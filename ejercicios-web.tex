%% ejercicios.tex
%%

%% Ejercicios (comunes para SAT y SARO), 2013-2014.

%%---------------------------------------------------------------------------
%%---------------------------------------------------------------------------
%%---------------------------------------------------------------------------
\section{Entrega de prácticas incrementales}
\label{sec:eje-entrega-practicas-incr}

Para la entrega de prácticas incrementales se utilizarán repositorios git públicos alojados en GitHub. Para cada práctica entregable los profesores abrirán un repositorio público en el proyecto CursosWeb~\footnote{\url{https://github.com/CursosWeb}}, con un nombre que comenzará por ``X--Serv--'', seguirá con el nombre del tema en el que se inscribe la práctica (por ejemplo, ``Python'' para el tema de introducción a Python) y el identificador del ejercicio (por ejemplo, ``Calculadora''). Este repositorio incluirá un fichero README.md, con el enunciado de la práctica, y cualquier otro material que los profesores estimen conveniente.

Cada alumno dispondrá de una cuenta en GitHub, que usará a efectos de entrega de prácticas. Esta cuenta deberá ser apuntada en una lista, en el sitio de la asignatura en el campus virtual, cuando los profesores se lo soliciten. Si el alumno desea que no sea fácil trazar su identidad a partir de esta cuenta, puede elegir abrir una cuenta no ligada a sus datos personales: a efectos de valoración, los profesores utilizará la lista anterior. Si el alumno lo desea, puede usar la misma cuenta en GitHub para otros fines, además de para la entrega de prácticas.

Para trabajar en una práctica, los alumnos comenzarán por realizar una copia (fork) de cada uno de estos repositorios. Esto se realiza en GitHub, visitando (tras haberse autenticado con su cuenta de usuario de GitHub para entrega de prácticas) el repositorio con la práctica, y pulsando sobre la opción de realizar un fork. Una vez esto se haya hecho, el alumno tendrá un fork del repositorio en su cuenta, con los mismos contenidos que el repositorio original de la práctica. Visitando este nuevo repositorio, el alumno podrá conocer la url para clonarlo, con lo que podrá realizar su clon (copia) local, usando la orden \verb|git clone|.

A partir de este momento, el alumno creará los ficheros que necesite en su copia local, los irá marcando como cambios con \verb|git commit| (usando previamente \verb|git add|, si es preciso, para añadirlos a los ficheros considerados por git), y cuando lo estime conveniente, los subirá a su repositorio en GitHub usando \verb|git push|.

Por lo tanto, el flujo normal de trabajo de un alumno con una nueva práctica será:

\begin{verbatim}
[En GitHub: visita el repositorio de la práctica en CursosWeb,
y le hace un fork, creando su propia copia del repositorio]

git clone url_copia_propia

[Se cera el directorio copia_propia, copia local del repositorio propio]

cd copia_propia
git add ... [ficheros de la práctica]
git commit .
git push
\end{verbatim}

Conviene visitar el repositorio propio en GitHub, para comprobar que efectivamente los cambios realizados en la copia local se han propagado adecuadamente a él, tras haber invocado \verb|git push|.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 01: Conceptos básicos de aplicaciones web}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Web 2.0}
\label{subsec:web-20}

\textbf{Enunciado:}

Seguramente has oído hablar muchas veces de la ``web 2.0''. ¿Qué es lo que significa esta expresión? Si puedes, cita referencias en la Red al respecto.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Última búsqueda}
\label{subsec:ultima-busqueda}

\textbf{Enunciado:}

¿Cómo mostrar la última búsqueda en un  buscador?

Se quiere que un cierto buscador web muestre a sus usuarios la última búsqueda que hicieron en él. Para ello, se utilizarán cookies. Son relevantes tres interacciones HTTP: la primera, en la que el navegador pide la página HTML con el formulario de búsquedas, la segunda, en la que el navegador envía la cadena de búsqueda que el usuario ha escrito en el navegador, y la tercera, que se realizará en cualquier momento posterior, en la que el navegador vuelve a pedir la página con el formulario de búsquedas, que ahora se recibe anotada con la cadena de la última búsqueda. Se pide indicar dónde van las cookies, cómo son éstas, y cómo solucionan el problema.

\textbf{Solución:}

Se puede hacer utilizando identificador de sesión en las cookies. Pero también es posible hacerlo sin que el servidor (el buscador) tenga que almacenar todos los identificadores de sesión  junto con la última búsqueda realizada, lo que tiene varias ventajas.

Para identificador de sesión, basta con un número aleatorio grande que se almacena en la cookie. La cookie la envía el buscador al navegador en la respuesta al HTTP GET que se realiza para obtener la página del buscador. Luego, esa cookie va en cada POST que hace el navegador (para realizar una nueva búsqueda). Si no se quiere que el buscador almacena la última pregunta para cada sesión, se puede enviar la propia búsqueda en la cookie.   

\textbf{Discusiones relacionadas:}

\begin{itemize}
\item Ventajas y desventajas de utilizar identificadores de sesión, o de almacenar las preguntas en cookies en el navegador.
\item ¿Serviría el mismo esquema para un servicio de banca electrónica? (en lugar de ``recordar'' la última pregunta, se quiere recordar qué usuario se autenticó.
\item Cómo implementarlo usando el identificador de usuario y la contraseña en la cookie. Implicaciones para la seguridad. El problema de la salida de la sesión.
\end{itemize}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Servicio horario}
\label{subsec:ej-servicio-horario}

\textbf{Enunciado:}

Queremos construir una aplicación web que cuando se consulta, devuelva la hora actual. Además, queremos que cuando se consulta por segunda vez, devuelva la hora actual y la hora en que se consultó por última vez. Explicar cómo se pueden usar cookies para conseguirlo.

\textbf{Enunciado avanzado:}

Igual que el anterior, pero se quiere que se muestre no sólo la hora en que se consultó por última vez, sino las horas de todas las consultas previas (además de la hora actual).

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Última búsqueda: números aleatorios o consecutivos}
\label{subsec:ultima-busqueda-aleconsec}

\textbf{Enunciado:}

En el ejercicio ``Última búsqueda'' (ejercicio~\ref{subsec:ultima-busqueda}) una de las soluciones pasa por usar cookies con identificadores de sesión. En principio, se han propuesto dos posibilidades para esos identificadores:

\begin{itemize}
\item Números enteros aleatorios sobre un espacio de números grande (por ejemplo entre 0 y $2^{128}-1$)
\item Números enteros consecutivos, comenzando por ejemplo por 0.
\end{itemize}

Comenta cuál de las dos soluciones te parece mejor, y si crees que alguna de ellas no sirve para resolver el problema. En ambos casos, indica las razones que te llevan a esa conclusión


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Espía a tu navegador}
\label{subsec:firebug}

\textbf{Enunciado:}

El navegador hace una gran cantidad de tareas interesantes para esta asignatura. Es muy útil poder ver cómo lo hace, y aprender de los detalles que veamos. De hecho, también, en ciertos casos, se puede modificar su comportamiento. Para todo esto, se pueden usar herramientas específicas. En nuestro caso, vamos a usar el módulo ``Firebug'' de Firefox (también disponible para otros navegadores).

El ejercicio consiste en:

\begin{itemize}
\item Instalar el módulo Firebug en tu navegador
\item Utilizarlo para ver la interacción HTTP al descargar una página web real.
\item Utilizarlo para ver el árbol DOM de una página HTML real.
\end{itemize}

Más adelante, lo utilizaremos para otras cosas, así que si quieres jugar un rato con lo que permite hacer Firebug, mucho mejor.

\textbf{Referencias}

Sitio web de Firebug: \url{https://getfirebug.com/}


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Cookies en tu navegador}
\label{subsec:cookies-navegador}

\textbf{Enunciado:}

Busca dónde tiene tu navegador accesible la lista de cookies que mantiene, y mírala. ¿Cuántas cookies tienes? ¿Qué sitio te ha puesto más cookies? ¿Cuál es la cookie más antigua que tienes? Explica también qué navegador usas (nombre y versión), desde cuándo más o menos, y cómo has podido ver las cookies en él.


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Cookies en tu navegador avanzado}
\label{subsec:cookies-navegador-2}

\textbf{Enunciado:}

Con el módulo adecuado, pueden editarse las cookies del navegador, lo que permite manejarlas con gran flexibilidad. Utiliza uno de estos módulos (por ejemplo, Cookies Manager$+$ para Firefox, o Firebug) para manipular las cookies que tenga tu navegador. Utilízalo para ``traspasar'' una sesión de un navegador a otro. Por ejemplo, puedes buscar las cookies que te autentican con un servicio (el campus virtual, una red social en la que tengas cuenta, etc.), guardarlas en un fichero, transferirlas a otro ordenador con otro navegador, e instalarlas en él, para comprobar cómo puedes continuar con la sesión desde él.

\textbf{Referencias}

Sitio web de Cookies Manager$+$: \url{https://addons.mozilla.org/firefox/addon/cookies-manager-plus/}


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Sumador simple con varios navegadores}
\label{subsec:sumador-simple-varios}

\textbf{Enunciado:}

Igual que el ejercicio ``Sumador simple'' (\ref{subsec:sumador-simple}), pero ahora puede haber varios navegadores invocando la aplicación web. Se supone que los navegadores no se interfieren (esto es, uno completa una suma antes de que otro la empiece).

\textbf{Comentario:}

No hacen falta modificaciones al código del ejercicio ``Sumador simple'' (\ref{subsec:sumador-simple}).


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Sumador simple con varios navegadores intercalados}
\label{subsec:sumador-simple-varios-intercalados}

\textbf{Enunciado:}

Igual que``Sumador simple con varios navegadores'' (\ref{subsec:sumador-simple-varios}), pero ahora un navegador puede comenzar una suma en cualquier momento, incluyendo momentos en los que otro navegador no la haya terminado.

\textbf{Comentarios:}

En una primera versión, se implementa con una cookie simple que incluye el primer operando, de forma que el servidor de aplicaciones no tiene que almacenar los operandos ni las cookies.

En una segunda versión, se utiliza una cookie de sesión más clásica, con un entero aleatorio, y se almacena el estado en un diccionario indexado por ese entero.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Sumador simple con rearranques}
\label{subsec:sumador-simple-rearranques}

\textbf{Enunciado:}

Igual que el ejercicio ``Sumador simple con varios navegadores intercalados'' (\ref{subsec:sumador-simple-varios-intercalados}), pero ahora desde que el navegador inicia la suma hasta que la completa, puede haberse caído la aplicación web.

\textbf{Comentario:}

La aplicación web tendrá que  almacenar su estado en almacenamiento estable. Hay que detectar cuál es ese estado, y almacenarlo en  un fichero, en  una base de datos, etc.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Traza de historiales de navegación por terceras partes}
\label{subsec:navegacion-terceras-partes}

Cuando un navegador realiza un GET sobre una página web HTML lanza a continuación, de forma automática, otras operaciones GET sobre los elementos cargables automáticamente que contenga esa página, como por ejemplo, las imágenes empotradas. Cada vez que se realiza uno de estos GET, se pueden recibir una o más cookies de los servidores que las sirven (y que en general pueden ser diferentes del que sirve la página HTML).

De esta forma, sirviendo imágenes para diferentes páginas HTML en diferentes sitios, una tercera parte puede trazar historiales de navegación, ligándolos a identificadores únicos. ¿Cómo?

Además, si la tercera parte en cuestión tiene acceso a información de un sitio web que permita identificar identidades, esos historiales pueden también ser ligados a identidades. ¿Cómo?

\textbf{Comentarios:}

La liga con identificadores únicos se puede lograr de varias formas, Por ejemplo se puede incluir en cada página HTML a trazar una imagen con nombre único, todas servidas por la tercera parte. La primera vez que sirve una imagen a un navegador dado, le envía también una cookie con identificador único. Todas las peticiones de imagen que se reciban serán escritas en un historial, junto con el identificador único de la cookie.

Para poder ligar este historial a una identidad, basta con que, en un servidor que ha identificado una identidad, sirva una imagen de la tercera parte con un nombre que permita posteriormente ligarlo a la identidad.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Trackers en páginas web}
\label{subsec:trackers-paginas-web}

Instala el \emph{plug-in} Lightbeam para tu navegador. Este \emph{plug-in} permite detectar todos los sitios web que se acceden al descargar una página, incluyendo los forzados por ``trackers'' (objetos incluidos en una página web para trazar a quienes descargan esa página). Utilízalo para encontrar páginas web con muchos trackers. Una vez lo hayas hecho, indica las dos páginas (de sitios distintos) en las que hayas encontrado más trackers.

\textbf{Referencias}

Sitio web de Lightbeam: \url{https://www.mozilla.org/lightbeam/}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Trackers en páginas web (Ghostery)}
\label{subsec:trackers-paginas-web-2}

Instala el \emph{plug-in} Ghostery para tu navegador. Este \emph{plug-in} permite detectar ``trackers'', objetos incluidos en una página web para trazar a quienes descargan esa página. Utilízalo para encontrar páginas web con muchos trackers. Una vez lo hayas hecho, indica las dos páginas (de sitios distintos) en las que hayas encontrado más trackers.

\textbf{Referencias}

Sitio web de Ghostery: \url{http://www.ghostery.com/}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 02: Servicios web que interoperan}



%%-----------------------------------------------------------------------------
\subsection{Arquitectura escalable}
\label{subsec:arq-escalable}

\textbf{Enunciado:}

Diseñar una arquitectura para una aplicación distribuida que cumpla las siguientes condiciones:

\begin{itemize}
\item Puede ser usada por millones de usuarios simultáneamente.
\item Hay miles de equipos de desarrollo trabajando sobre ella. Entre los equipos hay poca comunicación pero no deben tener conflictos entre sí.
\item Cada uno de los equipos podrían extender lo que habían hecho los otros sin que estos lo sepan y sin que la evolución de cada sistema rompiera la integración.
\end{itemize}

\textbf{Comentarios:}

Desde luego, hay otros sistemas, pero el web, entendido en sentido amplio, es uno que cumple bien estos requisitos.


%%-----------------------------------------------------------------------------
\subsection{Arquitectura distribuida}
\label{subsec:arq-distribuida}

\textbf{Enunciado:}

Diseñar una arquitectura para una aplicación distribuida que cumpla las siguientes condiciones:

\begin{itemize}
\item Pueda gestionar elementos en mi casa desde remoto, en particular, mi comida. Por tanto, tendrá que gestionar los alimentos que se encuentran en la nevera, la despensa, el bol de frutas, etc.
\item Pueda interactuar tanto con máquinas como con humanos
\item Sea lo más sencilla posible
\item Sea escalable
\end{itemize}

En particular, usando REST, define algunos recursos, y las operaciones que se podrían hacer sobre ellos. Explica también qué necesitaría para poder interoperar con los recursos correspondientes, por ejemplo, a la casa de tus amigos.

\textbf{Comentarios:}

Desde luego, hay muchas maneras de hacerlo y eso favorecerá el debate.

Una primera idea es modelar los elementos como objetos (la nevera, los alimentos, etc.) y hacerlo llegar de alguna manera al otro lado de la red, donde está mi portátil (esta es una solución que siguen muchos web services, o incluso CORBA). Hay que entender que esto hará que en el lado del portátil tengamos que conocer cómo funcionan los elementos (sus atributos y sus métodos). Es como tener que aprender el manual de instrucciones (los verbos) para cada cacharro que tengamos en la cocina.

Al ver esta solución, nos damos cuenta de que contamos en el otro lado con sustantivos. Éstos tienen una localización única, que especificamos mediante una URL. Asimismo, existe la URN, que permite especificar unívocamente un elemento según su nombre, pero se ha de tener en cuenta de que puede haber un URN para muchos elementos (es como el ISBN, que hay uno para toda la edición, o sea para muchos libros). Dado la URL localizamos un URN de manera unívoca.

Mientas, en el otro lado (en el cliente) tendremos un número mínimo de acciones (los verbos). Vemos el primero: GET. Éste no obtiene el sustantivo, sino una representación del mismo. Los sustantivos son recursos. Y estos recursos pueden venir expresados de varias maneras. Así, por ejemplo, si pedimos manzanas desde un portátil la representación podría ser una imagen muy detallada; para el móvil, la imagen será más pequeña; y si el que lo pide es una máquina, podría ser un XML. Vemos los demás métodos: PUT, POST y DELETE.

Vistos los métodos discutimos si cambian el estado (vemos que sólo GET no lo hace) y si el resultado de realizar varios consecutivos es igual a hacerlo una vez (lo que llamamos idempotencia, vemos que sólo POST no lo es).

Introducimos el concepto de elemento y colección de elementos (cuando pedimos una colección, nos da un listado de los elementos que contiene; este listado contiene enlaces a los mismos) y qué pasa cuando aplicamos un método a cada uno. Hacemos especial hincapié en la diferencia entre PUT y POST.

Introducimos el concepto de REST y sus reglas. Hay varias las hemos visto ya: URLs, enlaces, representaciones y métodos. Nos falta por ver que las comunicaciones son sin estado. Los recursos pueden tenerlo, pero no la comunicación. Discutimos qué significa esto con respecto a lo que hemos visto en la asignatura hasta ahora, en particular con respecto a las sesiones (y las cookies).

Finalmente discutimos porque la web no es así, si en realidad los diseñadores de HTTP habían diseñado el protocolo para que todo fuera REST. Comentamos que con los navegadores sólo podemos hacer GETs y POSTs (y contamos que podemos utilizar los demás métodos mediante plug-ins como Poster (ver ejercicio~\ref{subsec:inst-poster}). Mostramos que, más allá de los navegadores, ya estamos en disposición de crear programas para interactuar con servidores REST, de manera que podemos comunicar máquinas entre sí siguiendo estas reglas. Discutimos las ventajas de este enfoque en esos casos.

%%-----------------------------------------------------------------------------
\subsection{Listado de lo que tengo en la nevera}
\label{subsec:contenido-nevera}

\textbf{Enunciado:}

Vamos a diseñar una API REST para una aplicación que concreta el ejercicio ``Arquitectura distribuida'' (\ref{subsec:arq-distribuida}) en un caso bien simple: una aplicación web que mantenga la lista de lo que tengo en la nevera.

Supongamos que esta lista está compuesta únicamente por los items que tengo en la nevera en un momento dado (zanahorias, yogures, etc.) y un número natural para cada item que tengo, que expresa su cantidad. Por ejemplo, en un momento dado, la lista podría ser:

\begin{itemize}
\item Zanahorias: 5
\item Yogures: 4
\item Leche: 2
\end{itemize}

Si en este momento no tengo un determinado item en la nevera, no lo tengo en la lista. En otras palabras, no hay items con valor igual a 0.

La aplicación web la gestiono desde el móvil, con una app que puede hacer GET, PUT, POST y DELETE (usando HTTP). Cada vez que abro la puerta de la nevera, y meto o saco cosas de ella, utilizo la app del móvil para actualizar la lista en la aplicación web. Al hacerlo, la app del móvil siempre indica a la aplicación web la nueva cantidad que queda en la nevera. Esto es, no indica ``hay dos zanahorias más'', sino ``ahora hay 7 zanahorias''.

Se pide diseñar la API REST de esta aplicación web, identificando cuáles son los recursos relevantes, sus nombres, y describiendo todas las interacciones HTTP que soporten.

%%-----------------------------------------------------------------------------
\subsection{Sumador simple versión REST}
\label{subsec:sumador-simple-rest}

\textbf{Enunciado:}

Desarrollar una versión RESTful de ``Sumador simple'' (ejercicio~\ref{subsec:sumador-simple}). ¿Plantea problemas si se usa simultáneamente desde varios navegadores? ¿Plantea problemas si se cae el servidor entre dos invocaciones por parte del mismo navegador?

\textbf{Comentarios:}

Hay varias formas de hacer el diseño, pero por ejemplo, cada sumando podría ser un recurso, y el resultado obtenerse en un tercero (o bien como respuesta al actualizar el segundo sumando). Cada suma podría también realizarse en un espacio de nombres de recurso distinto (con su propio primer sumando, segundo sumando y resultado).


%%-----------------------------------------------------------------------------
\subsection{Calculadora simple versión REST}
\label{subsec:calc-simple-rest}

\textbf{Enunciado:}

Realizar una calculadora de las cuatro operaciones aritméticas básicas (suma, resta, multiplicación y división), siguiendo los principios REST, a la manera del sumador simple versión REST (ejercicio~\ref{subsec:sumador-simple-rest}).

\textbf{Comentarios:}

Este ejercicio, más que para proponer una solución concreta, está diseñado para debatir sobre las posibles soluciones que se le podrían dar. Por ejemplo, tenemos primero la versiones donde se supone un único usuario:

\begin{itemize}
\item Versión con un recurso por tipo de operación (``/suma'', ``resta'', etc.). Se actualiza con PUT, que envía los operandos (ej: 4,5), se consulta con GET, que devuelve el resultado (ej: 4+5=9).
\item Versión con un único recurso, ``/operacion''. Se actualiza con PUT, que envía en el cuerpo la operación (ej: 4+5), se consulta con GET, que devuelve el resultado (ej: 4+5=7).
\item Versión actualizando por separado los elementos de la operación, con un único recurso ``/operacion''. PUT podrá llevar en el cuerpo ``Primero: 4'' o ``Segundo: 5'', o ``Op: +''. Cada uno de ellos actualiza el elemento correspondiente de la operación. GET de ese recurso, devuelve el resultado de la operación con los elementos que tiene en este momento.
\item Versión actualizando por separado los elementos de la operación, con un único recurso ``/operación''. PUT podrá llevar en el cuerpo un número si es la primera o segunda vez que se invoca, un símbolo de operación si es la tercera. GET dará el resultado si se han especificado todos los elementos de la operación, error si no. Es ``menos REST'', en el sentido que guarda más estado en el lado del servidor. Pero cumple los requisitos generales de REST si consideramos que le cliente es responsable de mantener su estado y saber en qué fase de la operación está en cada momento.
\item Versión donde cada elemento se envía con un PUT a un recurso (``/operacion/primeroperando'', ``/operacion/segundooperando'', ``/operacion/signo''), y el resultado se obtiene con ``GET /operacion/resultado''. No es REST, porque el estado del recurso ``/operacion/resultado'' depende del estado de los otros recursos
.
\end{itemize}

También podemos extender el diseño a versiones con varios usuarios:

\begin{itemize}
\item Podría tenerse un identificador para cada operación. ``POST /operaciones'' podría devolver el enlace a una nueva operación creada, como ``/operaciones/2af434ad3''. Cada una de estas sumas se comportaría como las ``sumas con un usuario'' que se han comentado antes. ``DELETE  /operaciones/2af434ad3'' destruiría una operación.
\end{itemize}

\textbf{Material:}

\begin{itemize}
\item \texttt{simplecalc.py}: Programa con una posible solución a este ejercicio. Proporciona cuatro recursos ``calculadora'', uno para cada operación matemática (suma, resta, multiplicación, división). Cada calculadora mantiene un estado (operación matemática) que se actualiza con PUT y se consulta con GET.
\item Vídeo que muestra el funcionamiento de \texttt{simplecalc.py} \\
  \url{http://vimeo.com/31427714}
\item Vídeo que describe el programa \texttt{simplecalc.py} \\
  \url{http://vimeo.com/31430208}
\item \texttt{multicalc.py}: Programa con otra posible solución a este ejercicio. Proporciona un recurso para crear calculadoras (mediante POST). Al crear una calculadora se especifica de qué tipo (operación) es. Cada calculadora mantiene un estado (operación matemática) que se actualiza con PUT y se consulta con GET. Se apoya en las clases definidas en \texttt{simplecalc.py} para implementar las calculadoras.
\item \texttt{webappmulti.py}: Clase que proporciona la estructura básica para los dos programas anteriores (clase raíz de servicio web, de \emph{aplis}, etc.)
\end{itemize}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Cache de contenidos}
\label{subsec:cache-contenidos}

\textbf{Enunciado:}

Vamos a construir una aplicación web que no sólo recibe peticiones de un cliente, sino que también hace peticiones a otros servicios web. El ejercicio consiste en construir una aplicación que, dada una URL (sin ``http://'') como nombre de recurso, devuelve el contenido de la página correspondiente a esa URL. Esto es, si se le pide http://localhost:1234/gsyc.es/ devuelve el contenido de la página http://gsyc.es/. Además, lo guarda en un diccionario, de forma que si se le vuelve a pedir, lo devuelve directamente de ese diccionario.

%Puede usarse como base ``Django cms'' (ejercicio~\ref{subsec:django-cms}), y si se quiere, el módulo estándar de Python ``urllib''.
Puede usarse como base ContentApp, y si se quiere, el módulo estándar de Python urllib.

\textbf{Comentarios:}

Pueden discutirse muchos detalles de esta aplicación. Por ejemplo, cómo gestionar las cabeceras, y en particular las cookies. También, cómo saber si la página ha cambiado en el sitio original antes de decidir volver a bajarla (cabeceras relacionadas con ``cacheable'', peticiones ``HEAD'' para ver fechas, etc.)

Para la implementación de la aplicación sólo se pide lo más básico: no hay tratamiento de cabeceras, y no se vuelve a bajar el original una vez está en la cache.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Cache de contenidos anotado}
\label{subsec:cache-contenidos-anotado}

\textbf{Enunciado:}

Construir una aplicación como ``Cache de contenidos'' (ejercicio~\ref{subsec:cache-contenidos}), pero que anote cada página, en la primera línea, con un enlace a la página original, y que incluya también un enlace para ``recargar'' la página (volverla a refrescar a partir del original), otro enlace para ver el HTTP (de ida y de vuelta, si fuera posible) que se intercambió para conseguir la página original, y otro enlace para ver el HTTP de la consulta del navegador y de la respuesta del servidor al pedir esta página (de nuevo si fuera posible).

\textbf{Comentarios:}

Téngase en cuenta que por lo tanto cada página que sirva la aplicación, además de los contenidos  HTML correspondientes (obtenidos de la cache o directamente de Internet) tendrá cuatro enlaces en la primera línea:

\begin{itemize}
\item Enlace a la página original.
\item Enlace a un recurso de la aplicación que permita recargar.
\item Enlace a un recurso de la aplicación que permita ver el HTTP que se intercambió con el servidor que tenía la página.
\item Enlace a un recurso de la aplicación que permita ver el HTTP que se intercambió cuando se cargó en cache esa página.
\end{itemize}

Estos enlaces conviene introducirlos en el cuerpo de la página HTML que se va a servir. Así, por ejemplo, si la página que se bajó de Internet es como sigue:

\begin{verbatim}
<html>
  <head> ... </head>
  <body>
    Text of the page
  </body>
</html>
\end{verbatim}

Debería servirse anotada como sigue:

\begin{verbatim}
<html>
  <head> ... </head>
  <body>
    <a href="original_url">Original webpage</a>
    <a href="/recurso1">Reload</a>
    <a href="/recurso2">Server-side HTTP</a>
    <a href="/recurso3">Client-side HTTP</a></br>
    Text of the page
  </body>
</html>
\end{verbatim}

Para poder hacer esto, es necesario localizar el elemento $<body>$ en la página HTML que se está anotando. Hay que tener en cuenta que este elemento puede venir tal cual o con atributos, por ejemplo:

\begin{verbatim}
<body class="all" id="main">
\end{verbatim}

Por eso no basta con identificar dónde está la cadena ``$<body>$'' en la página, sino que habrá que identificar primero dónde está ``$<body$'' y, a partir de ahí, el cierre del elemento, ``$>$''. Será justo después de ese punto donde deberán colocarse las anotaciones. Para encontrar este punto puede usarse el método \texttt{find} de las variables de tipo \emph{string}, o expresiones regulares.

Para que los enlaces que se enlazan desde estas anotaciones funcionen, la aplicación tendrá que atender a tres nuevos recursos para cada página:

\begin{itemize}
\item /recurso1: Recarga de la página en la cache.
\item /recurso2: Devuelve el HTTP con el servidor (que tendrá que estar previamente almacenado en, por ejemplo, un diccionario).
\item /recurso3: Devuelve el HTTP con el navegador (que tendrá que estar previamente almacenado en, por ejemplo, un diccionario).
\end{itemize}

Naturalmente, cada página necesitará estos tres recursos, por lo tanto lo mejor será diseñar tres espacios de nombres donde estén los recursos correspondientes para cada una de las páginas. Por ejemplo, todos los recursos de recarga podrían comenzar por ``/reload/'', de forma que ``/reload/gsyc.es'' sería el recurso para recargar la página ``http://gsyc.es''.

Para poder almacenar el HTTP con el servidor, es importante darse cuenta de que el que se envía al servidor lo produce la propia aplicación. Si se usa \texttt{urllib}, no es posible acceder directamente a lo que se está enviando, pero se puede inferir a partir de lo que se indica a \texttt{urllib}. Por lo tanto, cualquier petición HTTP ``razonable'' para los parámetros dados será suficiente, aunque no sea exactamente lo que envíe \texttt{urllib}.

El HTTP que se recibe del servidor habrá que obtenerlo usando \texttt{urllib}, en la medida de lo posible.

Para poder almacenar el HTTP con el cliente, es importante darse cuenta de que el que se envía al navegador lo produce la propia aplicación, por lo que basta con almacenarlo antes de enviarlo. El que se recibe del navegador habrá que obtenerlo de la petición recibida.

%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos miltilingüe versión REST}
\label{subsec:contentappmulti}

\textbf{Enunciado:}

Diseño y construcción de ``Gestor de contenidos miltilingüe versión REST''. Retomamos la aplicación ContentApp, pero ahora vamos a proporcionarle una interfaz multilingüe simple. Para empezar, trabajaremos con español (``es'') e inglés (``en''). Siguiendo la filosofía REST, cada recurso lo vamos a tener ahora disponible en dos URLs distintas, según en qué idioma esté. Los recursos en español empezarán por ``/es/'', y los recursos en inglés por ``/en/''. Además, si a un recurso no se le especifica de esta forma en qué idioma está, se servirá en el idioma por defecto (si está disponible), o en el otro idioma (si no está en el idioma por defecto, pero sí en el otro). Como siempre, los recursos que no estén disponibles en ningún idioma producirán un error ``Resource not available''.

\textbf{Comentarios:}

Para construir esta aplicación puedes usar dos diccionarios de contenidos (uno para cada idioma), o quizás mejor un diccionario de diccionarios, donde para cada recurso tengas como dato un diccionario con los idiomas en que está disponible, que tienen a su vez como dato la página HTML a servir.


%%-----------------------------------------------------------------------------
\subsection{Sistema de transferencias bancarias}
\label{subsec:transferencias-bancarias}

\textbf{Enunciado:}

Diseñar un sistema RESTful sobre HTTP fiable para realizar una transferencia bancaria vía HTTP.

\begin{itemize}
\item Debe poder confirmarse que la transferencia ha sido realizada.
\item Debe poder prevenirse que la transferencia se haga más de una vez.
\item Datos de la transferencia: cuenta origen, cuenta destino, cantidad.
\item También debe poder consultarse el saldo de la cuenta (datos: cuenta)
\item En un segundo escenario, puede suponerse todo lo anterior, pero considerando que hay una contraseña que protege el acceso a operaciones sobre una cuenta data (una contraseña por cuenta), tanto transferencias como consultas de saldo
.
\end{itemize}

Indica el esquema de recursos (URLs) que ofrecerá la aplicación, y los verbos (comandos) HTTP que aceptará para cada uno, y con qué semántica.

%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos multilingüe preferencias del navegador}
\label{subsec:contentappmulti-navegador}

\textbf{Enunciado:}

Diseñar y construir la aplicación web ``Gestor de contenidos multilingüe preferencias del navegador''. En la aplicación ``Gestor de contenidos multilingüe versión REST'' (ejercicio~\ref{subsec:contentappmulti}) se especificaban como parte del nombre e recurso el idioma en que se quiere recibir un recurso. Pero el navegador tiene habitualmente una forma de especificar en qué idioma quieres recibir las páginas cuando están disponibles en varios. Para ver cómo funciona esto, prueba a cambiar tus preferencias idiomáticas en Firefox, y consulta la página \url{http://debian.org}.

Implementa una aplicación web que sea como la anterior, pero que además, haga caso de las preferencias del navegador con que la invoca, al menos para el caso de los idiomas ``es'' y ``en''.

\textbf{Material complementario:}
\begin{itemize}
\item Descripción de ``Accept-Language'' en la especificación de HTTP (RFC 2616) \\
  \url{http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4}
\end{itemize}

\textbf{Comentario:}

¿Qué recibe el servidor para poder hacer la selección de idioma? Utiliza una de tus aplicaciones para ver lo que le llega al servidor. Verás que lo que utiliza el navegador para indicar las preferencias idiomáticas del usuario es la cabecera ``Accept-Language''

%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos multilingüe con elección en la aplicación}
\label{subsec:contentappmulti-apli}

\textbf{Enunciado:}

Diseñar y construir la aplicación web ``Gestor de contenidos multilingüe con elección en la aplicación''. Ahora vamos a construir un servidor de contenidos multilingüe que además de los dos mecanismos anteriores (interfaz REST y preferencias del navegador, ejercicios~\ref{subsec:contentappmulti} y~\ref{subsec:contentappmulti-navegador}) permita que el usuario elija el idioma específicamente en la propia aplicación.

Para ello, el gestor de contenidos atenderá a peticiones GET sobre recursos de la forma ``/language/es'' (para indicar que se quieren recibir las páginas en español), ``/language/en'' (para indicar que se quieren recibir las páginas en inglés) o ``language/browser'' (para indicar que se quieren recibir las páginas en el idioma que indique las preferencias del navegador).

El mecanismo de especificación de idioma mediante nombre de recurso (``/en'' o /es'') tendrá precedencia sobre el mecanismo de especificación en la aplicación, y éste sobre el de preferencias del navegador.

Cada página incluirá, además del contenido en el idioma especificado, una lista (con enlaces) de los idiomas en que está disponible esa página, y una lista (con enlaces) de los idiomas que se pueden elegir en la aplicación. Por ejemplo, si estamos consultando una página en español que está disponible también en inglés, veremos un enlace ``This page in English'' que apuntará a la URL REST de esa página en inglés. Además, habrá enlaces a ``Ver páginas preferentemente en español'' (que apuntará al recurso /language/es), ``See pages preferently in English'' (que apuntará al recurso /language/en) y ``Ver páginas según preferencias del navegador'' (que apuntará a /language/browser).

\textbf{Comentario:}

Para implementar la elección especificándolo en la propia aplicación se podrán usar cookies, aunque no haya sistema de cuentas en la aplicación, como es el caso.

%%-----------------------------------------------------------------------------
\subsection{Sistema REST para calcular Pi}
\label{subsec:rest-pi}

\textbf{Enunciado:}

Diseñar un sistema RESTful sobre HTTP que permita calcular el número pi como una operación asíncrona.

\begin{itemize}
\item El usuario solicita el comienzo del cálculo indicando el número de decimales deseado
\item El usuario debe poder consultar a partir de ese momento el estado del cálculo
\end{itemize}

Indica el esquema de recursos (URLs) que ofrecerá la aplicación, y los verbos (comandos) HTTP que aceptará para cada uno, y con qué semántica.

Háganse dos versiones: en la primera, se supone que hay un sólo usuario (navegador) del sistema. En la segunda, puede haber varios, pero no simultáneamente: si un usuario solicita el comienzo del cálculo mientras hay otro cálculo en curso, le devuelve un mensaje de error.

\textbf{Comentario:}

Quien esté interesado puede realizar una implementación de una aplicación web para este diseño. Puede usar, por ejemplo, el método Monte Carlo, aplicando incrementalmente números cada vez más altos de números aleatorios.

\textbf{Materiales:}

Explicación del cálculo de Pi mediante el método Monte Carlo, incluyendo ejemplo en Python: \\
\url{http://www.eveandersson.com/pi/monte-carlo-circle}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 04: Introducción a XML}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Chistes XML}
\label{subsec:xml-chistes}

\textbf{Enunciado:}

Estudia y modifica el programa xml-parser-jokes.py (que funciona con el fichero jokes.xml), hasta que entiendas los rudimentos del manejo de reconocedores SAX con Python.

\textbf{Material:}

\begin{itemize}
  \item jokes.xml. Fichero XML con descripciones de chistes.
  \item xml-parser-jokes.py. Programa que lee el fichero anterior, y usando un parser SAX lo reconoce y muestra en pantalla el contenido de los chistes.
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Modificación del contenido de una página HTML}
\label{subsec:xml-modificacion-html}

\textbf{Enunciado:}

Estudia y modifica el documento HTML dom.html, de forma que:

\begin{itemize}
\item Al pulsar con el ratón sobre un texto, se recargue la página (invocando para ello una función JavaScript). Este texto ha de estar disponible para poder pulsar sobre él una vez la página haya cambiado de contenido.
\item Al pulsar con el ratón sobre un botón, se modificará alguna parte del contenido mostrando la hora y fecha del momento.
\end{itemize}

\textbf{Material:}

\begin{itemize}
  \item dom.html. Documento HTML, que incluye algo de código JavaScript, y que hay que modificar.
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Titulares de BarraPunto}
\label{subsec:xml-barrapunto}

\textbf{Enunciado:}

Descargar el fichero RSS de BarraPunto\footnote{\url{http://barrapunto.com}}, y construir un programa que produzca como salida sus titulares en una página HTML. Si se carga esa página en un navegador,  picando sobre un titular, el navegador deberá cargar la página de BarraPunto con la noticia correspondiente. Como base puede usarse lo aprendido estudiando los programas xml-parser-jokes.py y xml-parser-barrapunto.py.

\textbf{Material:}

\begin{itemize}
\item \url{http://barrapunto.com/index.rss}: URL del fichero RSS de BarraPunto.
\item xml-parser-barrapunto.py: Programa que muestre en pantalla los titulares y las URLs que se describen en el fichero barrapunto.rss.
\item barrapunto.rss: Fichero con el contenido del canal RSS de BarraPunto en un momento dado.
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con titulares de BarraPunto}
\label{subsec:contentapp-barrapunto}

\textbf{Enunciado:}

Partiendo de contentApp (``Gestor de contenidos'', ejercicio~\ref{subsec:contentapp}), realiza contentAppBarraPunto. Esta versión devolverá, para cada recurso para el cuál tenga un contenido asociado en el diccionario de contenidos, una página que incluirá el contenido en cuestión, y los titulares de BarraPunto (para cada uno, título y URL).

Para ello, podéis hacer por un lado una aplicación que sirva para bajar el canal RSS de la portada de BarraPunto, y lo almacene en un objeto persistente (usando, por ejemplo, Shelve). Por otro lado, contentBarraPuntoApp leerá, antes de devolver una página, ese objeto, y utilizará sus datos para componer esa página a devolver. 

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con titulares de BarraPunto versión SQL}
\label{subsec:contentapp-barrapunto-sql}

\textbf{Enunciado:}

Realiza contentDBAppBarraPuntoSQL, con la misma funcionalidad que contentAppBarraPunto (ejercicio~\ref{subsec:contentapp-barrapunto}), pero usando una base de datos SQLite en lugar de un diccionario persistente gestionado con Shelve.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con titulares de BarraPunto versión Django}
\label{subsec:contentapp-barrapunto-django}

\textbf{Enunciado:}

%% Realiza una aplicación Django con la misma funcionalidad que contentDBAppBarraPuntSQL (ejercicio~\ref{subsec:contentapp-barrapunto-sql}), pero usando el entorno de desarrollo Django.

Realiza una aplicación Django con la misma funcionalidad que ``Django cms'' (ejercicio~\ref{subsec:django-cms}), pero que devuelva para cada recurso para el cuál tenga un contenido asociado en su tabla de la base de datos una página que incluirá el contenido en cuestión, y los titulares de BarraPunto (para cada uno, título y URL).

%% Para ello, podéis hacer por un lado una aplicación que sirva para bajar el canal RSS de la portada de BarraPunto, y lo almacene en un objeto persistente (usando, por ejemplo, Shelve). Por otro lado, contentBarraPuntoApp leerá, antes de devolver una página, ese objeto, y utilizará sus datos para componer esa página a devolver. 

Para reutilizar código, puedes partir de ``Django cms'' (ejercicio~\ref{subsec:django-cms}) o  ``Django cms\_put'' (ejercicio~\ref{subsec:django-cms-put}).

En particular, puedes implementar la consulta a BarraPunto de una de las siguientes formas:

\begin{itemize}
\item Cada vez que se pida un recurso, se mostrará el contenido asociado a él, anotado con los titulares de BarraPunto, que se descargarán (vía canal RSS) en ese mismo momento.
\item Habrá un recurso especial, ``/update'', que se usará para actualizar una tabla con los contenidos de BarraPunto. Cuando se invoque este recurso, se bajarán los titulares (vía canal RSS) de BarraPunto, y se almacenarán en una tabla en la base de datos que mantiene Django. Cada vez que se pida cualquier otro recurso, se mostrará el contenido asociado a él, anotado con los titulares de BarraPunto, que se extraerán de esa tabla, sin volver a pedirlos a BarraPunto.
\end{itemize}

Basta con mostrar por ejemplo los últimos tres o cinco titulares de BarraPunto (cada uno como un enlace a la URL correspondiente).

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 04: Hojas de estilo CSS}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Django cms\_css simple}
\label{subsec:django-cms-css}

\textbf{Enunciado:}

Crea una hoja de estilo en la URL ``/css/main.css'' para manejar la apariencia de la página ``/about'' en ``Django cms\_put'' (ejercicio~\ref{subsec:django-cms-put}). La hoja tendrá el siguiente contenido:

\begin{verbatim}
body {
  margin: 10px 20% 50px 70px;
  font-family: sans-serif;
  color: black;
  background: white;
}
\end{verbatim}

La página ``/about'' tendrá el contenido que estimes conveniente. Ambos contenidos (el de ``/about'' y el de ``/css/main.css'') se subirán al gestor de contenidos mediante un PUT, igual que cualquier otro contenido.

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Django cms\_css elaborado}
\label{subsec:django-cms-css-2}

\textbf{Enunciado:}

Modifica tu solución para ``Django cms\_put'' (ejercicio~\ref{subsec:django-cms-put}) de forma que:

\begin{itemize}
\item Si el recurso está bajo ``/css/'', se almacene tal cual al recibirlo (mediante PUT) y se sirva tal cual (cuando se recibe un GET).
\item Si el recurso tiene cualquier otro nombre, se almacene de tal forma cuando se reciba (mediante PUT) que el contenido almacenado sea el cuerpo (lo que va en el elemento $<BODY>$) de las páginas que se sirvan (cuando se reciba el GET correspondiente). Para servir las páginas utiliza una plantilla (\emph{template}) que incluya el uso de la hoja de estilo ``/css/main.css'' para manejar la apariencia de todas las páginas.
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 05: AJAX}

Ejercicios con AJAX y tecnologías relacionadas.

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{SPA Sentences generator}
\label{subsec:spa-sentences-generator}

\textbf{Enunciado:}

Prueba el fichero sentences\_generator.html, que incluye una aplicación SPA simple que genera frases de forma aleatoria, a partir de componentes de tres listas de fragmentos de frases. En particular, observa dónde se obtiene una referencia al nodo del árbol DOM donde se quiere colocar la frase, y cómo se manipula éste árbol para colocarla ahí, una vez está generada.

Una vez lo hayas entendido, modifícalo para que en lugar de usar tres fragmentos para cada frase, use cuatro, cogiendo cada uno, aleatoriamente, de una lista de fragmentos.

\textbf{Material:}
\begin{itemize}
\item sentences\_generator.html: Aplicación SPA que muestra frases componiendo fragmentos.
\end{itemize}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Ajax Sentences generator}
\label{subsec:ajax-sentences-generator}

\textbf{Enunciado:}

Construye una aplicación con funcionalidad similar a ``SPA Sentences generator'' (ejercicio~\ref{subsec:spa-sentences-generator}), pero realizada mediante una aplicación AJAX que pide los datos a un servidor implementado en Django.

El servidor atenderá GET sobre los recursos /first, /second y /third, dando para cada uno de ellos la parte correspondiente (primera, segunda o tercera) de una frase, devolviendo un fragmento de texto aleatorio de una lista con fragmentos que tenga para cada uno de ellos (esto es, habrá una lista para los ``primeros'' fragmentos, otra para los segundos, y otra para los terceros).

La aplicación AJAX solicitará los tres fragmentos que necesita, y los compondrá mostrando la frase resultante, de forma similar a como lo hace la aplicación ``SPA Sentences generator''.

\textbf{Material:}

\begin{itemize}
\item words\_provider.tar.gz: Proyecto Django que sirve como servidor que proporciona fragmentos de frases para la aplicación AJAX anterior. Incluye apps/sentences\_generator.html, aplicación AJAX que muestra frases componiendo fragmentos que obtiene de un sitio web, utilizando llamadas HTTP síncronas, y apps/async\_sentences\_generator.html (similar, pero con llamadas asíncronas).
\end{itemize}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Gadget de Google}
\label{subsec:gadget-google}

\textbf{Enunciado:}

Inclusión de un gadget de Google, adecuadamente configurado, en una página HTML estática.

\textbf{Referencias:}

\url{http://www.google.com/ig/directory?synd=open}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Gadget de Google en Django cms}
\label{subsec:gadget-google-cms}

\textbf{Enunciado:}

Crear una versión del gestor de contenidos Django (Django cms, ejercicio~\ref{subsec:django-cms}) con un gadget de Google en cada página (el mismo en todas ellas).

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{EzWeb}
\label{subsec:ezweb}

\textbf{Enunciado:}

Abrir una cuenta en el sitio de EzWeb, y crear allí un nuevo espacio de trabajo donde se conecten algunos gadgets.

\textbf{Referencia:}

\url{http://ezweb.tid.es}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{EyeOS}
\label{subsec:eyeos}

\textbf{Enunciado:}

Abrir una cuenta en el sitio de EyeOS, y visitar el entorno que proporciona.

\textbf{Referencia:}

\url{http://www.eyeos.org/}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios P1: Introducción a Python}

Estos ejercicios pretenden ayudar a conocer el lenguaje de programación Python. Los ejercicios suponen que previamente el alumno se ha documentado sobre el lenguaje, usando las referencias ofrecidas en clase, u otras equivalentes que pueda preferir.

Aunque es fácil encontrar soluciones a los ejercicios propuestos, se recomienda al alumno que realice por si mismo todos ellos.

El primer ejercicio has de hacerlo directamente en el intérprete de Python (invocándolo sin un  programa fuente como argumento). Para los demás, puedes usar un editor (Emacs, gedit, o el que quieras) )o un IDE (Eclipse con el módulo PyDev, o el que quieras).

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Uso interactivo del intérprete de Python}
\label{subsec:practicas-interprete}

\textbf{Enunciado:}

Invoca el intérprete de Python desde la shell. Crea las siguientes
variables:

\begin{itemize}
\item un entero
\item una cadena de caracteres con tu nombre
\item una lista con cinco nombres de persona
\item un diccionario de cuatro
entradas que utilice como llave el nombre de uno de tus amigos y como valor su
número de móvil
\end{itemize}

Comprueba con la sentencia \verb|print nombre_variable| que todo lo
que has hecho es correcto.

Fíjate en particular que la lista mantiene el
orden que has introducido, mientras el diccionario no lo hace. Prueba a mostrar 
los distintos elementos de la lista y del diccionario con \verb|print|.

%%------------------------------------------------------------------------
%%------------------------------------------------------------------------
\subsection{Haz un programa en Python}
\label{subsec:eje-python-primer-programa}

\textbf{Enunciado:}

Haz un programa en Python que haga cualquier cosa, y escriba algo en la salida estándar (en el terminal, cuando lo ejecutes normalmente).

%En tu respuesta a este ejercicio, explica brevemente qué hace, y súbelo como anexo a esa respuesta (opción "Agregar" cuando estés editando la respuesta).

%%------------------------------------------------------------------------
%%------------------------------------------------------------------------
\subsection{Tablas de multiplicar}
\label{subsec:eje-python-tablas}

\textbf{Enunciado:}

Utilizando bucles for, y funciones range(), escribe un programa que muestre en su salida estándar (pantalla) las tablas de multiplicar del 1 al 10, de la siguiente forma:

\begin{verbatim}
Tabla del 1
-----------
1 por 1 es 1
1 por 2 es 2
1 por 3 es 3
...
1 por 10 es 10
Tabla del 2
-----------
2 por 1 es 2
2 por 2 es 4
...
Tabla del 10
------------
...
10 por 10 es 100
\end{verbatim}

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Ficheros y listas}
\label{subsec:ficheros-listas}

\textbf{Enunciado:}

Crea un script en Python que abra el fichero \verb|/etc/passwd|, tome todas sus líneas en una lista de Python e imprima, para cada identificador de usuario, la shell que utiliza.

Imprime también el número de usuarios que hay en esta máquina. Utiliza para
ello un método asociado a la lista, no un contador de la iteración.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Ficheros, diccionarios y excepciones}
\label{subsec:ficheros-dic-excep}

\textbf{Enunciado:}

Modifica el script
anterior, de manera que en vez de imprimir para cada identificador de usuario el tipo
de shell que utiliza, lo introduzca en un diccionario. Una vez introducidos todos, imprime por pantalla los valores para el usuario 'root' y para el
usuario 'imaginario'. El segundo produce un error, porque no existe. ¿Sabrías evitarlo mediante el uso de
excepciones?


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Calculadora}
\label{subsec:calculadora}

\textbf{Enunciado:}

Crea un programa que sirva de calculadora y que incluya las funciones
básicas (sumar, restar, multiplicar y dividir). El programa ha de poder ejecutarse desde la línea de comandos de la siguiente manera: \texttt{python calculadora.py
función operando1 operando2}. No olvides capturar las excepciones.

\newpage

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\section{Ejercicios P2: Aplicaciones web simples}

Estos ejercicios presentan al alumno unas pocas aplicaciones web que, aunque de funcionalidad mínima, van introduciendo algunos conceptos fundamentales.

%%-----------------------------------------------------------------------
%%-----------------------------------------------------------------------
\subsection{Aplicación web hola mundo}
\label{subsec:aplweb-hola-mundo}

\textbf{Enunciado:}

Construir una aplicación web, en Python, que muestre en el navegador ``Hola mundo'' cuando sea invocada. La aplicación usará únicamente la biblioteca socket. Construir la aplicación de la forma más simple posible, mientras proporcione correctamente la funcionalidad indicada.

\textbf{Motivación:}

Este ejercicio sirve para construir el primer ejemplo de aplicación web. Con ella se muestra ya la estructura típica genérica de una aplicación web: inicialización y bucle de atención a peticiones (a su vez dividido en recepción y análisis de petición, proceso y lógica y de aplicación, y respuesta). Todo está muy simplificado: no se hace análisis de la petición, porque se considera que todo vale, no se realiza proceso de la petición, porque siempre se hace lo mismo, y la respuesta es en realidad mínima.

Aunque no se usará mucho en la asignatura la biblioteca socket (pues trabajaremos a niveles de abstracción superiores), esta práctica sirve para ayudar a entender los detalles que normalmente oculta un marco de desarrollo de aplicaciones web.

La práctica también sirve para introducir el esquema típico de prueba (carga de la página principal de la aplicación con un navegador, colocación en un puerto TCP de usuario, etc.).

\textbf{Material:}

Se ofrecen dos soluciones en \verb|https://github.com/CursosWeb/X-Serv-14.1-WebServer|. La más simple es \verb|servidor-http-simple.py|. La otra, \verb|servidor-http-simple-2.py|, permite conexiones desde fuera de la máquina huésped, y es capaz de reusar el puerto de forma que se puede rearrancar en cuanto muere.


%%---------------------------------------------------------------------
%%---------------------------------------------------------------------
\subsection{Variaciones de la aplicación web hola mundo}
\label{subsec:aplweb-hola-mundo-var}

\textbf{Enunciado:}

Basándose en la aplicación ``Hola mundo'' construida para el ejercicio~\ref{subsec:aplweb-hola-mundo}, crear tres aplicaciones diferentes, con la siguiente funcionalidad cada una:

\begin{itemize}
\item Aplicación web que devuelva siempre la misma página HTML, que tendrá que tener al menos una imagen (usando un elemento IMG).

\item Aplicación web que devuelva un código de error 404 y muestre un mensaje en el navegador.

\item Aplicación web que produzca una redirección a la página \url{http://gsyc.es/}
\end{itemize}

\textbf{Material:}

%Soluciones de referencia:

%\begin{itemize}
%\item \verb|02-aplicaciones-web-simples/servidor-http-simple-img.py|
%\item \verb|02-aplicaciones-web-simples/servidor-http-simple-404.py|
%\item \verb|02-aplicaciones-web-simples/servidor-http-simple-301.py|
%\end{itemize}

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Aplicación web generadora de URLs aleatorias}
\label{subsec:aplweb-urls-aleatorias}

\textbf{Enunciado:}

Construcción de una aplicación web que devuelva URLs aleatorias. Cada vez que os conectéis al servidor, debe aparecer en el navegador ``Hola. Dame otra'', donde ``Dame otra'' es un enlace a una URL aleatoria bajo \verb|localhost:1234| (esto es, por ejemplo, \url{http://localhost:1234/324324234}). Esa URL ha de ser distinta cada vez que un navegador se conecte a la aplicación.

\textbf{Motivación:}

Explorar una aplicación web como extensión muy simple de ``Aplicación web hola mundo''.

%%-----------------------------------------------------------------------------
\subsection{Aplicación redirectora}
\label{subsec:aplweb-redirectora}

\textbf{Enunciado:}

Construir un programa en Python que sirva cualquier invocación que se le realice con una redirección (códigos de resultado HTTP en el rango 3xx) a otro recurso (aleatorio) de si mismo. 

\textbf{Comentarios:}

Este programa se realiza muy fácilmente a partir de la solución de ``Aplicación web generadora de URLs aleatorias'' (ejercicio~\ref{subsec:aplweb-urls-aleatorias}).

Para poder observar con más facilidad en el navegador lo que está ocurriendo, se puede hacer que la aplicación devuelva, en el cuerpo de la respuesta HTTP, un texto HTML indicando que se va a realizar una redirección, y a qué url va a realizarse. Para que este mensaje sea visible durante un tiempo razonable, se puede hacer que la aplicación, al recibir una petición, se quede ``parada'' durante unos segundos antes de contestar con la redirección.

\textbf{Motivación:}

Entender cómo funciona la redirección, y cómo reacciona un navegador ante ella.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Sumador simple}
\label{subsec:sumador-simple}

\textbf{Enunciado:}

Construir una aplicación web que suma en dos fases. En la primera, invocamos una URL del tipo \url{http://sumador.edu/5}, aportando el primer sumando (el número que aparece como nombre de recurso). En la segunda, invocamos una URL similar, proporcionando el segundo sumando. La aplicación nos devuelve el resultado de la suma. En esta primera versión, suponemos que la aplicación es usada desde un solo navegador, y que las URLs siempre le llegan ``bien formadas''.

\textbf{Nota:}

Muchos navegadores, cuando se invoca con ellos una URL, lanzan un GET para ella, y a continuación uno o varios GET para el recurso \texttt{favicon.ico} en el mismo sitio. Por ello, hace falta tener en cuenta este caso para que funcione la aplicación web con ellos.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Clase servidor de aplicaciones}
\label{subsec:clase-serv-aplis}

\textbf{Enunciado:}

Reescribe el programa ``Aplicación web hola mundo'' usando clases, y reutilizándolas, haz otro que devuelva ``Adiós mundo cruel'' en lugar de ``Hola mundo''. Para ello, define una clase \texttt{webApp} que sirva como clase raíz, que al especializar permitirá tener aplicaciones web que hagan distintas cosas (en nuestro caso, \texttt{holaApp} y \texttt{adiosApp}).

Esa clase \texttt{webApp} tendrá al menos:

\begin{itemize}
\item Un método \texttt{Analyze} (o \texttt{Parse}), que devolverá un objeto con lo que ha analizado de la petición recibida del navegador (en el caso más simple, el objeto tendrá un nombre de recurso)
\item Un método \texttt{Compute} (o \texttt{Process}), que recibirá como argumento el objeto con lo analizado por el método anterior, y devolverá una lista con el código resultante (por ejemplo, ``200 OK'') y la página HTML a devolver
\item Código para inicializar una instancia que incluya el bucle general de atención a clientes, y la gestión de sockets necesaria para que funcione.
\end{itemize}

Una vez la clase \texttt{webApp} esté definida, en otro módulo define la clase \texttt{holaApp}, hija de la anterior, que especializará los métodos Parse y Process como haga falta para implementar el ``Hola mundo''.

El código \verb|__main__| de ese módulo instanciará un objeto de clase \texttt{holaApp}, con lo que tendremos una aplicación ``Hola mundo'' funcionando.

Luego, haz lo mismo para \texttt{adiosApp}.

Conviene que en el módulo donde se defina la clase \texttt{webApp} se incluya también código para, en caso de ser llamado como programa principal, se cree un objeto de ese tipo, y se ejecute una aplicación web simple.

\textbf{Motivación:}

Explorar el sistema de clases de Python, y a la vez construir la estructura básica de una aplicación web con un esquema muy similar al que proporciona el módulo Python \texttt{SocketServer}.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Clase servidor de aplicaciones, generador de URLs aleatorias}
\label{subsec:aplweb-clase-urls-aleatorias}

\textbf{Enunciado:}

Realiza el servidor especificado en el ejercicio ``Aplicación web generadora de URLs aleatorias'' (ejercicio~\ref{subsec:aplweb-urls-aleatorias}) utilizando el esquema de clases definido en el ejercicio ``Clase servidor de aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis}).


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Clase servidor de aplicaciones, sumador}
\label{subsec:clase-sumador-simple}

\textbf{Enunciado:}

Realizar el servidor especificado en el ejercicio ``Sumador simple'' (ejercicio~\ref{subsec:sumador-simple}) utilizando el esquema de clases definido en el ejercicio ``Clase servidor de aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis}).

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Clase servidor de varias aplicaciones}
\label{subsec:clase-serv-aplis-multi}

\textbf{Enunciado:}

Realizar una nueva clase, similar a la que se construyó en el ejercicio ``Clase servidor de aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis}), pero preparada para servir varias aplicaciones (\emph{aplis}). Cada \emph{apli} se activará cuando se invoquen recursos que comiencen por un cierto prefijo.

Cada una de estas \emph{aplis} será a su vez una instancia de una clase con origen en una básica con los dos métodos ``parse'' y ``process'', con la misma funcionalidad que tenían en ``Clase servidor de aplicaciones''. Por lo tanto, para tener una cierta apli, se extenderá la jerarquía de clases para \emph{aplis} con una nueva clase, que redefinirá ``parse'' y ``process'' según la semántica de la apli.

Para especificar qué \emph{apli} se activará cuando llegue una invocación a un nombre de recurso, se creará un diccionario donde para cada prefijo se indicará la instancia de \emph{apli} a invocar. Este diccionario se pasará como parámetro al instanciar la clase que sirve varias aplicaciones.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Clase servidor, cuatro aplis}
\label{subsec:clase-serv-aplis-varias}

\textbf{Enunciado:}

Utilizando la clase creada para ``Clase servidor de varias aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis-multi}), crea una una aplicación web con varias aplis:

\begin{itemize}
\item Si se invocan recursos que comiencen por ``/hola'', se devuelve una página HTML en la que se vea el texto ``Hola''.
\item Si se invocan recursos que comiencen por ``/adios'', se devuelve una página HTML en la que se vea el texto ``Adiós''.
\item Si se invocan recursos que comiencen por ``/suma/'', se proporciona la funcionalidad de ``Sumador simple'' (ejercicio~\ref{subsec:sumador-simple}), esperando que los sumandos se incluyan justo a continuación de ``/suma/''.
\item Si se invocan recursos que comiencen por ``/aleat/'', se proporciona la funcionalidad de ``Aplicación web generadora de URLs aleatorias'' (ejercicio~\ref{subsec:aplweb-urls-aleatorias}).
\end{itemize}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Herramientas de Web Developer}
\label{subsec:inst-web-developer}

\textbf{Enunciado:}

Introducción a las herramientas de \emph{Web Developer}, que ayudan en el desarrollo
y depuración de aplicaciones web en Firefox.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Ejercicios P3: Introducción a Django}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Instalación de Django}
\label{subsec:django-install}

\textbf{Enunciado:}

Instala la versión de Django que utilizaremos en prácticas.

\textbf{Comentarios:}

Utilizaremos la versión Django 1.7.*

\textbf{Material:}

\begin{itemize}
\item Descarga de Django: \url{http://www.djangoproject.com/download/}
\item Transparencias ``Introducción a Django''
\end{itemize}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django Intro}
\label{subsec:django-intro}

\textbf{Enunciado:}

Realización de un proyecto Django de prueba (myproject), siguiendo el ejemplo de las transparencias ``Introducción a Django''. Creación de las tablas de su base de datos, con Django, y consulta de la base de datos creada con sqlitebrowser.

\textbf{Material:}

Se puede encontrar un ejemplo de solución del ejercicio ``Django intro'' en el siguiente repositorio en GitHub: \url{https://github.com/CursosWeb/X-Serv-15.5-Django-Intro}.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django primera aplicación}
\label{subsec:django-primera}

\textbf{Enunciado:}

Realización de una aplicación Django que haga cualquier cosa, aún sin usar datos en almacenamiento estable. Por ejemplo, puede simplemente responder a ciertos recursos con páginas HTML definidas en el propio programa (en el correspondiente fichero \texttt{views.py}).

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django calc}
\label{subsec:django-calc}

\textbf{Enunciado:}

Realizar una calculadora con Django. Esta calculadora responderá a URLs de la forma ``/num1+num2'', ``/num1*num2'', ``/num1-num2'', ``/num1/num2'', realizando las operaciones correspondientes, y devolviendo error ``Not Found'' para las demás.

\textbf{Material:}

calc.tar.gz: Ejemplo de solución del ejercicio ``Django calc''

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms}
\label{subsec:django-cms}

\textbf{Enunciado:}

Realizar una sistema de gestión de contenidos muy simple con Django. Corresponderá con la funcionalidad de ``contentApp'' (ejercicio~\ref{subsec:contentapp}), almacenando los contenidos en una base de datos. La aplicación Django se ha de llamar \texttt{cms}.

El ejercicio ha de entregarse en el siguiente repositorio en GitHub: 
\url{https://github.com/CursosWeb/X-Serv-15.5-Django-CMS}. El repositorio contiene
un archivo check.py para comprobar que se han entregado todos los fichero necesarios (básicamente todos los ficheros con código Python del proyecto (\texttt{manage.py} y los contenidos en el directorio \texttt{myproject} y de la aplicación en \texttt{cms}, así como la base de datos en un fichero \texttt{db.sqlite3}), además de comprobar que el código en
\texttt{views.py} sigue con las reglas de estilo de Python (PEP8).

%\textbf{Material:}
%
%cms.tar.gz: Ejemplo de solución del ejercicio ``Django cms''


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_put}
\label{subsec:django-cms-put}

\textbf{Enunciado:}

Realizar una sistema de gestión de contenidos muy simple con Django. Corresponderá con la funcionalidad de ``contentPutApp'' (ejercicio~\ref{subsec:contentputapp}), almacenando los contenidos en una base de datos. En otras palabras, será como ``Django cms'' (ejercicio~\ref{subsec:django-cms}), añadiendo la funcionalidad de que el usuario pueda poner contenidos mediante PUT, tal y como se explicó en el ejercicio de ``contentPutApp''. La aplicación Django se ha de llamar \texttt{cms\_put}.


\textbf{Comentario:}

Para realizar este ejercicio, consultar el manual de Django, donde explica cómo se comporta el objeto HTTPRequest, que es siempre primer argumento en los métodos que estamos definiendo en \texttt{views.py}. En particular, nos interesarán sus atributos ``method'' (que sirve para saber si nos está llegando un GET o un PUT) y ``body'', que nos da acceso a los datos (cuerpo) de la petición. A pesar de su nombre, este último atributo tiene esos datos tanto si la petición es un POST como si es un PUT. 

El ejercicio ha de entregarse en el siguiente repositorio en GitHub: 
\url{https://github.com/CursosWeb/X-Serv-15.6-Django-CMS_PUT}. El repositorio contiene
un archivo check.py para comprobar que se han entregado todos los fichero necesarios (básicamente todos los ficheros con código Python del proyecto (\texttt{manage.py} y los contenidos en el directorio \texttt{myproject} y de la aplicación en \texttt{cms}, así como la base de datos en un fichero \texttt{db.sqlite3}), además de comprobar que el código en
\texttt{views.py} sigue con las reglas de estilo de Python (PEP8).

%\textbf{Material:}
%
%cms\_put.tar.gz: Ejemplo de solución del ejercicio ``Django cms\_put''.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_users}
\label{subsec:django-users}

\textbf{Enunciado:}

Realizar un proyecto Django con la misma funcionalidad que ``Django cms\_put'', pero incluyendo un módulo de administración (lo que proporciona el ``Admin site'' de Django) y recursos para login y logout de usuarios. Además, cada página de contenidos (o cada mensaje indicando que una página no está disponible) deberá quedar anotada con la cadena ``Not logged in. Login'' (siendo ``Login'' un enlace al recurso de login) si no se está autenticado como usuario, o con la cadena ``Logged in as name. Logout'' (siendo ``name'' el nombre de usuario, y ``Logout'' un enlace al recurso de logout) si se está autenticado como usuario.

\textbf{Comentarios:}

\begin{itemize}
  \item Cada página tendrá, por tanto, la misma funcionalidad que cms\_put, pero además una línea en la parte superior que dependerá de si el usuario que la visita está registrado o no.

  \item Se puede ver cómo realizar la funcionalidad de login y de logout en las páginas de Django, en particular, en \url{https://docs.djangoproject.com/en/dev/topics/auth/default/#auth-web-requests}.

  \item No hace falta tener una página de registro. Si queremos registrar un usuario, lo haríamos a través del interfaz de ``admin''.
\end{itemize}

%Las aplicación Django ``Admin site'', entre otras, utiliza el middleware CSRF (protección frente a ``Cross Site Request Forgery''), que hay que tener en cuenta, especialmente en los formularios POST. En particular, es importante asegurarse de que se han referenciado los módulos de CSRF en settings.py:

%\begin{verbatim}
%MIDDLEWARE_CLASSES = (
%    ...
%    'django.middleware.csrf.CsrfViewMiddleware',
%    'django.middleware.csrf.CsrfResponseMiddleware',
%    ...
%\end{verbatim}

%Más información sobre este tema: \\
%\url{http://docs.djangoproject.com/en/dev/ref/contrib/csrf/}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_users\_put}
\label{subsec:django-users-put}

\textbf{Enunciado:}

Realizar un proyecto Django con la misma funcionalidad que ``Django cms\_users'' (ejercicio~\ref{subsec:django-users}), tratando de que el proceso de login y logout sea lo más razonable posible e incluyendo la funcionalidad de que sólo los usuarios que estén autenticados pueden cambiar el contenido de cualquier página, mientras que los que no lo están sólo pueden ver las páginas (funcionalidad similar a la de ``Gestor de contenidos con usuarios'').

Repositorio en GitHub para entregar el ejercicio: \\ 
\url{https://github.com/CursosWeb/X-Serv-15.8-CmsUsersPut}.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_templates}
\label{subsec:django-templates}

\textbf{Enunciado:}

Realizar un proyecto Django con la misma funcionalidad que ``Django cms\_users\_put'' (ejercicio~\ref{subsec:django-users-put}), pero atendiendo a una nueva familia de recursos: ``/annotated/''. Cualquier recurso que comience con ``/annotated/'' se servirá usando una plantilla, y por lo demás, con la misma funcionalidad que teníamos en ``Django cms\_users\_put'' al recibir un GET para el nombre de recurso.

Repositorio en GitHub para entregar el ejercicio: \\ 
\url{https://github.com/CursosWeb/X-Serv-15.9-Django-CMS-Templates}.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_post}
\label{subsec:django-post}

\textbf{Enunciado:}
 Realizar un proyecto Django con la misma funcionalidad que ``Django cms\_templates'' (ejercicio~\ref{subsec:django-templates}), pero atendiendo a una nueva familiar de recursos: ``/edit/''. Cuando se acceda con un GET a un recurso que comience por ``/edit'', la aplicación web devolverá un formulario que permita editarlo (si se detecta un usuario autenticado, y si el nombre de recurso existe como página en la base de datos de la aplicación). Ese formulario tendrá un único campo que se precargará con el contenido de esa página. Si se accede con POST a un recurso que comience por ``/edit/'', se utilizará el valor que venga en él para actualizar la página correspondiente, si el usuario está autenticado y la página existe. Además, volverá a devolver el formulario igual que con el GET, para que el usuario pueda continuar editando si así lo desea.
 
Repositorio en GitHub para entregar el ejercicio: \\
\url{https://github.com/CursosWeb/X-Serv-15.10-Django-CMS-POST}.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_forms}
\label{subsec:django-forms}

\textbf{Enunciado:}

Realizar el ejercicio ``Django cms\_post'' (ejercicio~\ref{subsec:django-post}) utilizando la clase Forms de Django. 

Además, se ha de intentar que un cambio en el modelo (p.ej. añadir un campo nuevo) sólo afecte al modelo y a la clase Form derivada del mismo, y pueda realizarse sin modificar ni las vistas ni las plantillas.

Repositorio en GitHub para entregar el ejercicio: \\ 
\url{https://github.com/CursosWeb/X-Serv-15.11-Django-cms-forms}.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django feed\_expander}
\label{subsec:django-feed-expander}

Utilizando Django y, en la medida que te parezca conveniente, \texttt{feedparser.py} y \texttt{BeautifulSoup.py}, realiza un servicio que expanda el contenido del canal de un usuario de Twitter. El servicio atenderá peticiones a recursos de la forma \verb|/feed/user| (siendo  \texttt{user} el identificador de un usuario de Twitter), devolviendo una página HTML con:

\begin{itemize}
\item Los cinco últimos \emph{tweets} del usuario.
\item Para cada uno de ellos, la lista de URLs que incluye (considerando como tales, por ejemplo, las subcadenas de caracteres delimitadas por espacios y que comiencen por ``http://''.
\item Para cada una de estas URLs:
  \begin{itemize}
  \item El texto del primer elemento $<p>$ de la página correspondiente, si existe.
  \item Las imágenes (identificadas como elementos $<img>$ que contenga la página correspondiente, si existen.
  \end{itemize}
\end{itemize}

Los canales de usuarios de Twitter están disponibles en formato RSS en URLs como \url{https://api.twitter.com/1/statuses/user_timeline.rss?screen_name=user}, para el usuario \texttt{user}.

Pueden usarse también las bibliotecas \texttt{urllib2} para la descarga de páginas mediante HTTP, y urlparse para manipular URLs (ambos son módulos estándar de Python).

\textbf{Referencias:}

\begin{itemize}
\item Documentación sobre feedparser.py (vía WayBack Machine): \\
  \url{http://web.archive.org/web/20110625112257/http://feedparser.org/docs/}
\item Presentación sobre feedparser.py: \\
  \url{http://www.slideshare.net/LindseySmith1/feedparser}
\item Documentación sobre BeautifulSoup.py: \\
  \url{http://www.crummy.com/software/BeautifulSoup/documentation.html}
\end{itemize}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django feed\_expander\_db}
\label{subsec:django-feed-expander-db}

Realiza un servicio que proporcione la misma funcionalidad que ``Django feed\_expander'' (ejercicio~\ref{subsec:django-feed-expander}), pero almacenando los datos en tablas en una base de datos. Más en detalle:

\begin{itemize}
\item El recurso \verb|/feed/user| seguirá haciendo lo mismo, para el usuario ``user'' de Twitter. Pero además de mostrar la página web resultante, almacenará entablas en la base de datos:

  \begin{itemize}
  \item Los cinco últimos \emph{tweets} del usuario, y el usuario al que se refieren
  \item La lista de URLs de cada \emph{tweet}
  \item El texto del primer elemento $<p>$ de la página referenciada por cada URL.
  \item Las imágenes de dicha página.
  \end{itemize}

En todos estos casos, la información se añadirá a la que haya ya previamente en las tablas correspondientes.

\item El recurso \verb|/db/user| mostrará la misma página que se muestra para \verb|/feed/user|, pero incluyendo toda la información disponible en la base de datos para ese usuario (esto es, no limitado a los cinco últimos \emph{tweets}, si hubiera más den la base de datos). Para mostrar la página mencionada, no se accederá a ningún recurso externo: sólo a la información en la base de datos.
\end{itemize}

\textbf{Comentarios:}

Se pueden realizar varios diseños de tablas en la base de datos para este ejercicio. Entre ellos, se sugieren los basados en el siguiente esquema:

\begin{itemize}
\item Tabla de \emph{tweets}, con dos campos: usuarios y \emph{tweets}, ambos cadenas de texto (además, Django mantendrá un campo id para cada \emph{tweet}).
\item Tabla de URLs, con dos campos: id de \emph{tweet} y URL, el primero un id, el segundo cadena de texto (además, Django mantendrá un campo id para cada URL).
\item Tabla de textos, con dos campos: id de URL y texto (contenido de $<p>$, cadena de texto).
\item Tabla de imágenes, con dos campos: id de URL e imagen (cadena de texto con la URL de la imagen).
\end{itemize}

Desde luego, este esquema se puede simplificar y complicar, pero quizás sea un buen punto medio para empezar a trabajar.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Ejercicios P4: Servidores simples de contenidos}

Construcción de algunos servidores de contenidos que permitan comprender la estructura básica de una aplicación web, y de cómo implementarlos aprovechando algunas características de Python.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Clase contentApp}
\label{subsec:contentapp}

\textbf{Enunciado:}

Esta clase, basada en el esquema de clases definido en el ejercicio ``Clase servidor de aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis}), sirve el contenido almacenado en un diccionario Python. La clave del diccionario es el nombre de recurso a servir, y el valor es el cuerpo de la página HTML correspondiente a ese recurso.

La solución de este ejercicio se encuentra disponible en el siguiente repositorio de GitHub:
\url{https://github.com/CursosWeb/X-Serv-16.3-contentPutApp}.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Instalación y prueba de Poster}
\label{subsec:inst-poster}

\textbf{Enunciado:}

Instalación y prueba de Poster, add-on de Firefox

\textbf{Referencias:}

Poster Firefox add-on: \\
\url{https://addons.mozilla.org/en-US/firefox/addon/2691/}

%%----------------------------------------------------------------------------
\subsection{Clase contentPutApp}
\label{subsec:contentputapp}

\textbf{Enunciado:}

Construcción de la clase ``contentPutApp'', similar a contentApp (ejercicio~\ref{subsec:contentapp}). En este caso, la clase permite la actualización del contenido mediante peticiones HTTP PUT. Para probarla, se puede usar el add-on de Firefox llamado ``Poster''. La clase será minimalista, basta con que funcione con ``Poster''.

Opcionalmente, puede trabajarse en conseguir que un servidor construido con la clase anterior funcione con Bluefish. Bluefish es un editor de contenidos, que puede cargar una página especificando su URL, y que una vez modificada, puede enviarla, usando PUT, de nuevo a la misma URL. Aunque esto es exactamente lo que espera la clase ``contentPutApp'', hay algunas peculiaridades de funcionamiento de Bluefish que hacen que probablemente la clase haya de ser modificada para que funcione correctamente con esta herramienta.

%%----------------------------------------------------------------------------
\subsection{Clase contentPostApp}
\label{subsec:contentpostapp}

\textbf{Enunciado:}

Construcción de la clase ``contentPostApp'', similar a contentApp (ejercicio~\ref{subsec:contentapp}). En este caso, la clase permite la actualización del contenido mediante peticiones HTTP POST. Cuando se reciba un GET pidiendo cualquier recurso, se buscará en el diccionario de contenidos, y si existe, se servirá. En cualquier caso (exista o no exista el contenido en cuestión) se servirá en la misma página un formulario que permitirá actualizar el contenido del diccionario (o crear una nueva entrada, si no existía) mediante un POST.

\textbf{Referencias:}

Forms in HTML (HTML 4.01 Specification by W3C): \\
\url{http://www.w3.org/TR/html4/interact/forms.html}

%%----------------------------------------------------------------------------
\subsection{Clase contentPersistentApp}
\label{subsec:contentpersistentapp}

\textbf{Enunciado:}

Construcción de la clase contentPersistentApp, similar a contentPutApp (ejercicio~\ref{subsec:contentputapp}), pero incluyendo almacenamiento del diccionario con los contenidos en almacenamiento persistente, de forma que la aplicación mantenga estado al recuperarse después de una caída. Para mantener estado, puede usarse el módulo ``Shelve'' de Python, que permite almacenar y recuperar objetos en ficheros.

Opcionalmente, puede usarse en otra versión el módulo ``dbm'' de Python, que sirve también para gestionar diccionarios persistentes, pero con más limitaciones.

%%----------------------------------------------------------------------------
\subsection{Clase contentStorageApp}
\label{subsec:contentstorageapp}

\textbf{Enunciado:}

Construcción de la clase contentStorageApp similar a contentPersistentApp, pero que use un objeto de clase permanentContentStore para almacenar el estado que ha de sobrevivir a caídas de la aplicación. Esta clase mantendrá variables internas con el estado a salvaguardar persistentemente, y métodos para consultar y actualizar los valores de ese estado.

%%----------------------------------------------------------------------------
\subsection{Gestor de contenidos con usuarios}
\label{subsec:contentappusers}

\textbf{Enunciado:}

Construye la clase contentAppUsers, que amplía el gestor de contenidos que estamos construyendo (clase contentStorageApp, ejercicio~\ref{subsec:contentstorageapp}) con el concepto de usuarios registrados.

Cada usuario registrado tendrá un nombre y una contraseña (que puedes almacenar por ejemplo en un diccionario), y sólo si se ha mostrado al sistema que se es usuario registrado se podrá cambiar contenido del sitio (mediante un PUT). Para mostrar que se es usuario del sistema, se hará un GET a un recurso de la forma ``/login,usuario,contraseña'', donde ``usuario'' y ``contraseña'' son el nombre de un usuario y su contraseña. A partir de ese momento, el sistema reconocerá que los accesos desde el mismo navegador son de ese usuario. 

%%----------------------------------------------------------------------------
\subsection{Gestor de contenidos con usuarios, con control estricto de actualización}
\label{subsec:contentappusersstrict}

\textbf{Enunciado:}

Construye la clase contentAppUsersStrict, que implemente la misma funcionalidad de contentAppUsers (ejercicio~\ref{subsec:contentappusers}), pero que además controle que sólo actualiza un contenido quien lo creó. En otras palabras, cuando la aplicación recibe un PUT, se comprueba que el recurso no existe, y en ese caso, si lo está subiendo un usuario autenticado, se crea. Pero si el recurso existe, sólo lo actualiza si el usuario que está invocando el PUT es el mismo que creó el recurso. Para implementar esta funcionalidad puedes utilizar un diccionario que ``recuerde'' quien creó cada recurso, o añadir, a los datos del diccionario de contenidos (donde sólo había la página HTML para el recurso en cuestión) un nuevo elemento (por ejemplo, usando una lista): el usuario que creó el recurso.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Ejercicios P5: Aplicaciones web con base de datos}

Construcción de aplicaciones web con almacenamiento estable en base de datos.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Introducción a SQLite3 con Python}
\label{subsec:sqlite3-python}

\textbf{Enunciado:}

Vamos a empezar a usar bases de datos relacionales con nuestras aplicaciones web. En particular, vamos a usar el módulo Python sqlite3, que proporciona enlace con el gestor de bases de datos SQLite3, que utiliza una interfaz SQL. Estudiar \texttt{test-db.py}, para entender cómo se hacen operaciones básicas sobre una base de datos con Python. Modificar ese programa para que añada más registros, y comprobar con sqlitebrowser la base de datos creada.

\textbf{Material:}

\texttt{test-db.py}. Programa que crea una base de datos simple SQLite3, y luego la muestra en pantalla.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Gestor de contenidos con base de datos}
\label{subsec:gestor-contenidos-bbdd}

\textbf{Enunciado:}

Escribe y prueba la clase contentDBApp, que será una versión de contentApp (ejercicio~\ref{subsec:contentapp}), pero utilizando una base de datos SQLite3 para almacenar sus objetos persistentes.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Gestor de contenidos con usuarios, con control estricto de actualización y base de datos}
\label{subsec:gestor-contenidos-usuarios-bbdd}

\textbf{Enunciado:}

Escribe y prueba la clase contentDBAppUsersStrict, que será igual que ``Gestor de contenidos con usuarios, con control estricto de actualización'' (contentAppUsersStrict, ejercicio~\ref{subsec:contentappusersstrict}), pero usando base de datos como almacenamiento permanente.

\newpage

%% %%----------------------------------------------------------------------------
%% %%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Prácticas de entrega voluntaria (curso 2014-2015)}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2013}

Esta práctica tendrá como objetivo la creación de una aplicación web simple para acortar URLs. La aplicación funcionará únicamente con datos en memoria: se supone que cada vez que la aplicación muera y vuelva a ser lanzada, habrá perdido todo su estado anterior. La aplicación tendrá que realizarse según un esquema de clases similar al explicado en clase.

El funcionamiento de la aplicación será el siguiente:

\begin{itemize}
\item Recurso ``/'', invocado mediante GET. Devolverá una página HTML con un formulario. En ese formulario se podrá escribir una url, que se enviará al servidor mediante POST. Además, esa misma página incluirá un listado de todas las URLs reales y acortadas que maneja la aplicación en este momento.

\item Recurso ``/'', invocado mediante POST. Si el comando POST incluye una qs (query string) que corresponda con una url enviada desde el formulario, se devolverá una página HTML con la url original y la url acortada (ambas como enlaces pinchables), y se apuntará la correspondencia (ver más abajo).

Si el POST no trae una qs que se haya podido generar en el formulario, devolverá una página HTML con un mensaje de error.

Si la URL especificada en el formulario comienza por ``http://'' o ``https://'', se considerará que ésa es la url a acortar. Si no es así, se le añadirá ``http://'' por delante, y se considerará que esa es la url a acortar. Por ejemplo, si en el formulario se escribe ``http://gsyc.es'', la url a acortar será ``http://gsyc.es''. Si se escribe ``gsyc.es'', la URL a acortar será ``http://gsyc.es''.

Para determinar la URL acortada, utilizará un número entero secuencial, comenzando por 0, para cada nueva petición de acortamiento de una URL que se reciba. Si se recibe una petición para una URL ya acortada, se devolverá la URL acortada que se devolvió en su momento.

Así, por ejemplo, si se quiere acortar

\verb|http://docencia.etsit.urjc.es|

y la aplicación está en el puerto 1234 de la máquina ``localhost'', se invocará (mediante POST) la URL

\verb|http://localhost:1234/|

y en el cuerpo de esa petición HTTP irá la qs

\verb|url=http://docencia.etsit.urjc.es|

si el campo donde el usuario puede escribir en el formulario tiene el nombre ``URL''. Normalmente, esta invocación POST se realizará rellenando el formulario que ofrece la aplicación.

Como respuesta, la aplicación devolverá (en el cuerpo de la respuesta HTTP) la URL acortada, por ejemplo

\verb|http://localhost:1234/3|

Si a continuación se trata de acortar la URL

\verb|http://docencia.etsit.urjc.es/moodle/course/view.php?id=25|

mediante un procedimiento similar, se recibirá como respuesta la URL acortada

\verb|http://localhost:1234/4|

Si se vuelve a intentar acortar la URL

\verb|http://docencia.etsit.urjc.es|

como ya ha sido acortada previamente, se devolverá la misma URL corta:

\verb|http://localhost:1234/3|

\item Recursos correspondientes a URLs acortadas. Estos serán números con el prefijo ``/''. Cuando la aplicación reciba un GET sobre uno de estos recursos, si el número corresponde a una URL acortada, devolverá un HTTP REDIRECT a la URL real. Si no la tiene, devolverá HTTP ERROR ``Recurso no disponible''.

Por ejemplo, si se recibe 

\verb|http://localhost:1234/3|

la aplicación devolverá un HTTP REDIRECT a la URL

\verb|http://docencia.etsit.urjc.es|

\end{itemize}

\textbf{Comentario}

Se recomienda utilizar dos diccionarios para almacenar las URLs reales y los números de las URLs acortadas. En uno de ellos, la clave de búsqueda será la URL real, y se utilizará para saber si una URL real ya está acortada, y en su caso saber cuál es el número de la URL corta correspondiente.

En el otro diccionario la clave de búsqueda será el número de la URL acortada, y se utilizará para localizar las URLs reales dadas las cortas. De todas formas, son posibles (e incluso más eficientes) otras estructuras de datos.

Se recomienda realizar la aplicación en varios pasos:

\begin{itemize}
\item Comenzar por reconocer ``GET /'', y devolver el formulario correspondiente.
\item Reconocer ``POST /'', y devolver la página HTML correspondiente (con la URL real y la acortada).
\item Reconocer ``GET /num'' (para cualquier número num), y realizar la redirección correspondiente.
\item Manejar las condiciones de error y realizar el resto de la funcionalidad.
\end{itemize}

%%---------------------------------------------------------------------
%%---------------------------------------------------------------------
\subsection{Práctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2013}

\textbf{Fecha recomendada de entrega:} Antes del 21 de abril.

Esta práctica tendrá como objetivo la creación de una aplicación web (de nombre \emph{acorta}) simple para acortar URLs utilizando Django (proyecto \emph{project}). Su enunciado será igual que el de la práctica 1 de entrega voluntaria (ejercicio~\ref{subsec:practica-vol-1-2013}), salvo en los siguientes aspectos:

\begin{itemize}
\item Se implementará utilizando Django.
\item Tendrá que almacenar la información relativa a las URLs que acorta en una base de datos, de forma que aunque la aplicación sea rearrancada, las URLs acortadas sigan funcionando adecuadamente.
\end{itemize}

Repositorio GitHub de entrega: \\
\url{https://github.com/CursosWeb/X-Serv-18.2-Practica2}

\newpage

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Práctica final (2015, mayo)}
\label{practica-final-2015-05}

La práctica final de la asignatura consiste en la creación de una aplicación web que aglutine información sobre actividades culturales y de ocio que tienen lugar en el municipio de Madrid. A continuación se describe el funcionamiento y arquitectura general de la aplicación, la funcionalidad mínima que debe proporcionar, y otra funcionalidad optativa que podrá tener.

La aplicación consiste en descargarse datos de tráfico (disponbiles públicamente en formato XML) y ofrecer estos datos a los usuarios de la aplicación para que puedan gestionar la información de la manera con consideren más conveniente. De esta manera, un escenario típico es el de un usuario que a partir de las actividades existentes, incluya en su perfil las que le interesen. Así, este usuario tendrá una página personal con sus actividades.

%%----------------------------------------------------------------------------
\subsection{Arquitectura y funcionamiento general}

Arquitectura general:

\begin{itemize}

\item La práctica se construirá como un proyecto Django, que incluirá una o varias aplicaciones Django que implementen la funcionalidad requerida.

\item Para el almacenamiento de datos persistente se usará SQLite3, con tablas definidas según modelos en Django.

\item Se usará la aplicación Django ``Admin Site'' para crear cuenta a los usuarios en el sistema, y para la gestión general de las bases de datos necesarias. Todas las bases de datos que mantenga DeLorean tendrá que ser accesible vía este ``Admin Site''.

\item Se utilizarán plantillas Django (a ser posible, una jerarquía de plantillas, para que la práctica tenga un aspecto similar) para definir las páginas que se servirán a los navegadores de los usuarios. Estas plantillas incluirán en todas las páginas al menos:
  \begin{itemize}
  \item Un banner (imagen) del sitio, en la parte superior.
  \item Un menú de opciones.
  \item Una caja para entrar (hacer login en el sitio), o para salir (si ya se ha entrado). En caso de que no se haya entrado en una cuenta, esta caja permitirá al visitante introducir su identificador de usuario y su contraseña. En caso de que ya se haya entrado, esta caja mostrará el identificador del usuario y permitirá salir de la cuenta (logout).
  \item Un pie de página con una nota de copyright.
  \end{itemize}

Cada una de estas partes estará marcada con propiedades ``id'' en HTML, para poder ser referenciadas en hojas de estilo CSS.

\item Se utilizarán hojas de estilo CSS para determinar la apariencia de la práctica. Estas hojas definirán al menos el color y el tamaño de la letra, y el color de fondo de cada una de las partes (elementos) marcadas con id que se indican en el apartado anterior.
\end{itemize}

Funcionamiento general:

\begin{itemize}
\item Los usuarios serán dados de alta en la práctica mediante el módulo ``Admin Site'' de Django. Una vez estén dados de alta, serán considerados ``usuarios registrados''.

\item Los usuarios registrados podrán crear su selección de actividades de cultura y de ocio. Para ello, dispondrán de una página personal. Llamaremos a esta página la ``página del usuario''.

\item La selección de incidencias en su página personal la realizará cada usuario a partir de información sobre actividades de ocio y cultura ya disponibles en el sitio.

\item Las actividades de ocio y cultura se actualizarán sólo cuando un usuario indique que quiere que se actualicen.

\item Cualquier navegador podrá acceder a la interfaz pública del sitio, que ofrecerá la página personal de cada usuario, para todos los usuarios del sitio.

\end{itemize}


%%----------------------------------------------------------------------------
\subsection{Funcionalidad mínima}

Las actividades de ocio y de cultura se toman de interpretar la información pública ofrecida por el Ayuntamiento de Madrid en el Portal de Datos Abiertos, y que es la siguiente:
    \begin{itemize}
      \item Actividades Culturales y de Ocio Municipal en los próximos 100 días: \\
        \url{http://goo.gl/809BPF}
    \end{itemize}

Como información pública de cada actividad de ocio o de cultura se mostrará:

\begin{itemize}
  \item El título de la actividad de ocio o de cultura
  \item El tipo de evento
  \item El precio del evento
  \item La fecha y hora del evento
  \item La duración del evento
  \item Si es un evento de larga duración
  \item La URL con información adicional
  \item La fecha en que el vento fue seleccionado para la página personal del usuario (junto al texto ``elegida en'').
\end{itemize}

Interfaz pública: recursos a servir como páginas HTML completas (pensadas para ser vistas en el navegador) para cualquier visitante (sea usuario registrado o no):

\begin{itemize}
\item /: Página principal de la práctica. Mostrará un listado de las diez actividades de ocio y cultura más próximas en el tiempo, y posteriormente otro listado con las páginas personales disponibles. Para cada página personal mostrará el título (como un enlace a la página personal), el nombre de su usuario y una pequeña descripción. Si a una página personal aún no se le hubiera puesto título, este título será ``Página de usuario'', donde ``usuario'' es el identificador de usuario del usuario en cuestión.

\item /usuario: Página personal de un usuario. Si la URL es ``/usuario'', es que corresponde al usuario ``usuario''. Mostrará las actividades de ocio y de cultura seleccionadas por ese usuario (aunuque no puede haber más de 10 a la vez, como se indicará más adelante). Para cada actividad de ocio y de cultura se mostrará al menos el título y la fecha de los eventos (con un enlace a la página /actividad de cada evento, ver más adelante).

\item /actividad: Página de una actividad de cultura o de ocio. Mostrará la información obtenida del XML del portal de datos abierto del Ayuntamiento de Madrid. Además, se mostrará su  ``información adicional''.

\item /usuario/rss: Canal RSS para las incidencias seleccionadas por ese usuario.

\item /ayuda: Página con información HTML explicando el funcionamiento de la práctica.

\item /todas: Página con todas las actividades de ocio y de cultura. En la parte superior de la página, existirá un formulario que permite filtrar estas actividades según varios campos, como, por ejemplo, la fecha, la duración, el precio o el título.
\end{itemize}

Todas las páginas de la interfaz pública incluirán un menú desde el que se podrá acceder a todas las incidiencias (URL /todas) con el texto ``Todas'' y a la ayuda (URL /ayuda) con el texto ``Ayuda''. Todas las página que no sean la principal tendrán otra opción de menú para la URL /, con el texto ``Inicio''.


Interfaz privada: recursos a servir como páginas HTML completas para usuarios registrados (una vez se han autenticado).

\begin{itemize}
  \item Todos los recursos de la interfaz pública.
  \item /actividades: Además de la información que se muestra de manera pública:
  \begin{itemize}
    \item Se mostrará el número de actividades de ocio y de cultura disponibles para el canal, y la fecha en que fue actualizado por última vez.
    \item Existirá un botón para actualizar las actividades a partir del canal de actividades. Si se pulsa este botón, se tratarán de actualizar las incidencias accediendo al canal de incidencias del Ayuntamiento de Madrid. Al terminar la operación se volverá a mostrar esta misma página, actualizada.
    \item La lista de actividades disponibles en el canal de actividades, incluyendo para cada una la ``información adicional', ver más adelante.
    \item Junto a cada actividad de la lista, se incluirá un botón que permitirá elegir la incidencia para la página personal del usuario autenticado. Tras añadir una actividad a la página del usuario, se volverá a ver en el navegador la página /actividad.
  \end{itemize}

  \item En la página /usuario que corresponde al usuario autenticado se mostrará, además de lo ya mencionado para la interfaz pública, un formulario en el que se podrá especificar la siguiente información:

  \begin{itemize}
    \item Los parámetros CSS para el usuario autenticado (al menos los indicados anteriormente para ser manejados por un documento CSS). Si el usuario los cambia, a partir de ese momento deberá verse el sitio con los nuevos valores, y para ello deberá servirse un nuevo documento CSS.
    \item El título de su página personal.
  \end{itemize}
\end{itemize}

%Si es preciso, se añadirán más recursos (pero sólo si es realmente preciso) para poder satisfacer los requisitos especificados.

Dados los recursos mencionados anteriormente, no se permitirán los nombres de usuario ``actividad'', ``ayuda'' ni ``todas'' (pero no hay que hacer ninguna comprobación para esto: se asume que no se darán de alta esos usuarios en el Admin Site).



%%----------------------------------------------------------------------------
\subsection{Funcionalidad optativa}

De forma optativa, se podrá incluir cualquier funcionalidad relevante en el contexto de la asignatura. Se valorarán especialmente las funcionalidades que impliquen el uso de técnicas nuevas, o de aspectos de Django no utilizados en los ejercicios previos, y que tengan sentido en el contexto de esta práctica y de la asignatura.

Sólo a modo de sugerencia, se incluyen algunas posibles funcionalidades optativas:

\begin{itemize}
\item Atención al idioma indicado por el navegador. El idioma de la interfaz de usuario del planeta tendrá en cuenta lo que especifique el navegador.

\item Generación de un canal RSS para los contenidos que se muestran en la página principal.

\item Uso de AJAX para algún aspecto de la práctica (por ejemplo, para seleccionar una incidencia para una página de usuario).

\item Puntuación de actividades. Cada visitante (registrado o no) puede dar un ``+1'' a cualquier incidencia del sitio. La suma de ``+'' que ha obtenido una incidencia se verá cada vez que se vea la incidencias en el sitio.

\item Comentarios a actividades. Cada usuario registrado puede comentar cualquier actividad del sitio. Estos comentarios se podrán ver luego en la página personal.

\end{itemize}


%%----------------------------------------------------------------------------
\subsection{Entrega de la práctica}

\textbf{Fecha límite de entrega de la práctica:} domingo, 24 de mayo de 2015 a las 23:59 (hora española peninsular).

\textbf{Fecha de publicación de notas:} martes, 25 de mayo de 2015, en la plataforma Moodle.

\textbf{Fecha de revisión:} viernes, 29 de mayo de 2014 a las 12:00. Se requerirá a algunos alumnos que asistan a la revisión {\bf en persona}; se informará de ello en el mensaje de publicación de notas.

La práctica se entregará realizando dos acciones:

\begin{enumerate}
  \item Rellenando un formulario web, que pedirá la siguiente información:
  \begin{itemize}
    \item Nombre de la asignatura.
    \item Nombre completo del alumno.
    \item Nombre de su cuenta en el laboratorio.
    \item Nombres y contraseñas de los usuarios creados para la práctica. Éstos deberán incluir al menos un usuario con cuenta ``marty'' y contraseña ``marty'' y otro usuario con cuenta ``doc'' y contraseña ``doc''.
    \item Resumen de las peculiaridades que se quieran mencionar sobre lo implementado en la parte obligatoria.
    \item Lista de funcionalidades opcionales que se hayan implementado, y breve descripción de cada una.
    \item URL del vídeo demostración en YouTube que muestre la funcionalidad básica
    \item URL del vídeo demostración en YouTube con la funcionalidad optativa, si se ha realizado funcionalidad optativa
  \end{itemize}

  \item Subiendo la práctica al recurso habilitado a tal fin en el sitio Moodle de la asignatura. Para entregar la práctica en el Moodle, cada alumno subirá al recurso habilitado a tal fin un fichero tar.gz con todo el código fuente de la práctica. El fichero se habrá de llamar practica-user.tar.gz, siendo ``user'' el nombre de la cuenta del alumno en el laboratorio.

El fichero que se entregue deberá constar de un proyecto Django completo y listo para funcionar en el entorno del laboratorio, incluyendo la base de datos con datos suficientes como para poder probarlo. Estos datos incluirán al menos dos usuarios con sus datos correspondientes, y con al menos cinco actividades en su página personal.
\end{enumerate}

Los vídeos de demostración serán de una duración máxima de 3 minutos (cada uno), y consistirán en una captura de pantalla de un navegador web utilizando la aplicación, y mostrando lo mejor posible la funcionalidad correspondiente (básica u opcional). Se valorará negativamente que los vídeos duren más de 3 minutos (de la experiencia de cursos pasados, tres minutos es un tiempo más que suficiente si uno no entra en detalles que no son importantes). Siempre que sea posible, el alumno comentará en el audio del vídeo lo que vaya ocurriendo en la captura. Los vídeos se colocarán en YouTube y deberán ser accesibles públicamente al menos hasta el 31 de mayo, fecha a partir de la cual los alumnos pueden retirar el vídeo (o indicarlo como privado).

Hay muchas herramientas que permiten realizar la captura de pantalla. Por ejemplo, en GNU/Linux puede usarse Gtk-RecordMyDesktop o Istanbul (ambas disponibles en Ubuntu). Incluso hay alguna aplicación web como Screen-O-Matic. Es importante que la captura sea realizada de forma que se distinga razonablemente lo que se grabe en el vídeo.

En caso de que convenga editar el vídeo resultante (por ejemplo, para eliminar tiempos de espera) puede usarse un editor de vídeo, pero siempre deberá ser indicado que se ha hecho tal cosa con un comentario en el audio, o un texto en el vídeo. Hay muchas herramientas que permiten realizar esta edición. Por ejemplo, en GNU/Linux puede usarse OpenShot o PiTiVi.

Los alumnos que no entreguen las práctica de esta forma serán considerados como no presentados en lo que a la entrega de prácticas se refiere.

%%----------------------------------------------------------------------------
\subsection{Notas y comentarios}

La práctica deberá funcionar en el entorno GNU/Linux (Ubuntu) del laboratorio de la asignatura con la versión de Django que se ha usado en prácticas (Django 1.7.*).

La práctica deberá funcionar desde el navegador Firefox disponible en el laboratorio de la asignatura.

Los canales (feeds) RSS que produce la aplicación web realizada en la práctica deberán funcionar al menos con el navegador Firefox (considerándolos como canales RSS) disponibles en el laboratorio.


\newpage

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Práctica final (2014, mayo)}
\label{practica-final-2014-04}

La práctica final de la asignatura consiste en la creación de una aplicación web que aglutine información sobre el estado de las carreteras y relacionada. A continuación se describe el funcionamiento y arquitectura general de la aplicación, la funcionalidad mínima que debe proporcionar, y otra funcionalidad optativa que podrá tener. Llamaremos a la aplicación DeLorean, como tributo a los casi 30 años de la primera película ``Regreso al Futuro''.

La aplicación consiste en descargarse datos de tráfico (disponbiles públicamente en formato XML) y ofrecer estos datos a los usuarios de la aplicación para que puedan gestionar la información de la manera con consideren más conveniente. De esta manera, un escenario típico es el de un usuario que indique una provincia (o incluso una carretera) en la que está interesado; en su página personal aparecerán todas las incidencias de tráfico que cumplan esos requisitos, en tiempo real.

%%----------------------------------------------------------------------------
\subsection{Arquitectura y funcionamiento general}

Arquitectura general:

\begin{itemize}

\item DeLorean se construirá como un proyecto Django, que incluirá una o varias aplicaciones Django que implementen la funcionalidad requerida.

\item Para el almacenamiento de datos persistente se usará SQLite3, con tablas definidas según modelos en Django.

\item Se usará la aplicación Django ``Admin Site'' para crear cuenta a los usuarios en el sistema, y para la gestión general de las bases de datos necesarias. Todas las bases de datos que mantenga DeLorean tendrá que ser accesible vía este ``Admin Site''.

\item Se utilizarán plantillas Django (a ser posible, una jerarquía de plantillas, para que DeLorean tenga un aspecto similar) para definir las páginas que se servirán a los navegadores de los usuarios. Estas plantillas incluirán en todas las páginas al menos:
  \begin{itemize}
  \item Un banner (imagen) del sitio, en la parte superior.
  \item Un menú de opciones.
  \item Una caja para entrar (hacer login en el sitio), o para salir (si ya se ha entrado). En caso de que no se haya entrado en una cuenta, esta caja permitirá al visitante introducir su identificador de usuario y su contraseña. En caso de que ya se haya entrado, esta caja mostrará el identificador del usuario y permitirá salir de la cuenta (logout).
  \item Un pie de página con una nota de copyright.
  \end{itemize}

Cada una de estas partes estará marcada con propiedades ``id'' en HTML, para poder ser referenciadas en hojas de estilo CSS.

\item Se utilizarán hojas de estilo CSS para determinar la apariencia de DeLorean. Estas hojas definirán al menos el color y el tamaño de la letra, y el color de fondo de cada una de las partes (elementos) marcadas con id que se indican en el apartado anterior.
\end{itemize}

Funcionamiento general:

\begin{itemize}
\item Los usuarios serán dados de alta en DeLorean mediante el módulo ``Admin Site'' de Django. Una vez estén dados de alta, serán considerados ``usuarios registrados''.

\item Los usuarios registrados podrán crear su selección de estados de carretera de DeLorean. Para ello, dispondrán de una página personal. Llamaremos a esta página la ``página del usuario''.

\item La selección de incidencias en su página personal la realizará cada usuario a partir de información sobre incidencias ya disponibles en el sitio.

\item Las incidencias se actualizarán sólo cuando un usuario indique que quiere que se actualicen.

\item Cualquier navegador podrá acceder a la interfaz pública del sitio, que ofrecerá la página personal de cada usuario, para todos los usuarios del sitio.
\end{itemize}


%%----------------------------------------------------------------------------
\subsection{Funcionalidad mínima}

Interfaz pública: recursos a servir como páginas HTML completas (pensadas para ser vistas en el navegador) para cualquier visitante (sea usuario registrado o no):

\begin{itemize}
\item /: Página principal de DeLorean. Mostrará un listado de las últimas diez incidencias y posteriormente otro listado con las páginas personales disponibles. Para cada página personal mostrará el título (como un enlace a la página personal), el nombre de su usuario y una pequeña descripción. Si a una página personal aún no se le hubiera puesto título, este título será ``Página de usuario'', donde ``usuario'' es el identificador de usuario del usuario en cuestión.

\item /usuario: Página personal de un usuario. Si la URL es ``/usuario'', es que corresponde al usuario ``usuario''. Mostrará las incidencias seleccionadas por ese usuario (aunuque no puede haber más de 10 a la vez, como se indicará más adelante). Para cada incidencia se mostrará la ``información pública de cada incidencia'', ver más adelante.

\item /usuario/rss: Canal RSS para las incidencias seleccionadas por ese usuario.

\item /ayuda: Página con información HTML explicando el funcionamiento de DeLorean.

\item /todas: Página con todas las incidencias. En la parte superior de la página, existirá un formulario que permite filtrar las incidencias según varios campos, como, por ejemplo, provincia, tipo, longitud.
\end{itemize}

Todas las páginas de la interfaz pública incluirán un menú desde el que se podrá acceder a todas las incidiencias (URL /todas) con el texto ``Todas'' y a la ayuda (URL /ayuda) con el texto ``Ayuda''. Todas las página que no sean la principal tendrán otra opción de menú para la URL /, con el texto ``Inicio''.

Interfaz privada: recursos a servir como páginas HTML completas para usuarios registrados (una vez se han autenticado).

\begin{itemize}
\item Todos los recursos de la interfaz pública.
\item /incidencias: Página con la lista de incidencias disponibles en DeLorean:

  \begin{itemize}
  \item Las incidencias se toman de interpretar la información pública ofrecida por la Dirección General de Tráfico (DGT), y que es la siguiente:
    \begin{itemize}
      \item Información de incidencias en carreteras (canal de incidencias): \\
        \url{http://www.dgt.es/incidencias.xml}
    \end{itemize}

  \item Se mostrará el número de incidencias disponibles para el canal, y la fecha en que fue actualizado por última vez.
  \item Existirá un botón para actualizar las incidencias a partir del canal de incidencias. Si se pulsa este botón, se tratarán de actualizar las incidencias accediendo al canal de incidencias de la DGT. Al terminar la operación se volverá a mostrar esta misma página, actualizada.
  \item La lista de incidencias disponibles en el canal de incidencias, incluyendo para cada una la ``información pública', ver más adelante.
  \item Junto a cada incidencia de la lista, se incluirá un botón que permitirá elegir la incidencia para la página personal del usuario autenticado. Tras añadir una incidencia a la página del usuario, se volverá a ver en el navegador la página /incidencias.
  \end{itemize}

\item En la página /usuario que corresponde al usuario autenticado se mostrará, además de lo ya mencionado para la interfaz pública, un formulario en el que se podrá especificar la siguiente información:

  \begin{itemize}
  \item Los parámetros CSS para el usuario autenticado (al menos los indicados anteriormente para ser manejados por un documento CSS). Si el usuario los cambia, a partir de ese momento deberá verse el sitio con los nuevos valores, y para ello deberá servirse un nuevo documento CSS.
  \item El título de su página personal.
  \end{itemize}
\end{itemize}

Si es preciso, se añadirán más recursos (pero sólo si es realmente preciso) para poder satisfacer los requisitos especificados.

Dados los recursos mencionados anteriormente, no se permitirán los nombres de usuario ``incidencias'', ``ayuda'' ni ``todas'' (pero no hay que hacer ninguna comprobación para esto: se asume que no se darán de alta esos usuarios en el Admin Site).


Como información pública de cada incidencia se mostrará:
\begin{itemize}
  \item El tipo de incidencia
  \item La provincia de la incidencia y la carretera
  \item La fecha en que fue publicada la incidencia en el sitio original (junto al texto ``publicada en'').
  \item La fecha en que fue seleccionada para la página personal del usuario (junto al texto ``elegida en'').
  \item La información detallada de la incidencia (toda la demás información de la incidencia que se puede extraer del XML)
\end{itemize}



%%----------------------------------------------------------------------------
\subsection{Funcionalidad optativa}

De forma optativa, se podrá incluir cualquier funcionalidad relevante en el contexto de la asignatura. Se valorarán especialmente las funcionalidades que impliquen el uso de técnicas nuevas, o de aspectos de Django no utilizados en los ejercicios previos, y que tengan sentido en el contexto de esta práctica y de la asignatura.

Sólo a modo de sugerencia, se incluyen algunas posibles funcionalidades optativas:

\begin{itemize}
\item Atención al idioma indicado por el navegador. El idioma de la interfaz de usuario del planeta tendrá en cuenta lo que especifique el navegador.

\item Generación de un canal RSS para los contenidos que se muestran en la página principal.

\item Uso de AJAX para algún aspecto de la práctica (por ejemplo, para seleccionar una incidencia para una página de usuario).

\item Puntuación de incidencias. Cada visitante (registrado o no) puede dar un ``+1'' a cualquier incidencia del sitio. La suma de ``+'' que ha obtenido una incidencia se verá cada vez que se vea la incidencias en el sitio.

\item Comentarios a incidencias. Cada usuario registrado puede comentar cualquier incidencia del sitio. Estos comentarios se podrán ver luego en la página personal.

\end{itemize}


%%----------------------------------------------------------------------------
\subsection{Entrega de la práctica}

\textbf{Fecha límite de entrega de la práctica:} sábado, 24 de mayo de 2014 a las 03:00 (hora española peninsular).

\textbf{Fecha de publicación de notas:} lunes, 26 de mayo de 2014, en la plataforma Moodle.

\textbf{Fecha de revisión:} miércoles, 28 de mayo de 2014 a las 12:00. Se requerirá a algunos alumnos que asistan a la revisión {\bf en persona}; se informará de ello en el mensaje de publicación de notas.

La práctica se entregará subiéndola al recurso habilitado a tal fin en el sitio Moodle de la asignatura. Los alumnos que no entreguen las práctica de esta forma serán considerados como no presentados en lo que a la entrega de prácticas se refiere. Los que la entreguen podrán ser llamados a realizar también una entrega presencial, que tendrá lugar en la fecha y hora exacta se les comunicará oportunamente. Esta entrega presencial podrá incluir una conversación con el profesor sobre cualquier aspecto de la realización de la práctica.

Para entregar la práctica en el Moodle, cada alumno subirá al recurso habilitado a tal fin un fichero tar.gz con todo el código fuente de la práctica. El fichero se habrá de llamar practica-user.tar.gz, siendo ``user'' el nombre de la cuenta del alumno en el laboratorio.

El fichero que se entregue deberá constar de un proyecto Django completo y listo para funcionar en el entorno del laboratorio, incluyendo la base de datos con datos suficientes como para poder probarlo. Estos datos incluirán al menos dos usuarios con sus datos correspondientes, y con al menos cinco incidencias en su página personal. Se incluirá también un fichero README con los siguientes datos:

\begin{itemize}
  \item Nombre de la asignatura.
  \item Nombre completo del alumno.
  \item Nombre de su cuenta en el laboratorio.
  \item Nombres y contraseñas de los usuarios creados para la práctica. Éstos deberán incluir al menos un usuario con cuenta ``marty'' y contraseña ``marty'' y otro usuario con cuenta ``doc'' y contraseña ``doc''.
\item Resumen de las peculiaridades que se quieran mencionar sobre lo implementado en la parte obligatoria.
\item Lista de funcionalidades opcionales que se hayan implementado, y breve descripción de cada una.
\item URL del vídeo demostración en YouTube que muestre la funcionalidad básica
\item URL del vídeo demostración en YouTube con la funcionalidad optativa, si se ha realizado funcionalidad optativa
\end{itemize}

Además, parte de la información del fichero README se incluirá a su vez en un formulario web a la hora de realizar la entrega.

Los vídeos de demostración serán de una duración máxima de 3 minutos (cada uno), y consistirán en una captura de pantalla de un navegador web utilizando la aplicación, y mostrando lo mejor posible la funcionalidad correspondiente (básica u opcional). Se valorará negativamente que los vídeos duren más de 3 minutos (de la experiencia de cursos pasados, tres minutos es un tiempo más que suficiente si uno no entra en detalles que no son importantes). Siempre que sea posible, el alumno comentará en el audio del vídeo lo que vaya ocurriendo en la captura. Los vídeos se colocarán en YouTube y deberán ser accesibles públicamente al menos hasta el 31 de mayo, fecha a partir de la cual los alumnos pueden retirar el vídeo (o indicarlo como privado).

Hay muchas herramientas que permiten realizar la captura de pantalla. Por ejemplo, en GNU/Linux puede usarse Gtk-RecordMyDesktop o Istanbul (ambas disponibles en Ubuntu). Incluso hay alguna aplicación web como Screen-O-Matic. Es importante que la captura sea realizada de forma que se distinga razonablemente lo que se grabe en el vídeo.

En caso de que convenga editar el vídeo resultante (por ejemplo, para eliminar tiempos de espera) puede usarse un editor de vídeo, pero siempre deberá ser indicado que se ha hecho tal cosa con un comentario en el audio, o un texto en el vídeo. Hay muchas herramientas que permiten realizar esta edición. Por ejemplo, en GNU/Linux puede usarse OpenShot o PiTiVi.

%%----------------------------------------------------------------------------
\subsection{Notas y comentarios}

La práctica deberá funcionar en el entorno GNU/Linux (Ubuntu) del laboratorio de la asignatura con la versión de Django que se ha usado en prácticas (Django 1.7.*).

La práctica deberá funcionar desde el navegador Firefox disponible en el laboratorio de la asignatura.

Se recomienda construir una o varias aplicaciones complementarias para probar la descarga y almacenamiento en base de datos de los canales que alimentarán las revistas.

Los canales (feeds) RSS que produce la aplicación web realizada en la práctica deberán funcionar al menos con el navegador Firefox (considerándolos como canales RSS) disponibles en el laboratorio.


\newpage




%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Ejercicios complementarios de varios temas}

A continuación, algunos ejercicios relacionados con el temario de la asignatura. Algunos de ellos han sido propuestos en exámenes de ediciones previas, o en asignaturas con temarios similares.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Números primos}

Se pide realizar una aplicación web que, dado un número, calcule si es primo o no. El número se indica como recurso, con URLs de la forma http://primos.org/34 (si el número a probar es ``34''). Para esta aplicación:

\begin{enumerate}
\item Escribir la petición y la respuesta HTTP que se podría observar para el caso de que se pruebe el número 34.
\item Escribir el código de la aplicación (sin usar un entorno de desarrollo de aplicaciones web). Escribir el código en Python, pseudo-Python o pseudocódigo. Puede usarse un método ``IsPrime'', que acepta un número como parámetro, y devuelve True si ese número es primo, y False en caso contrario.
\item Se quiere que la aplicación mantenga una caché de los números ya probados, para evitar volver a probar un número si ya se calculó si era primo. Explicar las modificaciones que se verán en el intercambio HTTP, y en el código de la aplicación.
\item Se quiere que la aplicación, tal y como la describía el enunciado al principio de este ejercicio, siga funcionado en presencia de caídas y posteriores recuperaciones del servidor. ¿Qué cambios habrá que hacerle?
\item Lo mismo, en el caso de la aplicación con caché, tal y como se describe dos aparatados más arriba.
\end{enumerate}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Autenticación}

Una aplicación web dada permite el acceso a cierto recurso, ``/resource'', sólo a usuarios que se hayan autenticado previamente. Los usuarios se autentican mediante nombre de usuario y contraseña. La autenticación se realiza mediante POST a un recurso ``/login''. Ese mismo recurso, si recibe un GET, sirve un formulario para poder realizar la autenticación. En este caso, se plantean las siguientes preguntas:

\begin{enumerate}
\item Describir (indicando las cabeceras relevantes y el contenido del cuerpo de los mensajes) las interacciones HTTP, desde que un usuario se quiere autenticar, y pincha en la URL para recibir el formulario, hasta que este usuario recibe un mensaje de bienvenida indicando que está ya autenticado.
\item Escribe el código de una vista (view) que de servicio al recurso ``/login''. Escríbelo como se haría en una view Django (pero si prefieres, usando pseudo-Python o pseudocódigo).
\item Describe la interacción HTTP que se producirá desde que un navegador invoca la un GET sobre ``/resource'' hasta que recibe la pertinente respuesta de la aplicación web. Hazlo primero en el caso de que el navegador se haya autenticado previamente como usuario, y luego en caso de que no lo haya hecho.
\end{enumerate}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Recomendaciones}

Te han pedido que diseñes un servicio en Internet para elegir, comentar y recibir recomendaciones sobre lugares para pasar las vacaciones. Las características principales del sistema serán:

\begin{enumerate}
\item La información, comentarios y recomendaciones siempre estarán referidos a un lugar (un pueblo, una playa, una zona).
\item Cualquier usuario del servicio podrá ``abrir'' un nuevo lugar, simplemente indicando su nombre y subiendo una descripción del mismo. A partir de ese momento, habrá una URL en el servicio que  mostrará esa información. Nos referiremos a esa URL como ``la página del lugar''.
\item Cualquier usuario del servicio (incluyendo el que lo abrió) podrá modificar la descripción de un lugar y/o añadir un comentario. Los comentarios y los cambios en la descripción se reflejarán inmediatamente en la página del lugar correspondiente.
\item Cualquier usuario del servicio podrá ``elegir'' un lugar. Para ello, tendrá un botón que podrá pulsar en la página de ese lugar.
\item Cualquier usuario del servicio podrá pedir que se le recomiende un lugar, según las elecciones pasadas propias y de otros usuarios. El algoritmo que el servicio use para realizar estas recomendaciones no es objeto del diseño.
\item No se quieren mantener cuentas de usuarios, pero sí se quiere poder diferenciar entre usuarios diferentes al menos para las elecciones y las recomendaciones (para que el algoritmo pueda diferenciar entre elecciones propias y elecciones de otros).
\item El sitio ofrecerá, para cada lugar, un canal RSS con los comentarios sobre ese lugar. También  habrá un canal RSS, único para todo el sitio, con los últimos lugares sobre los que se ha comentado.
\end{enumerate}

Salvo cuando se indique otra cosa, se supone que un usuario corresponde con un navegador en un ordenador concreto.

Teniendo en cuenta los requisitos anteriores, se pide:

\begin{enumerate}
\item Detalla un esquema de URLs que permita nombrar, siguiendo en lo posible el diseño REST, todos los elementos del servicio. Procura no usar URLs innecesarias.

\item Describe todas las interacciones HTTP que tendrán lugar en el sistema
  para abrir un lugar. Detalla las URLs implicadas, e indica las cabeceras más
  relevantes.

\item Ídem para realizar un comentario sobre un  lugar. En la página del lugar habrá un  formulario para poner comentarios, el usuario lo rellenará y a continuación lo verá en esa misma página del lugar (no se usa AJAX en este apartado).

\item Ídem para elegir un  lugar. El usuario habrá de estar a la vista del lugar que quiere elegir, y una vez elegido, tendrá que verlo como elegido en esa misma página (no se usa AJAX en este apartado).

\item Cuando un usuario cambie de navegador, querrá seguir siendo reconocido por el sistema. Diseña un mecanismo, lo más simple posible, que le permita hacerlo, manteniendo garantías de que quien no tenga acceso a su navegador no podrá colocarse en su lugar desde otro. Si es posible, diséñalo sin usar el correo electrónico.

\item Describe los cambios que habría que hacer al sistema para que en la página de cada lugar cualquier usuario pueda, además de comentarios, subir fotos.

\item Describe los cambios que habría que hacer en el sistema para que la elección de un lugar se pudiera expresar sin que se produzca una recarga de página, usando AJAX.

\item ¿Se podría construir un gadget, para integrar en un mashup, que mostrase los últimos comentarios que se están poniendo en el servicio? Explica qué partes del servicio especificado en la primera parte del ejercicio usarías, y si es caso, qué modificaciones del servicio harían falta.
\end{enumerate}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Geolocalización}

Se decide construir un sitio para permitir que sus usuarios realicen
anotaciones geolocalizadas que puedan ser consultadas por
otros usuarios. Las características principales del sistema serán:

\begin{enumerate}
\item Cualquier usuario del sitio podrá subir una anotación
  geolocalizada. Para ello, rellenará un formulario en su navegador en el que
  especificará el texto que constituirá la anotación y sus
  coordenadas (latitud y longitud).
\item Cualquier usuario podrá consultar información
  geolocalizada, de varias formas:
  \begin{itemize}
  \item Especificando unas coordenadas (latitud y longitud) y una
    distancia en un formulario en el navegador. El sistema devolverá
    una página HTML con todas las anotaciones (incluyendo sus
    coordenadas y el texto correspondiente) que estén cerca de las
    coordenadas especificadas (a menos de la distancia indicada).
  \item Especificando unas coordenadas (latitud y longitud) y una
    distancia como parte de una URL del servicio, y obteniendo como
    respuesta un canal GeoRSS con todas las anotaciones (incluyendo sus
    coordenadas y el texto correspondiente) que estén cerca de las
    coordenadas especificadas (a menos de la distancia indicada).
  \item Especificando unas coordenadas (latitud y longitud) y una
    distancia como parte de una URL del servicio, y obteniendo como
    respuesta un mapa con los puntos anotados (en formato PNG).
  \item Especificando una cadena de texto en un formulario en el
    navegador. El sistema devolverá una página HTML con todas las
    anotaciones (incluyendo sus coordenadas y el texto
    correspondiente) que incluyan ese texto.
  \end{itemize}
\item Los usuarios podrán usar el sitio sin tener que abrir cuenta (de
  hecho, el sitio no mantendrá cuentas).
\item Cualquier anotación podrá ser editada (para modificarla o
  eliminarla) las veces que se quiera, si se hace desde el mismo
  navegador desde el que se creó.
\end{enumerate}

En particular, y teniendo en cuenta los requisitos anteriores,
se pide:

\begin{enumerate}
\item Describe todas las interacciones HTTP que tendrán lugar en el sistema
  para crear una anotación. Detalla las URLs implicadas, e indica las cabeceras más relevantes.
\item Ídem para ver como página HTML las anotaciones cercanas a una
  posición dada por sus coordenadas.
\item Ídem para editar una anotación previamente creada desde el mismo
  navegador.
\item Se quiere que si un usuario pierde su ordenador, y pasa a usar
  uno nuevo, pueda seguir editando las anotaciones que creó. Describe
  un mecanismo que lo permita, sin obligar al usuario a crear una
  cuenta en el sistema.
\item Se quiere utilizar el servicio de consulta de anotaciones desde
  un programa de gestión de mapas. El programa ya tiene funcionalidad
  de mostrar mapas, y de mostrar información asociada con un punto
  cualquiera del mapa. Se pretende que se utilice esta funcionalidad
  de mostrar información para mostrar las anotaciones. Explicar cómo
  se podría usar el servicio descrito en la primera parte de este
  ejercicio. Indica las URLs y las transacciones HTTP involucradas
  (indicando sus principales cabeceras) para que la aplicación pueda
  mostrar las anotaciones cercanas a un punto del mapa.
\item Indica cómo se podría usar el servicio descrito en la primera
  parte del ejercicio para que desde la aplicación
  del apartado anterior se puedan también crear anotaciones. ¿Puede
  decirse que la parte del servicio que has usado sigue las
  directrices REST?
\item Pasado un tiempo se plantea la posibilidad de incorporar cuentas
  de usuario para que estos puedan autenticarse en el sitio web.
  Describe brevemente 2 mecanismos (en cuanto a interacción
  navegador-servicio) que podrían usarse con HTTP para realizar la
  autenticación y las principales ventajas e inconvenientes de cada
  uno.
\end{enumerate}

\newpage

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Prácticas de entrega voluntaria de cursos pasados}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Prácticas de entrega voluntaria (curso 2012-2013)}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2012}

\textbf{Fecha recomendada de entrega:} Antes del 12 de marzo.

Esta práctica tendrá como objetivo la creación de una aplicación web simple para acortar URLs. La aplicación funcionará únicamente con datos en memoria: se supone que cada vez que la aplicación muera y vuelva a ser lanzada, habrá perdido todo su estado anterior. La aplicación tendrá que realizarse según un esquema de clases similar al explicado en clase.

El funcionamiento de la aplicación será el siguiente:

\begin{itemize}
\item Recursos que comienzan por el prefijo ``/acorta/'' (invocados mediante GET). Estos recursos se utilizarán para devolver URLs acortadas, por el procedimiento de proporcionar un número entero secuencial, comenzando por 0, para cada nueva petición de acortamiento de una URL que se reciba. Si se recibe una petición para una URL ya acortada, se devolverá la URL acortada que se devolvió en su momento. La URL a acortar se especificará como parte del nombre de recurso, justo a partir de ``/acorta/'' (quitando la parte ``http://'' de la URL.

Así, por ejemplo, si se quiere acortar

\verb|http://docencia.etsit.urjc.es|

y la aplicación está en el puerto 1234 de la máquina ``localhost'', se invocará (mediante GET) la URL

\verb|http://localhost:1234/acorta/docencia.etsit.urjc.es|

Como respuesta, la aplicación devolverá (en el cuerpo de la respuesta HTTP) la URL acortada, por ejemplo

\verb|http://localhost:1234/3|

Si a continuación se trata de acortar la URL

\verb|http://docencia.etsit.urjc.es/moodle/course/view.php?id=25|

se invocará para ello la URL

\verb|http://localhost:1234/acorta/docencia.etsit.urjc.es/moodle/course/view.php?id=25|

y se recibirá como respuesta la URL acortada

\verb|http://localhost:1234/4|

Si se vuelve a intentar acortar la URL

\verb|http://docencia.etsit.urjc.es|

como ya ha sido acortada previamente, se devolverá la misma URL corta:

\verb|http://localhost:1234/3|

\item Recursos correspondientes a URLs acortadas. Estos serán números con el prefijo ``/''. Cuando la aplicación reciba un GET sobre uno de estos recursos, si el número corresponde a una URL acortada, devolverá un HTTP REDIRECT a la URL real. Si no la tiene, devolverá HTTP ERROR ``Recurso no disponible''.

Por ejemplo, si se recibe 

\verb|http://localhost:1234/3|

la aplicación devolverá un HTTP redirect a la URL

\verb|http://docencia.etsit.urjc.es|

\item Recurso ``/''. Si se invoca este recurso con GET, se obtendrá un listado de todas las URLs reales y acortadas que maneja la aplicación en este momento.
\end{itemize}

\textbf{Comentario}

Se recomienda utilizar dos diccionarios para almacenar las URLs reales y los números de las URLs acortadas. En uno de ellos, la clave de búsqueda será la URL real, y se utilizará para saber si una URL real ya está acortada, y en su caso saber cuál es el número de la URL corta correspondiente.

En el otro diccionario la clave de búsqueda será el número de la URL acortada, y se utilizará para localizar las URLs reales dadas las cortas. De todas formas, son posibles (e incluso más eficientes) otras estructuras de datos.

%%---------------------------------------------------------------------
%%---------------------------------------------------------------------
\subsubsection{Práctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2012}

\textbf{Fecha recomendada de entrega:} Antes del 9 de abril.

Esta práctica tendrá como objetivo la creación de una aplicación web simple para acortar URLs utilizando Django. Su enunciado será igual que el de la práctica 1 de entrega voluntaria (ejercicio~\ref{subsec:practica-vol-1-2012}), salvo en los siguientes aspectos:

\begin{itemize}
\item Se implementará utilizando Django.
\item Tendrá que almacenar la información relativa a las URLs que acorta en una base de datos, de forma que aunque la aplicación sea rearrancada, las URLs acortadas sigan funcionando adecuadamente.
\end{itemize}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Prácticas de entrega voluntaria (curso 2011-2012)}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2011}

%\textbf{Fecha recomendada de entrega:} Antes del 31 de octubre.

Esta práctica tendrá como objetivo la creación de una aplicación web para acceso a los artículos de Wikipedia con almacenamiento en cache.

La aplicación servirá dos tipos de recursos:

\begin{itemize}
\item ``/decorated/article'': servirá la página correspondiente al artículo ``article'' de la Wikipedia en inglés, decorado con las cajas auxiliares.
\item ``/raw/article'': servirá la página correspondiente al artículo ``article'' de la Wikipedia en inglés, sin decorar con las cajas auxiliares.
\end{itemize}

La página ``decorada'' es accesible mediante URLs de la siguiente forma (para el artículo ``pencil'' de la Wikipedia en inglés):

\begin{verbatim}
http://en.wikipedia.org/w/index.php?title=pencil&action=view
\end{verbatim}

El contenido que sirven estas URLs está previsto para ser directamente mostrado, como página HTML completa, por un navegador.

La página ``no decorada'' es accesible mediante URLs de la siguiente forma (para el artículo ``pencil'' de la Wikipedia en inglés):

\begin{verbatim}
http://en.wikipedia.org/w/index.php?title=pencil&action=render
\end{verbatim}

El contenido que sirven estas URLs está previsto para ser directamente empotrable en una página HTML, dentro del elemento ``body'' (y por lo tanto la aplicación web tendrá que aportar el HTML necesario para acabar teniendo una página HTML correcta).

Cualquiera de los dos tipos de recursos se comportará de la misma forma. Si es invocado mediante GET, usará para responder el artículo que tenga en cache. Si no lo tiene, lo bajará previamente accediendo a la URL adecuada, que se indicó anteriormente, lo almacenará en la cache, y lo usará para responder.

La respuesta, en cada caso, será una página HTML que contenga en la parte superior la siguiente información:

\begin{itemize}
\item Nombre del artículo, junto con la indicación ``(decorated)'' o ``(non decorated)'', según corresponda. Por ejemplo, ``Pencil (decorated)''.
\item Enlaces a las páginas con el artículo en la Wikipedia (versiones decorada y no decorada)
\item Enlace a la historia de modificaciones del artículo en la Wikipedia
\item Enlace al último artículos de la Wikipedia que ha servido la aplicación (al navegador que le hizo la petición, o a cualquier otro).
\item Línea de separación (elemento ``hr'').
\end{itemize}

Y a continuación el texto correspondiente del  artículo de la Wikipedia (decorado o no decorado, según sea el nombre del recurso invocado).

En caso de que se pida un artículo que no exista en la Wikipedia, se devolverá el código de error correspondiente, y se marcará en la cache, de alguna forma, que ese artículo no existe, para no tener que buscarlo en caso de que vuelva a ser pedido. En general, puede usarse algún texto que aparezca en la página que devuelve Wikipedia cuando sirve la página de un artículo que no existe, como por ejemplo:

\begin{verbatim}
<div class="noarticletext">
\end{verbatim}

\textbf{Materiales de apoyo:}

\begin{itemize}
\item Parámetros de index.php en Wikipedia (MediaWiki):
\url{http://www.mediawiki.org/wiki/Manual:Parameters_to_index.php#View_and_render}
\end{itemize}

\textbf{Comentario:}

En algunas circunstancias, el servidor de Wikipedia puede devolver un código de redirección (por ejmeplo, un ``301 Moved permanently''). Téngase en cuenta que la aplicación ha de reconocer esta situación, y repetir el GET en la URL a la que se redirige.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2011}

%\textbf{Fecha recomendada de entrega:} Antes del 20 de noviembre.

Realiza lo especificado en la práctica 1 (ejercicio~\ref{subsec:practica-vol-1-2011}), pero usando el entorno de desarrollo Django. En particular, utiliza plantillas (templates) para la generación de las páginas HTML, tablas en base de datos para almacenar las páginas de Wikipedia descargada, y añade la siguiente funcionalidad:

\begin{itemize}
\item Utilizando el módulo correspondiente de Django, añade usuarios, que se autenticarán en el recurso ``/login''. Las cuentas de usuario estarán dadas de alta por el administrador (vía módulo Admin de Django). Si una página es bajada por un usuario autenticado se incluirá en la parte superior el mensaje ``Usuario: user (logout)'', siendo ``user'' el identificador de usuario correspondiente, y ``logout'' un enlace al recurso que puede utilizar el usuario para salir de su cuenta. Si la página es bajada sin haberse autenticado previamente, en lugar de ese mensaje se incluirá ``Usuario anónimo (login)'', siendo ``login'' un enlace al recurso ``/login''.
\item La aplicación atenderá el recurso ``/'', en el que ofrecerá (si se invoca con ``GET'') una lista de los artículos de Wikipedia disponibles en la base de datos, junto al enlace correspondiente (bajo ``/decorated'' o bajo ``/raw'') para descargarla, y el mensaje ``decorated'' o ``raw'', según el tipo de artículo descargado.
\end{itemize}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Prácticas de entrega voluntaria (curso 2010-2011)}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2010}

Esta práctica tendrá como objetivo la creación de una aplicación web para acceso a los artículos de Wikipedia, con almacenamiento en cache, y con consulta en varios idiomas.

La aplicación servirá dos tipos de recursos:

\begin{itemize}
\item ``/article'': servirá la página correspondiente al artículo ``article'' de la Wikipedia en inglés.
\item ``/language/article'': servirá la página correspondiente al artículo ``article'' correspondiente al idioma ``language'', expresado mediante el código ISO de dos letras. Bastará con que funcione con los idiomas inglés (en) y español (es).
\end{itemize}

La página que se bajará de la Wikipedia para cada artículo será la ``no decorada'', accesible mediante URLs de la siguiente forma (para el artículo ``pencil'' de la Wikipedia en inglés):

\begin{verbatim}
http://en.wikipedia.org/w/index.php?action=render&title=pencil
\end{verbatim}

El contenido que sirve esta URL está previsto para ser directamente empotrable en una página HTML, dentro del elemento ``body''.

Cualquiera de los dos tipos de recursos se comportará de la misma forma. Si es invocado mediante GET, usará para responder el artículo que tenga en cache. Si no lo tiene, lo bajará previamente accediendo a la URL de página no decorada, que se indicó anteriormente, lo almacenará en la cache, y lo usará para responder.

La respuesta será una página HTML que contenga:

\begin{itemize}
\item Título de la página (nombre del artículo).
\item Enlace a la página con el artículo en la Wikipedia (versión decorada)
\item Enlace a la historia de modificaciones del artículo en la Wikipedia
\item Enlace a los tres últimos artículos de la Wikipedia que ha servido la aplicación (al navegador que le hizo la petición, o a cualquier otro).
\item Texto de la página no decorada del artículo de la Wikipedia.
\end{itemize}

En caso de que se pida un artículo que no exista en la Wikipedia, se devolverá el código de error correspondiente, y se marcará en la cache, de alguna forma, que ese artículo no existe, para no tener que buscarlo en caso de que vuelva a ser pedido. En general, puede usarse algún texto que aparezca en la página que devuelve Wikipedia cuando sirve la página de un artículo que no existe, como por ejemplo:

\begin{verbatim}
<div class="noarticletext">
\end{verbatim}

\textbf{Materiales de apoyo:}

\begin{itemize}
\item Parámetros de index.php en Wikipedia (MediaWiki):
\url{http://www.mediawiki.org/wiki/Manual:Parameters_to_index.php#View_and_render}
\end{itemize}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2010}

Esta práctica consistirá en la realización de un gestor de contenidos que tenga las siguientes características:

\begin{itemize}
\item Funcionalidad de ``Gestor de contenidos con usuarios, con control estricto de actualización y uso de base de datos'' (ejercicio~\ref{subsec:gestor-contenidos-usuarios-bbdd})

\item Implementación de HEAD para todos los recursos.

\item Terminación de una sesión autenticada. Para ello se usará el recurso ``/logout''.

\item Además, cada página que se obtenga con un GET irá anotada con la siguiente información:
  \begin{itemize}
  \item Sólo si la página no la está viendo un usuario autenticado. Enlace que permita la autenticación del usuario que creó la página (a falta de la contraseña). Aparecerá con la cadena ``Autor: user'', siendo ``user'' el nombre de usuario que creó la página, y estando enlazado a ``/login,user,''.
  \item Enlace que permita ver el mensaje HTTP que envió el navegador para poder ver esa página (se puede suponer que esa fue la última página descargada desde este navegador).
  \item Enlace que permita ver la respuesta HTTP que envió el servidor para poder ver esa página (se puede suponer que esa fue la última página descargada desde este navegador).
  \end{itemize}
\end{itemize}

Además, opcionalmente, podrá tener:

\begin{itemize}
\item Creación de cuentas de usuario. Para ello se usará un recurso ``/signin,user,passwd'', sobre el que un GET creará el usuario ``user'' con la contraseña ``passwd'', si ese usuario no existía ya.
\item Subida de páginas con POST. en lugar de PUT. Se usará un POST para subir una nueva página. No hace falta implementar un formulario HTML que invoque el POST, pero también se podría hacer.
\item Una implementación que no tenga la limitación de que los enlaces al mensaje HTTP del navegador y del servidor sean de la última página descargada, sino de los de la descarga de la página que los tiene, sea la última o no.
\end{itemize}

Realizar la entrega en un fichero tar.gz o .zip, incluyendo además del código fuente los ficheros de SQLite3 necesarios, y un fichero README que resuma la funcionalidad exacta que se ha implementado (en particular, que detalle la funcionalidad opcional implementada).

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 3 (entrega voluntaria)}
\label{subsec:practica-vol-3-2010}

Realiza lo especificado en la práctica 2, pero usando el entorno de desarrollo Django. Donde lo creas oportuno, interpreta las especificaciones en el contexto de las facilidades que proporciona Django. Por ejemplo, la autenticación de usuarios se puede hacer vía un formulario de login (con el POST correspondiente) usando los módulos que proporciona Django para ello.

Igualmente, extiende las especificaciones en lo que te sea simple al usar las facilidades de Django. Por ejemplo, la gestión de usuarios (creación y borrado de usuarios) puede hacerse fácilmente usando módulos Django.

En la medida que sea razonable, usa POST (con los correspondientes formularios) en lugar de PUT. Opcionalmente, mantén ambas funcionalidades (subida de contenidos vía PUT, como se indicaba en la práctica 2, y vía POST, como se está recomendando para ésta).

\textbf{Notas:}

Parte de la especificación requiere almacenar las cabeceras de la respuesta del servidor al navegador. En Django, las cabeceras se van añadiendo al objeto HTTPResponse (o similar), y por tanto será necesario extraerlas de él. La forma más simple, y suficiente para estas prácticas, es simplemente convertir el objeto HTTPResponse en string: ``str(response)''. Si se quiere, se puede manipular el string resultante, para obtener las cabeceras en un formato más parecido al de la práctica 1, pero esto no será necesario para la versión básica.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 4 (entrega voluntaria)}
\label{subsec:practica-vol-4-2010}

Realización de lo especificado en la práctica 3 de entrega voluntaria, utilizando para la implementación las posibilidades avanzadas de Django, incluyendo especialmente las plantillas, y si es posible el sitio de administración, los usuarios y las sesiones Django. La parte básica seguirá siendo básica, y la opcional, opcional (más la adición, opcional, que se comenta más adelante).

La funcionalidad de esta práctica es, por lo tanto, la misma que la de la práctica 3. Pero a diferencia de la práctica 3, en este caso sí se pide usar los módulos ``de alto nivel'' de Django.

La URL que se usaba en las prácticas 2 y 3 para autenticarse pasa a ser ``/login'', que en el caso de recibir un GET devolverá el formulario para autenticarse, y en caso de recibir un POST gestionará la autenticación.

A la parte opcional de las prácticas 2 y 3, que sigue siendo opcional, se añade la de modificar el contenido de las páginas con formularios (usando métodos POST para la actualización), y de crear nuevas páginas también mediante formularios y POST. Para la actualización se sugiere que se usen nombres de recurso de la forma ``/edit/name'', siendo ``name'' el nombre de la página. Para la creación se sugiere que se use un nombre de recurso de la forma ``/create''.

Con respecto a la opción de crear usuarios, ahora la opción cambia a servir una URL ``/signin'' que devuelva el formulario para crearse una cuenta, y que cuanto reciba un POST gestione la creación de la cuenta.

\newpage

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------

\section{Prácticas finales de cursos pasados}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica final (2013, mayo)}
\label{practica-final-2013-05}

La práctica final de la asignatura consiste en la creación de un selector de noticias a partir de canales, como aplicación web. A continuación se describe el funcionamiento y arquitectura general de la aplicación, la funcionalidad mínima que debe proporcionar, y otra funcionalidad optativa que podrá tener. Llamaremos a la aplicación MiRevista.

%%----------------------------------------------------------------------------
\subsection{Arquitectura y funcionamiento general}

Arquitectura general:

\begin{itemize}
\item La práctica consistirá en una aplicación web que servirá los datos a los usuarios.

\item MiRevista se construirá como un proyecto Django, que incluirá una o varias aplicaciones Django que implementen la funcionalidad requerida.

\item Para el almacenamiento de datos persistente se usará SQLite3, con tablas definidas según modelos en Django.

\item Se usará la aplicación Django ``Admin Site'' para mantener los usuarios con cuenta en el sistema, y para la gestión general de las bases de datos necesarias. Todas las bases de datos que mantenga MiRevista tendrá que ser accesible vía este ``Admin Site''.

\item Se utilizarán plantillas Django (a ser posible, una jerarquía de plantillas, para que MiRevista tenga un aspecto similar) para definir las páginas que se servirán a los navegadores de los usuarios. Estas plantillas incluirán en todas las páginas al menos:
  \begin{itemize}
  \item Un banner (imagen) del sitio, en la parte superior.
  \item Un menú de opciones.
  \item Una caja para entrar (hacer login en el sitio), o para salir (si ya se ha entrado). En caso de que no se haya entrado en una cuenta, esta caja permitirá al visitante introducir su identificador de usuario y su contraseña. En caso de que ya se haya entrado, esta caja mostrará el identificador del usuario y permitirá salir de la cuenta (logout).
  \item Un pie de página con una nota de copyright.
  \end{itemize}

Cada una de estas partes estará marcada con propiedades ``id'' en HTML, para poder ser referenciadas en hojas de estilo CSS.

\item Se utilizarán hojas de estilo CSS para determinar la apariencia de MiRevista. Estas hojas definirán al menos el color y el tamaño de la letra, y el color de fondo de cada una de las partes (elementos) marcadas con id que se indican en el apartado anterior.
\end{itemize}

Funcionamiento general:

\begin{itemize}
\item Los usuarios serán dados de alta en MiRevista mediante el módulo ``Admin Site'' de Django. Una vez estén dados de alta, serán considerados ``usuarios registrados''.

\item Los usuarios registrados podrán crear su selección de noticias en MiRevista. Para ello, dispondrán de una página personal, en la que trabajarán. Llamaremos a esta página la ``revista del usuario''.

\item La selección de noticias de su revista la realizará cada usuario a partir de canales RSS de sitios web ya disponibles en el sitio.

\item Además, si hay un canal no disponible en el sitio, un usuario podrá indicar sus datos para que pase a estar disponible.

\item Los contenidos de cada canal se actualizarán sólo cuando un usuario indique que quiere que se actualicen (esta indicación se hará por separado para cada canal que se quiera actualizar).

\item Cualquier navegador podrá acceder a la interfaz pública del sitio, que ofrecerá la revista de cada usuario, para todos los usuarios del sitio.
\end{itemize}


%%----------------------------------------------------------------------------
\subsection{Funcionalidad mínima}

Interfaz pública: recursos a servir como páginas HTML completas (pensadas para ser vistas en el navegador) para cualquier visitante (sea usuario registrado o no):

\begin{itemize}
\item /: Página principal de MiRevista. Mostrará la lista de las revistas disponibles, ordenadas por fecha de actualización, en orden inverso (las revistas actualizadas más recientemente, primero). Para cada revista se mostrará su título (como un enlace a la página de la revista), el nombre de su usuario y la fecha de su última actualización (fecha en que se añadió una noticia a esa revista por última vez). Si a una revista aún no se le hubiera puesto título, este título será ``Revista de usuario'', donde ``usuario'' es el identificador de usuario del usuario en cuestión.

\item /usuario: Página de la revista de un usuario. Si la URL es ``/usuario'', es que corresponde al usuario ``usuario''. Mostrará las 10 noticias de la revista de ese usuario (no puede haber más de 10, como se indicará más adelante). Para cada noticia se mostrará la ``información pública de noticia'', ver más adelante.

\item /usuario/rss: Canal RSS para la revista de ese usuario.

\item /ayuda: Página con información HTML explicando el funcionamiento de MiRevista.
\end{itemize}

Además, todas las páginas de la interfaz pública incluirán un menú desde el que se podrá acceder la ayuda (URL /ayuda) con el texto ``Ayuda''.

Además, todas las página que no sean la principal tendrán otra opción de menú para la URL /, con el texto ``Revistas''.

Interfaz privada: recursos a servir como páginas HTML completas para usuarios registrados (una vez se han autenticado).

\begin{itemize}
\item Todos los recursos de la interfaz pública.
\item /canales: Página con la lista de los canales disponibles en MiRevista:

  \begin{itemize}
  \item Para cada canal se mostrará el nombre del canal (apuntando a la página de ese canal en MiRevista, ver más adelante), el logo del canal, el número de mensajes disponibles para el canal, y la fecha en que fue actualizado por última vez.
  \item Además, en esta página se mostrará un formulario en el que se podrá introducir una URL, que se interpretará como la URL de un nuevo canal. Esta será la forma de añadir un nuevo canal para que esté disponible en el sitio. Cuando se añada un nuevo canal se tratarán de actualizar sus contenidos a partir de la URL indicada: si esta operación falla (bien porque la URL no está disponible, bien porque no se puede interpretar su contenido como un documento RSS), no se añadirá el canal como disponible. En cualquier caso, tras tratar de añadir un nuevo canal se volverá a ver la página /canales en el navegador.
  \end{itemize}

\item /canales/num: Página de un canal en MiRevista. ``num'' es el número de orden en que se hizo disponible (si fue el segundo canal que se hizo disponible en el sitio, será /canales/2). Mostrará:

  \begin{itemize}
  \item El nombre del canal (según venga como titulo en el canal RSS correspondiente) como enlace apuntando al sitio web donde se puede ver el contenido del canal (ojo: el contenido original, no el canal RSS)
  \item Junto a él pondrá entre paréntesis ``canal'', como enlace al canal RSS correspondiente en el sitio original
  \item Un botón para actualizar el canal. Si se pulsa este botón, se tratarán de actualizar las noticias de ese canal accediendo al documento RSS correspondiente en su sitio web de origen. Al terminar la operación se volverá a mostrar esta misma página /canales/num.
  \item La lista de noticias de ese canal, incluyendo para cada una la ``información pública de noticia'', ver más adelante.
  \item Junto a cada noticia de la lista, se incluirá un botón que permitirá elegir la noticia para la revista del usuario autenticado. Si al añadirla la lista de noticias de esa revista fuera de más de 10, se eliminarán las que se eligieron hace más tiempo, de forma que no queden más de 10. Tras añadir una noticia a la revista del usuario, se volverá a ver en el navegador la página /canales/num correspondiente al canal en que se seleccionó.
  \end{itemize}

\item En la página /usuario que corresponde al usuario autenticado se mostrará, además de lo ya mencionado para la interfaz pública, un formulario en el que se podrá especificar la siguiente información:

  \begin{itemize}
  \item Los parámetros CSS para el usuario autenticado (al menos los indicados anteriormente para ser manejados por un documento CSS). Si el usuario los cambia, a partir de ese momento deberá verse el sitio con los nuevos valores, y para ello deberá servirse un nuevo documento CSS.
  \item El título de la revista del usuario autenticado.
  \end{itemize}
\end{itemize}

Si es preciso, se añadirán más recursos (pero sólo si es realmente preciso) para poder satisfacer los requisitos especificados.

Dados los recursos mencionados anteriormente, no se permitirán los nombres de usuario ``canales'' ni ``ayuda'' (pero no hay que hacer ninguna comprobación para esto: se asume que no se darán de alta esos usuarios en el Admin Site).


Como información pública de noticia se mostrará:
\begin{itemize}
\item El título de la noticia, como enlace a la noticia en el sitio web original.
\item La fecha en que fue publicada la noticia en el sitio original (junto al texto ``publicada en'').
\item La fecha en que fue seleccionada para esta revista (junto al texto ``elegida en'').
\item El contenido de la noticia.
\item El nombre del canal de donde viene la noticia, como enlace a la página de ese canal en MiRevista.
  \end{itemize}



%%----------------------------------------------------------------------------
\subsection{Funcionalidad optativa}

De forma optativa, se podrá incluir cualquier funcionalidad relevante en el contexto de la asignatura. Se valorarán especialmente las funcionalidades que impliquen el uso de técnicas nuevas, o de aspectos de Django no utilizados en los ejercicios previos, y que tengan sentido en el contexto de esta práctica y de la asignatura.

Sólo a modo de sugerencia, se incluyen algunas posibles funcionalidades optativas:

\begin{itemize}
\item Atención al idioma indicado por el navegador. El idioma de la interfaz de usuario del planeta tendrá en cuenta lo que especifique el navegador.

\item Generación de un canal RSS para los contenidos que se muestran en la página principal.

\item Uso de AJAX para algún aspecto de la práctica (por ejemplo, para seleccionar una noticia para una revista).

\item Puntuación de noticias. Cada visitante (registrado o no) puede dar un ``+1'' a cualquier noticia del sitio. La suma de ``+'' que ha obtenido una noticia se verá cada vez que se vea la noticia en el sitio.

\item Comentarios a revistas. Cada usuario registrado puede comentar cualquier revista del sitio. Estos comentarios se podrán ver luego en la página de la revista.

\item Autodescubrimiento de canales. Dada una URL (de un blog, por ejemplo), busca si en ella hay algún enlace que parece un canal. Si es así, ofrécelo al usuario para que lo pueda elegir. Esto se puede usar, por ejemplo, en la página que muestra el listado de canales, como una opción más para elegir canales (``especifica un blog para buscar sus canales'').
\end{itemize}


%%----------------------------------------------------------------------------
\subsection{Entrega de la práctica}

\textbf{Fecha límite de entrega de la práctica:} 22 de mayo de 2013.

La práctica se entregará subiéndola al recurso habilitado a tal fin en el sitio Moodle de la asignatura. Los alumnos que no entreguen las práctica de esta forma serán considerados como no presentados en lo que a la entrega de prácticas se refiere. Los que la entreguen podrán ser llamados a realizar también una entrega presencial, que tendrá lugar en la fecha y hora exacta se les comunicará oportunamente. Esta entrega presencial podrá incluir una conversación con el profesor sobre cualquier aspecto de la realización de la práctica.

Para entregar la práctica en el Moodle, cada alumno subirá al recurso habilitado a tal fin un fichero tar.gz con todo el código fuente de la práctica. El fichero se habrá de llamar practica-user.tar.gz, siendo ``user'' el nombre de la cuenta del alumno en el laboratorio.

El fichero que se entregue deberá constar de un proyecto Django completo y listo para funcionar en el entorno del laboratorio, incluyendo la base de datos con datos suficientes como para poder probarlo. Estos datos incluirán al menos tres usuarios con sus datos correspondientes, y con al menos cinco noticias en su revista, y al menos tres canales RSS diferentes. Se incluirá también un fichero README con los siguientes datos:

\begin{itemize}
\item Nombre de la asignatura.
\item Nombre completo del alumno.
\item Nombre de su cuenta en el laboratorio.
\item Nombres y contraseñas de los usuarios creados para la práctica. Éstos deberán incluir al menos un usuario con cuenta ``marta'' y contraseña ``marta'' y otro usuario con cuenta ``pepe'' y contraseña ``pepe''.
\item Canales disponibles en el sitio, incluyendo su URL
\item Resumen de las peculiaridades que se quieran mencionar sobre lo implementado en la parte obligatoria.
\item Lista de funcionalidades opcionales que se hayan implementado, y breve descripción de cada una.
\item URL del vídeo demostración de la funcionalidad básica
\item URL del vídeo demostración de la funcionalidad optativa, si se ha realizado funcionalidad optativa
\end{itemize}

El fichero README se incluirá también como comentario en el recurso de subida de la práctica, asegurándose de que las URLs incluidas en él son enlaces ``pinchables''.

Los vídeos de demostración serán de una duración máxima de 2 minutos (cada uno), y consistirán en una captura de pantalla de un navegador web utilizando la aplicación, y mostrando lo mejor posible la funcionalidad correspondiente (básica u opcional). Siempre que sea posible, el alumno comentará en el audio del vídeo lo que vaya ocurriendo en la captura. Los vídeos se colocarán en algún servicio de subida de vídeos en Internet (por ejemplo, Vimeo o YouTube).

Hay muchas herramientas que permiten realizar la captura de pantalla. Por ejemplo, en GNU/Linux puede usarse Gtk-RecordMyDesktop o Istanbul (ambas disponibles en Ubuntu). Es importante que la captura sea realizada de forma que se distinga razonablemente lo que se grabe en el vídeo.

En caso de que convenga editar el vídeo resultante (por ejemplo, para eliminar tiempos de espera) puede usarse un editor de vídeo, pero siempre deberá ser indicado que se ha hecho tal cosa con un comentario en el audio, o un texto en el vídeo. Hay muchas herramientas que permiten realizar esta edición. Por ejemplo, en GNU/Linux puede usarse OpenShot o PiTiVi.

%%----------------------------------------------------------------------------
\subsection{Notas y comentarios}

La práctica deberá funcionar en el entorno GNU/Linux (Ubuntu) del laboratorio de la asignatura con la versión de Django que se ha usado en prácticas (Django 1.7.*).

La práctica deberá funcionar desde el navegador Firefox disponible en el laboratorio de la asignatura.

Se recomienda construir una o varias aplicaciones complementarias para probar la descarga y almacenamiento en base de datos de los canales que alimentarán las revistas.

Los usuarios registrados pueden, en principio, hacer disponible cualquier canal de cualquier blog. Sin embargo, para la funcionalidad mínima es suficiente que MiRevista funcione con blogs de WordPress.com.

Los canales (feeds) RSS que produce la aplicación web realizada en la práctica deberán funcionar al menos con el navegador Firefox (considerándolos como canales RSS) disponibles en el laboratorio.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica final (2012, diciembre)}
\label{practica-final-2012-12}

La práctica final de la asignatura consiste en la creación de un planeta, o agregador de canales, como aplicación web. A continuación se describe el funcionamiento y arquitectura general de la aplicación, la funcionalidad mínima que debe proporcionar, y otra funcionalidad optativa que podrá tener. Llamaremos a la aplicación MiPlaneta.

%%----------------------------------------------------------------------------
\subsubsection{Arquitectura y funcionamiento general}

Arquitectura general:

\begin{itemize}
\item La práctica consistirá en una aplicación web que servirá los datos a los usuarios.

\item MiPlaneta se construirá como un proyecto Django, que incluirá una o varias aplicaciones Django que implementen la funcionalidad requerida.

\item Para el almacenamiento de datos persistente se usará SQLite3, con tablas definidas según modelos en Django.

\item Se usará la aplicación Django ``Admin Site'' para mantener los usuarios con cuenta en el sistema, y para la gestión general de las bases de datos necesarias (todas las bases de datos que mantenga MiPlaneta tendrá que ser accesible vía este ``Admin Site''.

\item Se utilizarán plantillas Django (a ser posible, una jerarquía de plantillas, para que MiPlaneta tenga un aspecto similar) para definir las páginas que se servirán a los navegadores de los usuarios. Estas plantillas incluirán en todas las páginas al menos:
  \begin{itemize}
  \item Un banner (imagen) del sitio, en la parte superior.
  \item Un menú de opciones.
  \item Un pie de página con una nota de copyright.
  \end{itemize}

Cada una de estas partes estará marcada con propiedades ``id'' en HTML, para poder ser referenciadas en hojas de estilo CSS.

\item Se utilizarán hojas de estilo CSS para determinar la apariencia de MiPlaneta. Estas hojas definirán al menos el color de fondo y del texto, y alguna propiedad para las partes marcadas que se indican en el apartado anterior.
\end{itemize}

Funcionamiento general:

\begin{itemize}
\item Los usuarios serán dados de alta en MiPlaneta mediante el módulo ``Admin Site'' de Django. Una vez estén dados de alta, serán considerados ``usuarios registrados''.

\item Los usuarios registrados podrán especificar en MiPlaneta su número de usuario en el Moodle de la ETSIT. Por ejemplo, si la página de perfil de un usuario en el Moodle de la ETSIT es \url{http://docencia.etsit.urjc.es/moodle/user/profile.php?id=8} (llamaremos a la página a la que apunta esta URL la ``página del usuario en el Moodle de la ETSIT'') su número de usuario es 8. Puede obtenerse el número de usuario en el Moodle de la ETSIT a través de los enlaces a ese usuario en los mensajes que pone en sus foros, por ejemplo.

\item Cada usuario registrado podrá indicar el blog que le representa en MiPlaneta. Para ello, especificará la URL del canal RSS correspondiente a ese blog.

\item Habrá una URL para actualizar los contenidos.

\item Cualquier navegador podrá acceder a la interfaz pública del sitio, que ofrecerá los artículos en la base de datos e información pública para cada usuario.
\end{itemize}


%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad mínima}

Interfaz pública: recursos a servir como páginas HTML completas (pensadas para ser vistas en el navegador) para cualquier visitante (sea usuario registrado o no):

\begin{itemize}
\item /: Página principal de MiPlaneta. Lista de los últimos 20 artículos, por fecha de publicación, en orden inverso (más nuevos primero). Para cada artículo se mostrará la ``información pública de articulo'', ver más abajo.

\item /users: Lista de usuarios registrados de MiPlaneta. Para casa usuario se mostrará la ``información resumida de usuario'', ver más abajo.

\item /users/alias: Información sobre el usuario que tiene el alias ``alias'' en MiPlaneta. El alias es el nombre de usuario que tiene como usuario registrado, fijado con el módulo ``Admin Site''. Se incluirá la ``información completa de usuario'', ver más abajo.

\item /update: Actualización de los artículos de todos los blogs. Cuando sea invocada, se bajarán todos los canales y se almacenarán en la base de datos los artículos correspondientes. Si un artículo ya estaba en la base de datos, no debe almacenarse dos veces. Al terminar, enviará una redirección a la página principal.
\end{itemize}

Además, todas las páginas de la interfaz pública incluirán un formulario para poder autenticarse si se es usuario registrado, y un menú desde el que se podrá acceder a / (con el texto ``página principal''), a /users (con el texto ``listado de usuarios'') y a /update (con el texto ``actualizar'').

Interfaz privada: recursos a servir como páginas HTML completas para usuarios registrados (una vez se han autenticado).

\begin{itemize}
\item Todos los recursos de la interfaz pública.
\item /conf: Configuración de usuario. Tendrá un formulario en el que se podrá especificar:
  \item Un número de usuario del Moodle de la ETSIT
  \item La URL del canal RSS de un blog
  \item El color de fondo de todas las páginas del blog
  \item El color del texto normal de todas las páginas del blog
\end{itemize}

Además, todas las páginas de la interfaz privada incluirán el nombre y la foto del usuario registrado (según aparecen en su perfil el en Moodle de la ETSIT), una opción para cerrar la sesión y un menú que incluirá las mismas opciones que el menú público más otra que permita acceder a /conf con el texto ``configuración''.

Tanto el color de fondo como el del texto normal de las páginas deberán recibirse en el navegador como parte de un documento CSS.

Detalles de las distintas informaciones mencionadas:

\begin{itemize}
\item Información pública de artículo. Se mostrará:
  \begin{itemize}
  \item Del artículo: su título (que será un enlace al artículo en su blog original) y su contenido (tal y como venga especificado en el canal).
  \item Del blog original que lo contiene: el nombre del blog, un enlace al blog, y otro a su canal RSS.
  \item Del usuario del Moodle de la ETSIT correspondiente: el nombre, que será un enlace a ``/users/alias'' (el alias en MiPlaneta) y la foto.
  \end{itemize}

\item Información resumida de usuario. Se mostrará:
  \begin{itemize}
  \item Del usuario del Moodle de la ETSIT correspondiente: el nombre, la foto, el enlace a su sitio web. El nombre será un enlace a ``/users/alias'' (el alias en MiPlaneta).
  \item Del blog original que lo contiene: el nombre del blog, que será un enlace a ese mismo blog.
  \end{itemize}

\item Información completa de usuario. Se mostrará:
  \begin{itemize}
  \item Del usuario del Moodle de la ETSIT correspondiente: el nombre, la foto, el enlace a su sitio web, y un enlace a su perfil en Moodle de la ETSIT.
  \item Del blog original que lo contiene: el nombre del blog, un enlace al blog, y otro a su canal RSS, todos los artículos almacenados para ese blog.
  \item De cada artículo: su título (que será un enlace al artículo en su blog original) y su contenido (tal y como venga especificado en el canal).
  \end{itemize}
\end{itemize}


Además de estos recursos, se atenderá a cualquier otro que sea necesario para proporcionar la funcionalidad indicada.


%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad optativa}

De forma optativa, se podrá incluir cualquier funcionalidad relevante en el contexto de la asignatura. Se valorarán especialmente las funcionalidades que impliquen el uso de técnicas nuevas, o de aspectos de Django no utilizados en los ejercicios previos, y que tengan sentido en el contexto de esta práctica y de la asignatura.

Sólo a modo de sugerencia, se incluyen algunas posibles funcionalidades optativas:

\begin{itemize}
\item Atención al idioma indicado por el navegador. El idioma de la interfaz de usuario del planeta tendrá en cuenta lo que especifique el navegador.

\item Generación de un canal RSS para los contenidos que se muestran en la página principal.

\item Uso de AJAX para algún aspecto de la práctica (por ejemplo, en los formularios de /conf)

\item Puntuación de artículos. Cada usuario registrado puede puntuar cualquier artículo del sitio, por ejemplo entre 1 y 5. Estas puntuaciones se podrán ver luego junto al artículo en cuestión.

\item Comentarios a artículos. Cada usuario registrado puede comentar cualquier artículo del sitio. Estos comentarios se podrán ver luego junto al artículo en cuestión (en la página de ese artículo).

\item Soporte para logos. Cada blog o artículo de un blog se presentará junto con un logo que represente al blog en cuestión.

\item Autodescubrimiento de canales. Dada una URL (de un blog, por ejemplo), busca si en ella hay algún enlace que parece un canal. Si es así, ofrécelo al usuario para que lo pueda elegir. Esto se puede usar, por ejemplo, en la página de configuración de usuario, como una opción más para elegir canales (``especifica un blog para buscar sus canales'').
\end{itemize}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica final (2011, diciembre)}
\label{practica-final-2011-12}

%[Este enunciado es aún tentativo, incompleto, y está sujeto a cambios]

La práctica final de la asignatura consiste en la creación de un sitio web de creación de revistas con resúmenes de información procedente de sitios terceros, MetaMagazine. A continuación se describe el funcionamiento y arquitectura general de la aplicación, la funcionalidad mínima que debe proporcionar, y otra funcionalidad optativa que podrá tener.

%%----------------------------------------------------------------------------
\subsubsection{Arquitectura y funcionamiento general}

Arquitectura general:

\begin{itemize}
\item La práctica consistirá en una aplicación web que servirá los datos a los usuarios.

\item La aplicación web se construirá como un proyecto Django, que incluirá una o varias aplicaciones Django que implementen la funcionalidad requerida.

\item Para el almacenamiento de datos persistente se usará SQLite3, con tablas definidas según modelos en Django.

\item Se usará la aplicación Django ``Admin site'' para mantener los usuarios con cuenta en el sistema, y para la gestión general de las bases de datos necesarias.

\item Se utilizarán plantillas Django (a ser posible, una jerarquía de plantillas, para que toda la aplicación tenga un aspecto similar) para definir las páginas que se servirán a los navegadores de los usuarios. Estas plantillas incluirán en todas las páginas al menos:
  \begin{itemize}
  \item Un banner (imagen) del sitio, en la parte superior.
  \item Un menú de opciones también en la parte superior.
  \item Un pie de página con una nota de copyright.
  \end{itemize}

\item Se utilizarán hojas de estilo CSS para determinar la apariencia de la aplicación.
\end{itemize}

Funcionamiento general:

\begin{itemize}
\item El sitio MetaMagazine ofrece como servicio la construcción de revistas con resúmenes de información obtenidos a partir de canales RSS de ciertos sitios terceros. Para construir una revista, primero se extraerán noticias de los canales correspondientes. Para cada noticia, se buscarán las URLs incluidas en su texto. Para cada URL, se visitará la página correspondiente, y se extraerá de ella la información (texto, imágenes, etc.) deseada. Con esta información se compondrá una página HTML que será la que se sirva a los navegadores que visiten la revista de ese usuario.

\item Cada usuario autenticado podrá construir una revista indicando en qué información de sitios terceros están interesados (eligiendo los canales RSS correspondientes), e indicando cuántas noticias de cada uno se tomarán como máximo cuando se actualice la revista. Cuando un usuario autenticado indica un nuevo canal en el que está interesado, el sistema genera una revista para ese sitio a partir de su canal (usando el número de noticias que ha seleccionado), y se lo muestra al usuario. Si el usuario lo acepta, se toma nota del sitio y de los contenidos de la revista en la base de datos.

\item Cuando cualquier visitante de MetaMagazine acceda a la revista creada por un usuario, podrá ver la información almacenada para esa revista. Además, la página de la revista incluirá un mecanismo para actualizarla, bajando información de los sitios correspondientes. En la actualización, para cada canal sólo se considerará el número de noticias más actuales que haya seleccionado el creador de la revista (y se ignorarán las más antiguas, salvo que ya estén en la base de datos). No se eliminarán las noticias antiguas de la base de datos al actualizar las revistas.

\item Cuando esté visitando MetaMagazine un visitante sin autenticar, le aparecerá una caja para autenticarse. Si es un usuario autenticado, le aparecerá un mecanismo para salir de la cuenta (``desautenticarse'').
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad mínima}

Esta es la funcionalidad mínima que habrá de proporcionar la aplicación:

\begin{itemize}
\item Para cada revista (correspondiente a un usuario registrado del sitio) se mostrará a cualquier visitante:
  \begin{itemize}
  \item El título de la revista.
  \item Un enlace a los canales y sitios web correspondientes a esos canales, y la fecha de última actualización (para cada uno de ellos).
  \item Para cada canal, un mecanismo para actualizar en la base de datos la información extraída las páginas web que referencie.
  \item El texto de las noticias de los sitios elegidos para esa revista.
  \item Para cada noticia, un mecanismo para desplegar la información extraída las páginas web que referencie.
  \item Un mecanismo para desplegar (de una vez) la información extraída de todas las noticias.
  \end{itemize}

\item Para cada noticia, la información que se mostrará será:
  \begin{itemize}
  \item Enlace a la página de la noticia en MetaMagazine.
  \item Los enlaces a las páginas web cuya URL aparezca en la noticia.
  \item Para cada una de esas páginas, las primeras 50 palabras que incluyan (basta con considerar, por ejemplo, las primeras 50 palabras incluidas en elementos $<p>$).
  \item Para cada una de esas páginas, 5 de las imágenes que incluyan, si las hubiera.
  \item Para cada una de esas páginas, los vídeos de Youtube, si los hubiera.
  \end{itemize}

\item Para cada revista (correspondiente a un usuario registrado del sitio) se mostrará al usuario que la construye:

  \begin{itemize}
  \item Toda la información anterior, que se muestra también para cualquier visitante.
  \item El título de la revista de forma que se pueda cambiar.
  \item Una zona para incluir nuevos canales en la revista, que incluirá:
    \begin{itemize}
    \item Un menú con la opción de sitios de los que se podrán incluir canales.
    \item Un formulario para indicar qué canal del sitio elegido se incluirá.
    \end{itemize}
  \item Para cada canal de la revista, un mecanismo para eliminarlo.
  \end{itemize}

\item Como mínimo, se podrán seleccionar los siguientes tipos de canales:
  \begin{itemize}
  \item Canales RSS correspondientes a usuarios de Twitter\footnote{Para el usuario ``jgbarah'': \\
    \url{https://twitter.com/statuses/user_timeline/jgbarah.rss}}.
  \item Canales RSS correspondientes a usuarios de Identi.ca\footnote{Para el usuario ``jgbarah'': \\
    \url{http://identi.ca/jgbarah/rss}}.
  \item Canales RSS correspondientes a usuarios de Youtube\footnote{Para el usuario ``user'': \\
\url{http://gdata.youtube.com/feeds/api/videos?max-results=5&alt=rss&author=user}}.
  \end{itemize}
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Esquema de recursos servidos (funcionalidad mínima)}

Recursos a servir como páginas HTML completas (pensadas para ser vistas en el navegador):

\begin{itemize}
\item /: Página principal de MetaMagazine, con texto de bienvenida y contenidos de una de las revistas (aleatoriamente, se elegirá una cada vez que se reciba una nueva visita, y se incluirán sus contenidos, que deberán ser iguales a los que se verían en la página de esa revista).
\item /channels: Lista de canales activos, con enlace a los RSS correspondientes
\item /magazines: Lista de revistas disponibles, con enlace a cada una de ellas.
\item /magazines/user: Revista del usuario ``user''
\item /news/id: Página de la noticia ``id'' en MetaMagazine: título de la noticia y elementos a mostrar (enlaces de la noticia, primeras palabras de los sitios web en esos enlaces, imágenes en esos enlaces, etc.)
\end{itemize}

Recursos a servir con texto HTML listo para empotrar en otras páginas (esto es, texto que pueda ir dentro de un elemento $<body>$):

\begin{itemize}
\item /api/news/id: Para la noticia ``id'', elementos a mostrar (enlaces de la noticia, primeras palabras de los sitios web en esos enlaces, imágenes en esos enlaces, etc.)
\end{itemize}

Además de estos recursos, se atenderá a cualquier otro que sea necesario para proporcionar la funcionalidad indicada.


%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad optativa}

De forma optativa, se podrá incluir cualquier funcionalidad relevante en el contexto de la asignatura. Se valorarán especialmente las funcionalidades que impliquen el uso de técnicas nuevas, o de aspectos de Django no utilizados en los ejercicios previos, y que tengan sentido en el contexto de esta práctica y de la asignatura.

Sólo a modo de sugerencia, se incluyen algunas posibles funcionalidades optativas:

\begin{itemize}

\item Recurso /conf: Configuración del usuario, para usuarios registrados. Incluirá campos para editar su nombre público, su contraseña (dos veces, para comprobar).
\item Recurso /conf/skin: Configuración del estilo (skin), para usuarios registrados. Mediante un formulario, el usuario podrá editar el fichero CSS que codificará su estilo, o podrá copiar el de otro usuario. Cada usuario tendrá un estilo (fichero CSS) por defecto, que el sistema le asignará si no lo ha configurado.
\item Recurso /rss/user: Canal RSS para la revista del usuario ``user'', con las 20 últimas entradas (del canal que sea.
\item Uso de AJAX para otros aspectos de la aplicación. Por ejemplo, para indicar qué canales se quieren.
\item Puntuación de revistas. Cada usuario registrado puede puntuar cualquier revista del sitio, por ejemplo entre 1 y 5. Estas puntuaciones se podrán ver luego junto a la revista en cuestión.
\item Puntuación de noticias. Cada usuario registrado puede puntuar cualquier noticia del sitio, por ejemplo entre 1 y 5. Estas puntuaciones se podrán ver luego junto a la noticia en cuestión.
\item Comentarios a noticias. Cada usuario registrado puede comentar cualquier noticia del sitio. Estos comentarios se podrán ver luego junto a la noticia en cuestión.
\item Soporte para avatares. Cada canal se presentará junto con el avatar (el logo que ha elegido el usuario en el sitio original, como por ejemplo Twitter) del canal.
\item Mejoras en la identificación de la información de las páginas web enlazadas. Por ejemplo, seleccionar las imágenes descartando las que probablemente son pequeños iconos (analizando el tamaño de la imagen), o identificando otros elementos relevantes.
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Notas y comentarios}

La práctica deberá funcionar en el entorno GNU/Linux (Ubuntu) del laboratorio de la asignatura, con la versión de Django instalada en /usr/local/django (Django 1.3.1).

La práctica deberá funcionar desde el navegador Firefox disponible en el laboratorio de la asignatura.

Se recomienda construir una o varias aplicaciones complementarias para probar la descarga y almacenamiento en base de datos de los canales que alimentarán el planeta.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica final (2012, mayo)}
\label{practica-final-2012-05}

%[Este enunciado es aún tentativo, incompleto, y está sujeto a cambios]

La práctica final a entregar en la convocatoria extraordinaria (mayo de 2012) será como la de la entrega ordinaria (práctica~\ref{practica-final-2011-12}), con las diferencias que se indican en los siguientes apartados.

%%----------------------------------------------------------------------------
\subsubsection{Arquitectura y funcionamiento general}

Con respecto a las de la práctica de la convocatoria ordinaria, el enunciado tiene los siguientes cambios:

\begin{itemize}
\item En lugar de canales RSS se utilizarán canales Atom para descargar las noticias de los sitios terceros.
\item Para construir una revista, en lugar de indicar qué información se quiere de cada sitio tercero, se indicarán cadenas de texto. Estas cadenas se utilizarán como hashtags en los sitios terceros que los soporten, o como cadenas de búsqueda en los que no. Por lo tanto, el usuario especificará una cadena, que se usará para definir qué canales Atom de los sitios terceros habrá que considerar (ver funcionalidad mínima más adelante).
\item Al definir su revista, un usuario podrá por tanto especificar cadenas, igual que antes especificaba canales de un sitio tercero. Ahora, cada cadena indicará qué canales de todos los sitios terceros hay que considerar para esa revista.
\end{itemize}

El resto queda igual.

%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad mínima}

Con respecto a la de la práctica de la convocatoria ordinaria, el enunciado tiene los siguientes cambios:

\begin{itemize}
\item Para cada cadena que un usuario especifique en su revista se bajará información de, como mínimo, los siguientes canales (los ejemplos serían para la cadena ``urjc''):
  \begin{itemize}
  \item Canal Atom correspondiente al hashtag de Twitter definido por esa cadena\footnote{Para el hashtag ``\#urjc'': \\
    \url{http://search.twitter.com/search.atom?q=\%23urjc}}.
  \item Canal Atom correspondientes al hashtag de Identi.ca definido por esa cadena\footnote{Para el hashtag ``\#urjc'': \\
    \url{http://identi.ca/api/statusnet/tags/timeline/urjc.atom}}.
  \item Canal Atom correspondientes a la búsqueda en Youtube de esa cadena\footnote{Para la búsqueda ``urjc'': \\
\url{http://gdata.youtube.com/feeds/api/videos?q=urjc&max-results=5&alt=atom}}.
  \end{itemize}

\end{itemize}

El resto queda igual.



%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica final (2010, enero)}

La práctica final de la asignatura consiste en la creación de un planeta, o agregador de canales, como aplicación web. A continuación se describe el funcionamiento y arquitectura general de la aplicación, la funcionalidad mínima que debe proporcionar, y otra funcionalidad optativa que podrá tener.

%%----------------------------------------------------------------------------
\subsubsection{Arquitectura y funcionamiento general}

Arquitectura general:

\begin{itemize}
\item La práctica consistirá en una aplicación web que servirá los datos a los usuarios.

\item La aplicación web se construirá como un proyecto Django, que incluirá una o varias aplicaciones Django que implementen la funcionalidad requerida.

\item Para el almacenamiento de datos persistente se usará SQLite3, con tablas definidas según modelos en Django.

\item Se usará la aplicación Django ``Admin site'' para mantener los usuarios con cuenta en el sistema, y para la gestión general de las bases de datos necesarias.

\item Se utilizarán plantillas Django (a ser posible, una jerarquía de plantillas, para que toda la aplicación tenga un aspecto similar) para definir las páginas que se servirán a los navegadores de los usuarios. Estas plantillas incluirán en todas las páginas al menos:
  \begin{itemize}
  \item Un banner (imagen) del sitio, en la parte superior.
  \item Un menú de opciones también en la parte superior.
  \item Un pie de página con una nota de copyright.
  \end{itemize}

\item Se utilizarán hojas de estilo CSS para determinar la apariencia de la aplicación.
\end{itemize}

Funcionamiento general:

\begin{itemize}
\item Los usuarios indicarán en qué canales (blogs) están interesados. Para ello, cada usuario podrá especificar un número en principio ilimitado de URLs, cada una correspondiente a un canal que le interesa.
\item Cuando un usuario indica que le interesa un blog, se baja el canal correspondiente y se almacenan en la base de datos los artículos referenciados en él.
\item Cuando un usuario acceda a la URL de actualización de sus blogs, se bajan los canales correspondientes a todos ellos, y se almacenan en la base de datos los artículos correspondientes. Si un artículo ya estaba en la base de datos, no debe almacenarse dos veces.
\item Cualquier navegador podrá acceder a la interfaz pública del sitio, que ofrecerá los artículos en la base de datos e información pública para cada usuario.
\item Sólo los navegadores con un usuario autenticado podrán personalizar en qué blogs están interesados.
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad mínima}

\begin{itemize}
\item Para cada artículo en la base de datos del planeta, se mostrarán (salvo que se indique lo contrario) su título (que será un enlace al artículo en su blog original), un enlace al blog original que lo incluye, y su contenido (tal y como venga especificado en el canal).
\item El planeta mostrará en una interfaz pública (visible por cualquiera que no tenga cuenta en el sitio) todos los artículos que tenga en la base de datos, organizados en los siguientes recursos:

  \begin{itemize}
  \item /: Lista de los últimos 20 artículos, por fecha de publicación, en orden inverso (más nuevos primero).
  \item /blog: Lista de los últimos 20 artículos del blog ``blog'', por fecha de publicación, en orden inverso (más nuevos primero).
  \item /blog/num: Artículo número ``num'' del blog ``blog'', siendo ``0'' el artículo más antiguo de ese blog que se tiene en la base de datos.
  \end{itemize}

\item Además, el planeta mostrará en una interfaz privada (visible sólo para un usuario concreto cuando se autentica como tal) los artículos que éste haya seleccionado, organizados en los siguientes recursos:

  \begin{itemize}
  \item /custom: Lista de los últimos 20 artículos, por fecha de publicación, en orden inverso (más nuevos primero), de los blogs seleccionados por el usuario.
  \end{itemize}

\item Además, habrá ciertos recursos donde los usuarios registrados podrán (una vez autenticados) configurar ciertos aspectos del sitio:

  \begin{itemize}
  \item /conf: Configuración del usuario. Incluirá campos para editar su nombre público, su contraseña (dos veces, para comprobar), y los blogs en los que está interesado. Estos blogs se podrán elegir bien de un menú desplegable (en el que estarán los que ya se están bajando) o indicando sus datos (la URL de su canal correspondiente).
  \item /conf/skin: Configuración del estilo (skin) con el que el usuario quiere ver el sitio. Mediante un formulario, el usuario podrá editar el fichero CSS que codificará su estilo, o podrá copiar el de otro usuario. Cada usuario tendrá un estilo (fichero CSS) por defecto, que el sistema le asignará si no lo ha configurado.
  \item /update: Actualizará los artículos de los blogs en los que está interesado el usuario.
  \end{itemize}

\item Para cada usuario, se mantendrán ciertos recursos públicos con información relacionada con ellos:

  \begin{itemize}
  \item /user: Nombre de usuario y lista de blogs que interesan al usuario ``user''.
  \item /user/feed: Canal RSS  con los 20 últimos artículos que interesan al usuario ``user''.
  \end{itemize}

\item El idioma de la interfaz de usuario del planeta tendrá en cuenta lo que especifique el navegador, y podrá ser especificado también en la URL /conf para los usuarios registrados (entre opciones para indicar un idioma particular, o ``por defecto'', que respetará lo que indique el navegador).

\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad optativa}

De forma optativa, se podrá incluir cualquier funcionalidad relevante en el contexto de la asignatura. Se valorarán especialmente las funcionalidades que impliquen el uso de técnicas nuevas, o de aspectos de Django no utilizados en los ejercicios previos, y que tengan sentido en el contexto de esta práctica y de la asignatura.

Sólo a modo de sugerencia, se incluyen algunas posibles funcionalidades optativas:

\begin{itemize}
\item Uso de AJAX para algún aspecto de la práctica (por ejemplo, para elegir un nuevo blog, o para subir comentarios)
\item Puntuación de artículos. Cada usuario registrado puede puntuar cualquier artículo del sitio, por ejemplo entre 1 y 5. Estas puntuaciones se podrán ver luego junto al artículo en cuestión.
\item Comentarios a artículos. Cada usuario registrado puede comentar cualquier artículo del sitio. Estos comentarios se podrán ver luego junto al artículo en cuestión (en la página de ese artículo).
\item Soporte para logos. Cada blog o artículo de un blog se presentará junto con un logo que represente al blog en cuestión.
\item Autodescubrimiento de canales. Dada una URL (de un blog, por ejemplo), busca si en ella hay algún enlace que parece un canal. Si es así, ofrécelo al usuario para que lo pueda elegir. Esto se puede usar, por ejemplo, en la página de configuración de usuario, como una opción más para elegir canales (``especifica un blog para buscar sus canales'').
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Entrega de la práctica}

La práctica se entregará el día del examen de la asignatura, o un día posterior si así se acordase. La entrega se realizará presencialmente, en el laboratorio donde tienen lugar las clases de la asignatura habitualmente.

Cada alumno entregará su práctica en un fichero tar.gz, que tendrá preparado antes del comienzo del examen, y cuya localización mostrará al profesor durante el transcurso del mismo. El fichero se habrá de llamar practica-user.tar.gz, siendo ``user'' el nombre de la cuenta del alumno en el laboratorio.

El fichero que se entregue deberá constar de un proyecto Django completo y listo para funcionar en el entorno del laboratorio, incluyendo la base de datos con datos suficientes como para poder probarlo. Estos datos incluirán al menos tres usuarios, y cinco blogs con sus noticias correspondientes. Se incluirá también un fichero README con los siguientes datos:

\begin{itemize}
\item Nombre de la asignatura.
\item Nombre completo del alumno.
\item Nombre de su cuenta en el laboratorio.
\item Nombres y contraseñas de los usuarios creados para la práctica.
\item Resumen de las peculiaridades que se quieran mencionar sobre lo implementado en la parte obligatoria.
\item Lista de funcionalidades opcionales que se hayan implementado, y breve descripción de cada una.
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Notas y comentarios}

La práctica deberá funcionar en el entorno GNU/Linux (Ubuntu) del laboratorio de la asignatura, con la versión de Django instalada en /usr/local/django (Django 1.1.1).

La práctica deberá funcionar desde el navegador Firefox disponible en el laboratorio de la asignatura.

Se recomienda construir una o varias aplicaciones complementarias para probar la descarga y almacenamiento en base de datos de los canales que alimentarán el planeta.

Los canales (feeds) RSS que produce la aplicación web realizada en la práctica deberán funcionar al menos con el agregador Liferea.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica final (2010, junio)}

La práctica final para entrega en la convocatoria extraordinaria de junio será similar a la especificada para la convocatoria ordinaria de enero. En particular, deberá cumplir las siguientes condiciones:

\begin{itemize}
\item La arquitectura general será la misma, salvo:
  \begin{itemize}
  \item En lugar de incluir en las plantillas Django un menú de opciones en la parte superior de las páginas, ese menú estará en una columna en la parte derecha de cada página.
  \end{itemize}
\item El funcionamiento general será el mismo, salvo:
  \begin{itemize}
  \item Cuando un usuario indica que le interesa un blog, no se almacenan en la base de datos los artículos de ese blog.
  \item No habrá URL de actualización de los blogs de un usuario.
  \item Los artículos correspondientes a un blog se actualizarán sólo cuando se visualice una página del planeta que incluya artículos de ese blog. En ese momento, los artículos nuevos (los que no estaban ya en la base de datos) se bajarán a dicha base de datos.
  \end{itemize}
\item La funcionalidad mínima será la misma, salvo:
  \begin{itemize}
  \item No se implementará el recurso ``/update'', dado que el funcionamiento de la actualización será diferente, como se ha indicado anteriormente.
  \item El recurso ``/user'' incluirá la lista de los últimos 20 artículos, por fecha de publicación, en orden inverso (más nuevos primero), de los blogs seleccionados por el usuario, además del nombre de usuario.
  \item Cada usuario registrado podrá puntuar cualquier artículo del sitio entre 1 y 5. Estas puntuaciones se podrán ver junto al artículo en cuestión, en todos los sitios donde aparece un enlace a él en el planeta.
  \end{itemize}
\item La funcionalidad optativa será la misma, salvo la puntuación de artículos, que ya ha sido mencionada como funcionalidad mínima.
\end{itemize}

El resto de condiciones serán iguales que en la convocatoria de enero de 2010.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica final (2010, diciembre)}

La entrega de esta práctica será necesaria para poder optar a aprobar la asignatura.
 Este enunciado corresponde con la convocatoria de diciembre.

La práctica final de la asignatura consiste en la creación de una aplicación web de resumen y cache de micronotas (microblogs). En este enunciado, llamaremos a esa aplicación ``MiResumen'', y a los resúmenes de micronotas para cada usuario, ``microresumen''.

Los sitios de microblogs permiten a sus usuarios compartir notas breves (habitualmente de 140 caracteres o menos). Entre los más populares pueden mencionarse Twitter\footnote{\url{http://twitter.com}} e Identi.ca\footnote{\url{http://identi.ca}}. La aplicación web a realizar se encargará de mostrar las micronotas que se indiquen, junto con información relacionada. A continuación se describe el funcionamiento y arquitectura general de la aplicación, la funcionalidad mínima que debe proporcionar, y otra funcionalidad optativa que podrá tener.

%%----------------------------------------------------------------------------
\subsubsection{Arquitectura y funcionamiento general}

Arquitectura general:

\begin{itemize}
\item La práctica consistirá en una aplicación web que servirá los datos a los usuarios.

\item La aplicación web se construirá como un proyecto Django, que incluirá una o varias aplicaciones Django que implementen la funcionalidad requerida.

\item Para el almacenamiento de datos persistente se usará SQLite3, con tablas definidas según modelos en Django.

\item Se usará la aplicación Django ``Admin site'' para mantener los usuarios con cuenta en el sistema, y para la gestión general de las bases de datos necesarias.

\item Se utilizarán plantillas Django (a ser posible, una jerarquía de plantillas, para que toda la aplicación tenga un aspecto similar) para definir las páginas que se servirán a los navegadores de los usuarios. Estas plantillas incluirán en todas las páginas al menos:
  \begin{itemize}
  \item Un banner (imagen) del sitio, en la parte superior.
  \item Un menú de opciones también en la parte superior, a la derecha del banner del sitio.
  \item Un pie de página con una nota de copyright.
  \end{itemize}

\item Se utilizarán hojas de estilo CSS para determinar la apariencia de la aplicación.
\end{itemize}

Funcionamiento general:

\begin{itemize}
\item Se considerarán sólo micronotas en Identi.ca. Llamaremos a los usuarios de Identi.ca ``micronoteros''.
\item MiResumen mantendrá usuarios, que habrán de autenticarse para poder configurar la aplicación.
\item Cada usuario de MiResumen indicará qué micronoteros de Identi.ca le interesan, configurando una lista de micronoteros.
\item Cuando un usuario indica que le interesa un micronotero, MiResumen bajará el canal RSS correspondiente, y se almacenarán en la base de datos las micronotas referenciadas en él.
\item Cuando un usuario acceda a la URL de actualización de su microresumen, se bajan los canales correspondientes a todos los micronoteros que tiene especificados, y se almacenan en la base de datos las micronotas correspondientes. Si una micronota ya estaba en la base de datos, no debe almacenarse dos veces.
\item Cualquier navegador podrá acceder a la interfaz pública del sitio, que ofrecerá los microresúmenes de cada usuario.
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad mínima}

\begin{itemize}
\item Para cada micronota en la base de datos del planeta, se mostrarán (salvo que se indique lo contrario) su texto, un enlace a la micronota en Identi.ca, el nombre del micronotero que la puso (con un enlace a su página en Identi.ca), y la fecha en que la puso, 
\item MiResumen mostrará en una interfaz pública (visible por cualquiera que no tenga cuenta en el sitio) todas las micronotas que tenga en la base de datos, organizadas en los siguientes recursos:

  \begin{itemize}
  \item /: Microresumen de las últimas 50 micronoticias, ordenadas por fecha inversa de publicación, en orden inverso (más nuevos primero).
  \item /noteros/micronotero: Microresumen de las últimas 50 micronoticias del micronotero ``micronotero'', ordenadas por fecha inversa de publicación, en orden inverso (más nuevos primero).
  \item /usuarios/usuario: Microresumen de las últimas 50 micronoticias de los micronoteros que sigue el usuario ``usuario'', ordenadas por fecha inversa de publicación.
  \item /usuarios/usuario/feed: Canal RSS  con las 50 últimas micronotas que interesan al usuario ``usuario''.
  \end{itemize}

\item Además MiResumen proporcionará ciertos recursos donde los usuarios registrados podrán (una vez autenticados) configurar ciertos aspectos del sitio:

  \begin{itemize}
  \item /conf: Configuración del usuario. Incluirá campos para editar su nombre público, su contraseña (dos veces, para comprobar), y el idioma que prefiere (al menos deberá poder elegir entre español e inglés).
  \item /conf/skin: Configuración del estilo (skin) con el que el usuario quiere ver el sitio. Mediante un formulario, el usuario podrá editar el fichero CSS que codificará su estilo, o podrá copiar el de otro usuario. Cada usuario tendrá un estilo (fichero CSS) por defecto, que el sistema le asignará si no lo ha configurado.
  \item /micronoteros: Lista de los micronoteros seleccionados por el usuario, junto con enlace a su página en Identi.ca. El usuario podrá eliminar un micronotero de la lista, o añadir uno nuevo mediante POST sobre ese recurso. Los micronoteros se podrán elegir bien de un menú desplegable (en el que estarán los que tiene seleccionados cualquier usuario de MiResumen) o indicando su nombre de micronotero en Identi.ca.
  \item /update: Actualizará las micronotas de los micronoteros en los que está interesado el usuario.
  \end{itemize}

\item El idioma de la interfaz de usuario del planeta será el especificado en la URL /conf para los usuarios registrados. Para los visitantes no registrados, será español.

\end{itemize}

Para la generación de canales RSS y para la internacionalización se podrán usar los mecanismos que proporciona Django, o no, según el alumno considere que le sea más conveniente.

%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad optativa}

De forma optativa, se podrá incluir cualquier funcionalidad relevante en el contexto de la asignatura. Se valorarán especialmente las funcionalidades que impliquen el uso de técnicas nuevas, o de aspectos de Django no utilizados en los ejercicios previos, y que tengan sentido en el contexto de esta práctica y de la asignatura.

Sólo a modo de sugerencia, se incluyen algunas posibles funcionalidades optativas:

\begin{itemize}
\item Uso de Ajax para algún aspecto de la práctica (por ejemplo, para solicitar actualización de la lista de micronotas, o para suscribirse a un micronotero picando sobre una micronota suya).
\item Promoción de micronotas. Cada usuario registrado puede promocionar (indicar que le gusta) cualquier micronota del sitio. Cada micronota se verá en el sitio junto con el número de promociones que ha recibido.
\item Soporte para avatares. Cada micronota se presentará junto con el avatar (imagen) correspondiente al micronotero que la ha puesto.
\item Soporte para Twitter y/o otros sitios de microblogging (micronotas) además de Identi.ca
\item Enlace a URLs. Se identificarán en las micronotas los textos que tengan formato de URL, y se mostrará esa URL como enlace.
\item Enlace a micronoteros referenciados. Se identificarán en las micronotas los textos que tengan formato de identificador de micronotero (@nombre), y se mostrarán como enlace a la página del micronotero en cuestión.
\item Suscripción a los mismos micronoteros a los que esté suscrito otro usuario. Un usuario podrá indicar que quiere suscribirse a la misma lista de micronoteros que otro, indicando sólo su identificador de usuario.
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Entrega de la práctica}

La práctica se entregará electrónicamente en una de las dos fechas indicadas:

\begin{itemize}
\item El día anterior al examen de la asignatura, esto es, el 12 de diciembre, a las 18:00.
\item El 30 de diciembre a las 23:00.
\end{itemize}

Además, los alumnos que hayan presentado las prácticas podrán tener que realizar una entrega presencial en una de las dos fechas indicadas:

\begin{itemize}
\item El día del examen, esto es, el 14 de diciembre, al terminar el examen de teoría. La lista de alumnos que tengan que hacer la entrega presencial se indicará durante el examen de teoría.
\item El día 10 de enero, a las 16:00. La lista de alumnos que tengan que hacer la entrega presencial se indicará con anterioridad en el sito web de la asignatura.
\end{itemize}

La entrega presencial se realizará en el laboratorio donde tienen lugar habitualmente las clases de la asignatura.

Cada alumno entregará su práctica colocándola en un directorio en su cuenta en el laboratorio. El directorio, que deberá colgar directamente de su directorio hogar (\$HOME), se llamará ``pf\_django\_2010''.

El directorio que se entregue deberá constar de un proyecto Django completo y listo para funcionar en el entorno del laboratorio, incluyendo la base de datos con datos suficientes como para poder probarlo. Estos datos incluirán al menos tres usuarios, y cinco micronoteros con sus micronotas correspondientes. Entre los usuarios, habrá en la base de datos al menos los dos siguientes.

\begin{itemize}
\item Usuario ``pepe'', contraseña ``XXX''
\item Usuario ``pepa'', contraseña ``XXX''
\end{itemize}

Cada uno de estos usuarios estará ya siguiendo al menos dos micronoteros.

Se incluirá también en el directorio que se entregue un fichero README con los siguientes datos:

\begin{itemize}
\item Nombre de la asignatura.
\item Nombre completo del alumno.
\item Nombre de su cuenta en el laboratorio.
\item Nombres y contraseñas de los usuarios creados para la práctica.
\item Nombres de al menos cinco micronoteros cuyas noticias estén en la base de datos de la aplicación.
\item Resumen de las peculiaridades que se quieran mencionar sobre lo implementado en la parte obligatoria.
\item Lista de funcionalidades opcionales que se hayan implementado, y breve descripción de cada una.
\end{itemize}

Es importante que estas normas se cumplan estrictamente, y de forma especial lo que se refiere al nombre del directorio, porque la recogida de las prácticas, y parcialmente su prueba, se hará con herramientas automáticas.

[Las normas de entrega podrán incluir más detalles en el futuro, compruébalas antes de realizar la entrega.]


%%----------------------------------------------------------------------------
\subsubsection{Notas y comentarios}

La práctica deberá funcionar en el entorno GNU/Linux (Ubuntu) del laboratorio de la asignatura, con la versión 1.2.3 de Django.

La práctica deberá funcionar desde el navegador Firefox disponible en el laboratorio de la asignatura.

Se recomienda construir una o varias aplicaciones complementarias para probar la descarga y almacenamiento en base de datos de los canales que alimentarán MiResumen.

Los canales (feeds) RSS que produce la aplicación web realizada en la práctica deberán funcionar al menos con el agregador Liferea y el que lleva integrado Firefox.

%%----------------------------------------------------------------------------
\subsubsection{Notas de ayuda}

A continuación, algunas notas que podrían ayudar a la realización de la práctica. Gracias a los alumnos que han contribuido a ellas, bien preguntando sobre algún problema que han encontrado, o incluso aportando directamente una solución correcta.

\begin{itemize}
\item \textbf{Conversión de fechas:}

La conversión de fechas, tal y como vienen en el formato de los canales RSS de Identi.ca, al formato de fechas datetime adecuado para almacenarlas en una tabla de la base de datos se puede hacer así:

\begin{verbatim}
from email.utils import parsedate
from datetime import datetime

dbDate = datetime(*(parsedate(rssDate)[:6]))
\end{verbatim}

El uso de ``*'' permite, en este caso, obtener una referencia a la tupla de siete elementos que contiene los parámetros que espera datetime() (que son siete parámetros).

Más información sobre parsedate() en la documentación del módulo email.utils de Python.

\item \textbf{Envío de hojas CSS:}

Para que el navegador interprete adecuadamente una hoja de estilo, puede ser conveniente fijar el tipo de contenidos de la respuesta HTTP en la que la aplicación la envía al navegador. En otras palabras, asegurar que cuando el navegador reciba la hoja CSS, le venga adecuadamente marcada como de tipo ``text/css'' (y no ``text/html'' o similar, que es como vendrá marcado normalmente lo que responda la aplicación).

En código, bastaría con poner la cabecera ``Content-Type'' adecuada al objeto que tiene la respuesta HTTP que devolverá la función que atiende a la URL para servir la hoja CSS (normalmente en \texttt{views.py}):

\begin{verbatim}
myResponse = HttpResponse(cssText)
myResponse['Content-Type'] = 'text/css'
return myResponse
\end{verbatim}

\end{itemize}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Práctica final (2011, junio)}

La entrega de esta práctica será necesaria para poder optar a aprobar la asignatura.
 Este enunciado corresponde con la convocatoria de junio.

La práctica final de la asignatura consiste en la creación de una aplicación web de resumen y cache de micronotas (microblogs). En este enunciado, llamaremos a esa aplicación ``MiResumen2'', y a los resúmenes de micronotas para cada usuario, ``microresumen''.

Los sitios de microblogs permiten a sus usuarios compartir notas breves (habitualmente de 140 caracteres o menos). Entre los más populares pueden mencionarse Twitter\footnote{\url{http://twitter.com}} e Identi.ca\footnote{\url{http://identi.ca}}. La aplicación web a realizar se encargará de mostrar las micronotas que se indiquen, junto con información relacionada. A continuación se describe el funcionamiento y arquitectura general de la aplicación, la funcionalidad mínima que debe proporcionar, y otra funcionalidad optativa que podrá tener.

%%----------------------------------------------------------------------------
\subsubsection{Arquitectura y funcionamiento general}

Arquitectura general:

\begin{itemize}
\item La práctica consistirá en una aplicación web que servirá los datos a los usuarios.

\item La aplicación web se construirá como un proyecto Django, que incluirá una o varias aplicaciones Django que implementen la funcionalidad requerida.

\item Para el almacenamiento de datos persistente se usará SQLite3, con tablas definidas según modelos en Django.

\item No se mantendrán usuarios con cuenta, ni usando la aplicación Django ``Admin site'' ni de otra manera. Por lo tanto, para usar el sitio no hará falta registrarse, ni entrar en una cuenta.

\item Se utilizarán plantillas Django (a ser posible, una jerarquía de plantillas, para que toda la aplicación tenga un aspecto similar) para definir las páginas que se servirán a los navegadores de los usuarios. Estas plantillas incluirán en todas las páginas al menos:
  \begin{itemize}
  \item Un banner (imagen) del sitio, en la parte superior.
  \item Un menú de opciones justo debajo del banner, formateado en una línea.
  \item Un pie de página con una nota de copyright.
  \end{itemize}

\item Se utilizarán hojas de estilo CSS para determinar la apariencia de la aplicación. Estas hojas se almacenará en la base de datos.
\end{itemize}

Funcionamiento general:

\begin{itemize}
\item Se considerarán sólo micronotas en Identi.ca. Llamaremos a los usuarios de Identi.ca ``micronoteros''.
\item MiResumen2 recordará a todos sus visitantes. A estos efectos, consideraremos como sesión de un visitante todas las interacciones que se hagan con el sitio desde el mismo navegador (por lo tanto, se podrán usar cookies de sesión para mantener esta relación).
\item MiResumen2 mostrará notas de Identi.ca, que se irán actualizando según se indica en el apartado siguiente.
\item Los visitantes de MiResumen2 podrán seleccionar cualquier micronota que aparezca en él.
\item Cada visitante podrá ver las micronotas que ha seleccionado, por orden inverso de publicación en Identi.ca, en un listado que incluirá también la fecha en que seleccionó cada micronota.
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad mínima}

\begin{itemize}
\item Para cada micronota en la base de datos del planeta, se mostrarán (salvo que se indique lo contrario):
  \begin{itemize}
  \item el texto de la micronota
  \item un enlace a la micronota en Identi.ca
  \item el nombre del micronotero que la puso (con un enlace a su página en Identi.ca)
  \item la fecha en que se publicó en Identi.ca
  \item un botón para que cualquier visitante pueda seleccionar esta nota (o deseleccionarla si ya la había seleccionado)
  \item si el usuario ha seleccionado la micronota, la fecha en que la había seleccionado
  \item un número que representará el número de visitantes que han seleccionado esta micronota
  \end{itemize}

\item MiResumen2 mostrará en una interfaz pública (visible por cualquiera que visite el sitio) todas las micronotas que tenga en la base de datos, organizadas en los siguientes recursos:

  \begin{itemize}
  \item /: Microresumen de las últimas 30 micronoticias almacenadas en MiResumen2, ordenadas por fecha inversa de publicación (más nuevos primero). Además, incluirá un enlace al recurso de actualización (ver más abajo), y al microresumen de las 30 siguientes micronoticias (/30, ver más abajo)
  \item /nnn: Microresumen de las micronoticas entre la nnn y la nnn+29, según el orden de fecha inversa de publicación (más nuevos primero, con números más bajos). Se considerará que la micronota más reciente es la micronota 0. Así, /0 mostrará lo mismo que / , /30 mostrará las 30 micronotas siguientes a las mostradas en / y /40 mostrará las micronotas de la 40 a la 67.
  \item /update: Recurso de actualización: cuando se acceda a él, MiResumen2 accederá al RSS de la página principal de Identi.ca y extraerá de él las últimas 20 micronotas (o menos, si no hay tantas micronotas en el canal que no estén ya en la base de datos), almacenándolas en la base de datos y mostrándolas.
  \item /selected: Listado de todas las micronotas seleccionadas por el visitante actual, ordenadas por fecha de publicación inversa (más nuevas primero).
  \item /feed: Canal RSS  con las 10 micronotas más recientes (por fecha de publicación) que ha seleccionado el visitante actual. 
  \item /conf: Configuración del visitante. Incluirá campos para editar el nombre del visitante, que se mostrará en todas las páginas del sitio que se sirvan a ese visitante.
  \item /skin: Configuración del estilo (skin) con el que el visitante quiere ver el sitio. Mediante un formulario, el visitante podrá editar el fichero CSS que codificará su estilo (y que se almacenará en la base de datos). Si no lo han cambiado, los visitantes tendrán el estilo CSS por defecto del sitio.
  \item /cookies: Página HTML que incluirá un listado de las cookies que se están usando con cada uno de los visitantes conocidos para la aplicación, en formato listo para que cada cookie pueda ser copiada y pegada en un editor de cookies.
  \end{itemize}

\end{itemize}

Para la generación de canales RSS y la gestión de sesiones y/o cookies se podrán usar los mecanismos que proporciona Django, o no, según el alumno considere que le sea más conveniente.

%%----------------------------------------------------------------------------
\subsubsection{Funcionalidad optativa}

De forma optativa, se podrá incluir cualquier funcionalidad relevante en el contexto de la asignatura. Se valorarán especialmente las funcionalidades que impliquen el uso de técnicas nuevas, o de aspectos de Django no utilizados en los ejercicios previos, y que tengan sentido en el contexto de esta práctica y de la asignatura.

Sólo a modo de sugerencia, se incluyen algunas posibles funcionalidades optativas:

\begin{itemize}
\item Uso de Ajax para algún aspecto de la práctica (por ejemplo, para seleccionar y deseleccionar una micronota).
\item Votación de micronotas. Cada visitante podrá dar una puntuación entre 0 y 10 a cada micronota. Cuando se muestre cada micronota en el sitio, además de los demás datos que se han mencionado, se incluirá la media de las votaciones que ha tenido, y el número de votaciones que ha tenido esa micronota. Una vez que un visitante ha votado una micronota, no puede volver a votarla, ni cambiar su votación.
\item Soporte para avatares. Cada micronota se presentará junto con el avatar (imagen) correspondiente al micronotero que la ha puesto.
\item Soporte para Twitter y/o otros sitios de microblogging (micronotas) además de Identi.ca
\item Enlace a URLs, etiquetas y micronoteros referenciados. Se identificarán en las micronotas los textos que tengan formato de URL, y se mostrará esa URL como enlace, los que tengan formato de etiqueta (tag, nombres que comienzan por \#), mostrándolos como enlace a la página Identi.ca para ese tag, y los micronoteros referenciados (nombres que comienzan por @), mostrándolos como enlace a la página del micronotero en cuestión en Identi.ca.
\item Recomendación de micronotas. En una página, se mostrarán las micronotas que probablemente interesen al micronotero, basada en la historia de elecciones pasadas. El algoritmo a usarse puede ser: busca los tres visitantes que más notas hayan elegido en común con las del visitante actual, y muestra todas las micronotas que hayan elegido esos visitantes y el visitante actual aún no ha elegido.
\end{itemize}

%%----------------------------------------------------------------------------
\subsubsection{Entrega de la práctica}

La práctica se entregará electrónicamente como muy tarde el día 17 de junio a las 23:00.

Además, los alumnos que hayan presentado las prácticas podrán tener que realizar una entrega presencial el día que esté fijado el examen de teoría de la asignatura. La entrega presencial se realizará en el laboratorio donde tienen lugar habitualmente las clases de la asignatura.

Cada alumno entregará su práctica colocándola en un directorio en su cuenta en el laboratorio. El directorio, que deberá colgar directamente de su directorio hogar (\$HOME), se llamará ``pf\_django\_2010\_2''.

El directorio que se entregue deberá constar de un proyecto Django completo y listo para funcionar en el entorno del laboratorio, incluyendo la base de datos con datos suficientes como para poder probarlo. Estos datos incluirán al menos cinco visitantes diferentes, cada uno con al menos 3 micronotas elegidas, y un total de al menos 50 micronotas en la base de datos de MiResumen2

Se incluirá también en el directorio que se entregue un fichero README con los siguientes datos:

\begin{itemize}
\item Nombre de la asignatura.
\item Nombre completo del alumno.
\item Nombre de su cuenta en el laboratorio.
\item Resumen de las peculiaridades que se quieran mencionar sobre lo implementado en la parte obligatoria.
\item Lista de funcionalidades opcionales que se hayan implementado, y breve descripción de cada una.
\end{itemize}

Es importante que estas normas se cumplan estrictamente, y de forma especial las que se refieren al nombre del directorio, porque la recogida de las prácticas, y parcialmente su prueba, se hará con herramientas automáticas.

[Las normas de entrega podrán incluir más detalles en el futuro, compruébalas antes de realizar la entrega.]


%%----------------------------------------------------------------------------
\subsubsection{Notas y comentarios}

La práctica deberá funcionar en el entorno GNU/Linux (Ubuntu) del laboratorio de la asignatura, con la versión 1.2.3 de Django.

La práctica deberá funcionar desde el navegador Firefox disponible en el laboratorio de la asignatura.

Se recomienda construir una o varias aplicaciones complementarias para probar la descarga y almacenamiento en base de datos del canal que alimentarán MiResumen.

Los canales (feeds) RSS que produce la aplicación web realizada en la práctica deberán funcionar al menos con el agregador Liferea y el que lleva integrado Firefox.

Se recomienda utilizar alguna extensión para Firefox que permita manipular cookies para poder probar la aplicación simulando varios visitantes desde el mismo navegador.

%%----------------------------------------------------------------------------
\subsubsection{Notas de ayuda}

A continuación, algunas notas que podrían ayudar a la realización de la práctica. Gracias a los alumnos que han contribuido a ellas, bien preguntando sobre algún problema que han encontrado, o incluso aportando directamente una solución correcta.

\begin{itemize}
\item \textbf{Conversión de fechas:}

La conversión de fechas, tal y como vienen en el formato de los canales RSS de Identi.ca, al formato de fechas datetime adecuado para almacenarlas en una tabla de la base de datos se puede hacer así:

\begin{verbatim}
from email.utils import parsedate
from datetime import datetime

dbDate = datetime(*(parsedate(rssDate)[:6]))
\end{verbatim}

El uso de ``*'' permite, en este caso, obtener una referencia a la tupla de siete elementos que contiene los parámetros que espera datetime() (que son siete parámetros).

Más información sobre parsedate() en la documentación del módulo email.utils de Python.

\item \textbf{Envío de hojas CSS:}

Para que el navegador interprete adecuadamente una hoja de estilo, puede ser conveniente fijar el tipo de contenidos de la respuesta HTTP en la que la aplicación la envía al navegador. En otras palabras, asegurar que cuando el navegador reciba la hoja CSS, le venga adecuadamente marcada como de tipo ``text/css'' (y no ``text/html'' o similar, que es como vendrá marcado normalmente lo que responda la aplicación).

En código, bastaría con poner la cabecera ``Content-Type'' adecuada al objeto que tiene la respuesta HTTP que devolverá la función que atiende a la URL para servir la hoja CSS (normalmente en \texttt{views.py}):

\begin{verbatim}
myResponse = HttpResponse(cssText)
myResponse['Content-Type'] = 'text/css'
return myResponse
\end{verbatim}

\end{itemize}

\newpage

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\section{Materiales de interés}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Material complementario general}

\begin{itemize}
\item Philip Greenspun, \textsl{Software Engineering for Internet Applications}:\\
  \url{http://philip.greenspun.com/seia/} \\
  utilizado en un curso del MIT \\
  \url{http://philip.greenspun.com/teaching/one-term-web}
\end{itemize}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Introducción a Python}

\begin{itemize}
\item \url{http://www.python.org/doc}

Documentación en línea de Python (incluyendo un Tutorial, los manuales de referencia, HOWTOS, etc. Usa la versión para Python 2.x

\item \url{http://www.diveintopython.org/}

``Dive into Python'', por Mark Pilgrim. Libro para aprender Python, orientado a quien ya sabe programa con lenguajes orientados a objetos.

\item \url{http://wiki.python.org/moin/BeginnersGuide/Programmers}

Otros textos sobre Python, de interés especialmente para quien ya sabe programar en otros lenguajes.

\item \url{http://en.wikibooks.org/wiki/Python_Programming}

``Python Programming'', Wikibook sobre programación en Python.

\item \url{http://en.wikipedia.org/wiki/Python_(programming_language)}

Python en la Wikipedia

\item \url{http://www.python.org/dev/peps/pep-0008/}

Style Guide for Python Code (PEP 8). Esta es la guía de estilo que se puede comprobar con el programa pep8.
\end{itemize}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Aplicaciones web mínimas}

\begin{itemize}
\item \url{http://docs.python.org/dev/howto/sockets.html}

``Socket Programming HOWTO''. Programación de sockets en Python, guía rápida.

\item \url{http://docs.python.org/library/socket.html}

Documentación de la biblioteca de sockets de Python.

\item \url{https://addons.mozilla.org/en-US/firefox/} 

Lista de add-ons y plugins para Firefox.

\end{itemize}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{SQL y SQLite}


\begin{itemize}
\item \url{http://www.shokhirev.com/nikolai/abc/sql/sql.html}

``SQLite / SQL Tutorials: Basic SQL'', por Nikolai Shokhirev

\end{itemize}
