%% ejercicios.tex
%%

%% Ejercicios (comunes para SAT y SARO), 2013-2014.

%% %%----------------------------------------------------------------------------
%% %%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------


\section{Prácticas de entrega voluntaria}

%%---------------------------------------------------------------------------
%%---------------------------------------------------------------------------
%%---------------------------------------------------------------------------
\subsection{Entrega de microprácticas y miniprácticas}
\label{sec:eje-entrega-practicas-incr}

Para la entrega de prácticas incrementales se utilizarán repositorios git públicos alojados en el GitLab de la ETSIT. Para cada práctica entregable los profesores abrirán un repositorio público en el proyecto CursosWeb~\footnote{\url{https://gitlab.etsit.urjc.es/CursosWeb}}, con un nombre que comenzará por ``X--Serv--'', seguirá con el nombre del tema en el que se inscribe la práctica (por ejemplo, ``Python'' para el tema de introducción a Python) y el identificador del ejercicio (por ejemplo, ``Calculadora''). En el caso de las miniprácticas, el nombre comenzará por ``Mini--'', seguido de un número (el de orden de entrega), y el identificador del ejercicio. Este repositorio incluirá un fichero README.md, con el enunciado de la práctica, y cualquier otro material que los profesores estimen conveniente.

Cada alumno dispondrá de una cuenta en el GitLab de la ETSIT, que usará a efectos de entrega de prácticas. Esta cuenta deberá ser apuntada en una lista, en el sitio de la asignatura en el campus virtual, cuando los profesores se lo soliciten. Si el alumno desea que no sea fácil trazar su identidad a partir de esta cuenta, puede elegir abrir una cuenta no ligada a sus datos personales: a efectos de valoración, los profesores utilizará la lista anterior. Si el alumno lo desea, puede usar la misma cuenta en GitLab para otros fines, además de para la entrega de prácticas.

Para trabajar en una práctica, los alumnos comenzarán por realizar una copia (fork) de cada uno de estos repositorios. Esto se realiza en GitLab, visitando (tras haberse autenticado con su cuenta de usuario de GitLab para entrega de prácticas) el repositorio con la práctica, y pulsando sobre la opción de realizar un fork. Una vez esto se haya hecho, el alumno tendrá un fork del repositorio en su cuenta, con los mismos contenidos que el repositorio original de la práctica. Visitando este nuevo repositorio, el alumno podrá conocer la url para clonarlo, con lo que podrá realizar su clon (copia) local, usando la orden \verb|git clone|.

A partir de este momento, el alumno creará los ficheros que necesite en su copia local, los irá marcando como cambios con \verb|git commit| (usando previamente \verb|git add|, si es preciso, para añadirlos a los ficheros considerados por git), y cuando lo estime conveniente, los subirá a su repositorio en GitLab usando \verb|git push|.

Por lo tanto, el flujo normal de trabajo de un alumno con una nueva práctica será:

\begin{verbatim}
[En GitLab: visita el repositorio de la práctica en CursosWeb,
y le hace un fork, creando su propia copia del repositorio]

git clone url_copia_propia

[Se cera el directorio copia_propia, copia local del repositorio propio]

cd copia_propia
git add ... [ficheros de la práctica]
git commit .
git push
\end{verbatim}

Conviene visitar el repositorio propio en GitLab, para comprobar que efectivamente los cambios realizados en la copia local se han propagado adecuadamente a él, tras haber invocado \verb|git push|.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Minipráctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2016}

\textbf{Fecha recomendada de entrega:} Antes del 2 de abril de 2021.

Esta práctica tendrá como objetivo la creación de una aplicación web simple para acortar URLs. Los usuarios de la aplicación podrán especificar URLs y nombres de recurso, y a partir de ese momento, esos nombres de recurso redireccionarán a su URL correspondiente. La aplicación podrá realizarse según el esquema de clases explicado en clase (usando, si se quiere, el módulo \texttt{webapp.py}), o de cualquier otra forma.

El repositorio de partida es: \url{https://gitlab.etsit.urjc.es/cursosweb/mini-1-acortadora/}

El código ha de guardarse en un fichero llamado \emph{shortener.py}.

El funcionamiento de la aplicación será el siguiente:

\begin{itemize}
\item Recurso ``/'', invocado mediante GET. Devolverá una página HTML con un formulario. En ese formulario habrá dos campos, uno para la url a acortar, y el otro para escribir el nombre de recurso para esa url. El formulario se enviará al servidor mediante POST, y sus dos campos se llamarán, respectivamenet, \texttt{url} y \texttt{short}. Además, esa misma página incluirá un listado de todas las URLs reales y acortadas que maneja la aplicación en este momento.

\item Recurso ``/'', invocado mediante POST. Si el comando POST incluye una \texttt{qs} (query string) que tenga campos \texttt{url} y \texttt{short} se devolverá una página HTML con la URL original y la URL acortada (ambas como enlaces pinchables), y se apuntará la correspondencia (ver más abajo).

Si el POST no trae una \texttt{qs} que se haya podido generar en el formulario, devolverá una página HTML con un mensaje de error.

Si la URL especificada en el formulario comienza por ``http://'' o ``https://'', se considerará que ésa es la URL a acortar. Si no es así, se le añadirá ``https://'' por delante, y se considerará que esa es la url a acortar. Por ejemplo, si en el formulario se escribe ``http://gsyc.es'', la URL a acortar será ``http://gsyc.es''. Si se escribe ``gsyc.es'', la URL a acortar será ``https://gsyc.es''.

Si se recibe una petición para un nombre de recurso que ya corresponde con una URL, se cambiará la URL. Una URL podrá estar referenciada por más de un nombre de recurso.

Así, por ejemplo, si se quiere acortar \texttt{http://gsyc.urjc.es} con el nombre de recurso \texttt{gsyc}, y la aplicación está en el puerto 1234 de la máquina ``localhost'', se invocará (mediante POST) la URL

\texttt{https://localhost:1234/}

y en el cuerpo de esa petición HTTP irá la \texttt{qs}

\verb|url=https://gsyc.urjc.es&short=gsyc|

Normalmente, esta invocación POST se realizará rellenando el formulario que ofrece la aplicación.

Como respuesta, la aplicación devolverá (en el cuerpo de la respuesta HTTP) una página HTML con el formulario, y la lista de URLs acortadas, incluyendo esta.


\item Recursos correspondientes a URLs acortadas. Estos serán los nombres de recurso (los que se escribieron en el campo \texttt{short}) con el prefijo ``/''. Cuando la aplicación reciba un GET sobre uno de estos recursos, si el número corresponde a una URL acortada, devolverá un HTTP REDIRECT a la URL real. Si no la tiene, devolverá HTTP ERROR ``Recurso no disponible''.

Por ejemplo, si se recibe 

\verb|http://localhost:1234/gsyc|

la aplicación devolverá un HTTP REDIRECT a la URL

\verb|https://gsyc.urjc.es|

\end{itemize}

%La aplicación funcionará con estado: se supone que cada vez que la aplicación muera y vuelva a ser lanzada, no perderá todo su estado anterior. Para ello, se guardarán las URLs acortadas en un fichero CSV. Al lanzar la aplicación, se leerá el fichero CSV con las URLs acortadas. Y cada vez que se incluya una nueva URL acortada en el sistema, también se guardará esta información en el fichero CSV.

\textbf{Comentario}

Se recomienda utilizar un diccionario para almacenar las URLs reales y los nombres de recurso correspondientes. La clave de búsqueda será el nombre de recurso, y el valor, la URL real.

Se recomienda realizar la aplicación en varios pasos:

\begin{itemize}
\item Comenzar por reconocer ``GET /'', y devolver el formulario correspondiente.
\item Reconocer ``POST /'', y devolver la página HTML correspondiente (con la URL real y el nombre de recurso).
\item Reconocer ``GET /recurso'' (para cualquier recurso), y realizar la redirección correspondiente.
\item Manejar las condiciones de error y realizar el resto de la funcionalidad.
\end{itemize}

%%---------------------------------------------------------------------
%%---------------------------------------------------------------------
\subsection{Minipráctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2015}

\textbf{Fecha recomendada de entrega:} Hasta el 14 de abril.

Esta práctica tendrá como objetivo la creación de una aplicación web (de nombre \emph{acorta}) simple para acortar URLs utilizando Django (en un nuevo proyecto Django llamado \emph{project}). Su enunciado será igual que el de la práctica 1 de entrega voluntaria (ejercicio~\ref{subsec:practica-vol-1-2016}), salvo en los siguientes aspectos:

\begin{itemize}
  \item Se implementará utilizando Django.
  \item Tendrá que almacenar la información relativa a las URLs que acorta en una base de datos, de forma que aunque la aplicación sea rearrancada, las URLs acortadas sigan funcionando adecuadamente.
  \item Utilizará plantillas, de manera que el código Python y el HTML estarán separados.
\end{itemize}

%Repositorio GitHub de entrega: \\
%\url{https://github.com/CursosWeb/X-Serv-18.2-Practica2}

Repositorio GitLab de partida: \\
\url{https://gitlab.etsit.urjc.es/cursosweb/x-serv-18.2-practica2}

\newpage



%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 01: Conceptos básicos de aplicaciones web}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Web 2.0}
\label{subsec:web-20}

\textbf{Enunciado:}

Seguramente has oído hablar muchas veces de la ``web 2.0''. ¿Qué es lo que significa esta expresión? Si puedes, cita referencias en la Red al respecto.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Última búsqueda}
\label{subsec:ultima-busqueda}

\textbf{Enunciado:}

¿Cómo mostrar la última búsqueda en un  buscador?

Se quiere que un cierto buscador web muestre a sus usuarios la última búsqueda que hicieron en él. Para ello, se utilizarán cookies. Son relevantes tres interacciones HTTP: la primera, en la que el navegador pide la página HTML con el formulario de búsquedas, la segunda, en la que el navegador envía la cadena de búsqueda que el usuario ha escrito en el navegador, y la tercera, que se realizará en cualquier momento posterior, en la que el navegador vuelve a pedir la página con el formulario de búsquedas, que ahora se recibe anotada con la cadena de la última búsqueda. Se pide indicar dónde van las cookies, cómo son éstas, y cómo solucionan el problema.

\textbf{Solución:}

Se puede hacer utilizando identificador de sesión en las cookies. Pero también es posible hacerlo sin que el servidor (el buscador) tenga que almacenar todos los identificadores de sesión  junto con la última búsqueda realizada, lo que tiene varias ventajas.

Para identificador de sesión, basta con un número aleatorio grande que se almacena en la cookie. La cookie la envía el buscador al navegador en la respuesta al HTTP GET que se realiza para obtener la página del buscador. Luego, esa cookie va en cada POST que hace el navegador (para realizar una nueva búsqueda). Si no se quiere que el buscador almacena la última pregunta para cada sesión, se puede enviar la propia búsqueda en la cookie.   

\textbf{Discusiones relacionadas:}

\begin{itemize}
\item Ventajas y desventajas de utilizar identificadores de sesión, o de almacenar las preguntas en cookies en el navegador.
\item ¿Serviría el mismo esquema para un servicio de banca electrónica? (en lugar de ``recordar'' la última pregunta, se quiere recordar qué usuario se autenticó.
\item Cómo implementarlo usando el identificador de usuario y la contraseña en la cookie. Implicaciones para la seguridad. El problema de la salida de la sesión.
\end{itemize}

%%--------------------------------------------------------------------
%%--------------------------------------------------------------------
\subsection{Espía a tu navegador (Firefox Developer Tools)}
\label{subsec:firefox-devel}

\textbf{Enunciado:}

El navegador hace una gran cantidad de tareas interesantes para esta asignatura. Es muy útil poder ver cómo lo hace, y aprender de los detalles que veamos. De hecho, también, en ciertos casos, se puede modificar su comportamiento. Para todo esto, se pueden usar herramientas específicas. En nuestro caso, vamos a usar las ``Firefox Developer Tools'', que vienen ya preinstaladas en Firefox.

El ejercicio consiste en:

\begin{itemize}
\item Ojear las distintas herramientas de Firefox Developer Tools.
\item Utilizarlas para ver la interacción HTTP al descargar una página web real.
\item Utilizarlas para ver el árbol DOM de una página HTML real.
\end{itemize}

Más adelante, lo utilizaremos para otras cosas, así que si quieres jugar un rato con lo que permiten hacer estas herramientas, mucho mejor.

\textbf{Referencias}

Sitio web de Firefox Developer Tools: \\
\url{https://developer.mozilla.org/en/docs/Tools}



%%--------------------------------------------------------------------
%%--------------------------------------------------------------------
\subsection{Espía a tu navegador (Firebug)}
\label{subsec:firebug}

\textbf{Enunciado:}

El navegador hace una gran cantidad de tareas interesantes para esta asignatura. Es muy útil poder ver cómo lo hace, y aprender de los detalles que veamos. De hecho, también, en ciertos casos, se puede modificar su comportamiento. Para todo esto, se pueden usar herramientas específicas. En nuestro caso, vamos a usar el módulo ``Firebug'' de Firefox (también disponible para otros navegadores).

El ejercicio consiste en:

\begin{itemize}
\item Instalar el módulo Firebug en tu navegador
\item Utilizarlo para ver la interacción HTTP al descargar una página web real.
\item Utilizarlo para ver el árbol DOM de una página HTML real.
\end{itemize}

Más adelante, lo utilizaremos para otras cosas, así que si quieres jugar un rato con lo que permite hacer Firebug, mucho mejor.

\textbf{Referencias}

Sitio web de Firebug: \url{https://getfirebug.com/}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Explora tus cookies}
\label{subsec:explora-cookies}

\textbf{Enunciado:}

En este ejercicio vamos a ver las cookies que intercambia nuestro navegador con un servidor simple. El servidor que vamos a usar es \verb|cookies-server-6.py| (en la carpeta \verb|Python-Web/cookies|). Ejecuta el servidor, y luego, utilizando las herramientas de desarrollador de Firefox (ver ejercicio~\ref{subsec:firefox-devel}, observa las cookies que se intercambian entre este servidor y el navegador. En concreto, carga en el navegador la página principal del servidor, escribe algo en el formulario que te aparecerá, y contesta a este ejercicio escribiendo las cookies que observes en la interacción que se produce cuando le das al botón ``Submit'' para enviar al servidor el texto que has escrito.

Cuando lances el servidor, indicarás en qué puerto TCP escuchará (que tendrá que estar libre en la máquina donde se lance). Por ejemplo, para lanzarlo escuchando en el puerto 8000, usarás la línea:

\begin{verbatim}
python3 cookies-server-6.py -p 8000
\end{verbatim}

En el navegador, tendrás que indicar la url correspondiente al puerto que hayas indicado. Por ejemplo, para acceder al servidor lanzado en el puerto 8000, la url será \url{http://localhost:8000}.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Explora tus cookies (2)}
\label{subsec:explora-cookies-2}

\textbf{Enunciado:}

Vamos a explorar las diferencias entre dos programas que tratan de ``recordarte'' lo último que escribiste en un formulario. Ambos son servidores HTTP, y están en el directorio \verb|Python-Web/cookies| (en el repositorio de código de la asignatura), y son \verb|cookies-server-8.py| y \verb|cookies-server-9.py|. El ejercicio consiste en ejecutar cada uno de ellos de esta forma:

\begin{itemize}
\item Lanza el programa servidor que vas a probar.
\item En el navegador, carga la página correspondiente al recurso principal de ese servidor.
\item Borra las cookies que pueda haber para ese servidor.
\item Recarga la página que tienes en el navegador
\item En el formulario que tienes en la página, escribe ``Primero'', y envíalo al servidor. Llamaremos al resultado de este envío (la página que muestre el navegador al recibir la respuesta del servidor ``Página~1''.
\item En el formulario que tienes ahora en la Página~1, escribe ``Segundo'', y vuelve a enviarlo al servidor. Llamaremos al resultado de este envío (la página que muestre el navegador al recibir la respuesta del servidor ``Página~2''.
\item En el formulario que tienes ahora en la Página~2, escribe ``Tercero'', y vuelve a enviarlo al servidor. Llamaremos al resultado de este envío (la página que muestre el navegador al recibir la respuesta del servidor ``Página~3''.
\end{itemize}

Compara qué ves en Página~1, Página~2 y Página~3 en los dos casos (cuando lanzas cada uno de los dos servidores, y sigues el proceso con ellos). Trata de explicar lo que ocurre viendo en el navegador las cookies que envía el servidor en cada uno de los casos. A continuación, trata de explicarlo mirando el código de los dos servidores. Puedes utilizar la herramienta \verb|diff| para ver las diferencias en el código de ambos, si eso te ayuda.

Escribe como respuesta:

\begin{itemize}
\item Las diferencias que observes entre Página~1, Página~2 y Página~3 (descritas, acompañadas de capturas de pantalla si lo ves útil).
\item La explicación que hayas podido encontrar a las diferencias mirando las cookies en el navegador.
\item La explicación que hayas podido encontrar a las diferencias mirando el código de los dos servidores.  
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Servidores que recuerdan}
\label{subsec:servidores-recuerdan}

\textbf{Enunciado:}

En el directorio \verb|Python-Web/cookies| (en el repositorio de código de la asignatura) puedes encontrar los programas \verb|content-server-1.py| y \verb|content-server-2.py|. Ambos utilizan cookies de datos para ``recordar'' el último texto que se introdujo en el formulario que proporciona el servidor. El primero, utiliza GET para enviar al servidor el contenido del formulario, y el segundo utiliza POST.

Este ejercicio consiste en entender el código de ambos programas, y escribir otros dos, \verb|content-server-3.py| y \verb|content-server-4.py|, que hagan lo mismo, pero utilizando cookies de sesión (que identifican el navegador, y utilizan el identificador para buscar el último contenido del formulario en un diccionario que mantienen).

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Servicio horario}
\label{subsec:ej-servicio-horario}

\textbf{Enunciado:}

Queremos construir una aplicación web que cuando se consulta, devuelva la hora actual. Además, queremos que cuando se consulta por segunda vez, devuelva la hora actual y la hora en que se consultó por última vez. Explicar cómo se pueden usar cookies para conseguirlo.

\textbf{Enunciado avanzado:}

Igual que el anterior, pero se quiere que se muestre no sólo la hora en que se consultó por última vez, sino las horas de todas las consultas previas (además de la hora actual).

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Última búsqueda: números aleatorios o consecutivos}
\label{subsec:ultima-busqueda-aleconsec}

\textbf{Enunciado:}

En el ejercicio ``Última búsqueda'' (ejercicio~\ref{subsec:ultima-busqueda}) una de las soluciones pasa por usar cookies con identificadores de sesión. En principio, se han propuesto dos posibilidades para esos identificadores:

\begin{itemize}
\item Números enteros aleatorios sobre un espacio de números grande (por ejemplo entre 0 y $2^{128}-1$)
\item Números enteros consecutivos, comenzando por ejemplo por 0.
\end{itemize}

Comenta cuál de las dos soluciones te parece mejor, y si crees que alguna de ellas no sirve para resolver el problema. En ambos casos, indica las razones que te llevan a esa conclusión


%%------------------------------------------------------------------------------
%%------------------------------------------------------------------------------
\subsection{Cookies en tu navegador}
\label{subsec:cookies-navegador}

\textbf{Enunciado:}

Busca dónde tiene tu navegador accesible la lista de cookies que mantiene, y mírala. ¿Cuántas cookies tienes? ¿Qué sitio te ha puesto más cookies? ¿Cuál es la cookie más antigua que tienes? Explica también qué navegador usas (nombre y versión), desde cuándo más o menos, y cómo has podido ver las cookies en él.


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Cookies en tu navegador avanzado}
\label{subsec:cookies-navegador-2}

\textbf{Enunciado:}

Con el módulo adecuado, pueden editarse las cookies del navegador, lo que permite manejarlas con gran flexibilidad. Utiliza uno de estos módulos (por ejemplo, Cookie Quick Manager para Firefox) para manipular las cookies que tenga tu navegador. Utilízalo para ``traspasar'' una sesión de un navegador a otro. Por ejemplo, puedes buscar las cookies que te autentican con un servicio (el campus virtual, una red social en la que tengas cuenta, etc.), guardarlas en un fichero, transferirlas a otro ordenador con otro navegador, e instalarlas en él, para comprobar cómo puedes continuar con la sesión desde él.

\textbf{Referencias}

Cookie Quick Manager: \url{https://addons.mozilla.org/en-US/firefox/addon/cookie-quick-manager/}


%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Sumador simple con varios navegadores}
\label{subsec:sumador-simple-varios}

\textbf{Enunciado:}

Igual que el ejercicio ``Sumador simple'' (\ref{subsec:sumador-simple}), pero ahora puede haber varios navegadores invocando la aplicación web. Se supone que los navegadores no se interfieren (esto es, uno completa una suma antes de que otro la empiece).

\textbf{Comentario:}

No hacen falta modificaciones al código del ejercicio ``Sumador simple'' (\ref{subsec:sumador-simple}).


%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Sumador simple con varios navegadores intercalados}
\label{subsec:sumador-simple-varios-intercalados}

\textbf{Enunciado:}

Igual que``Sumador simple con varios navegadores'' (\ref{subsec:sumador-simple-varios}), pero ahora un navegador puede comenzar una suma en cualquier momento, incluyendo momentos en los que otro navegador no la haya terminado.

\textbf{Comentarios:}

En una primera versión, se implementa con una cookie simple que incluye el primer operando, de forma que el servidor de aplicaciones no tiene que almacenar los operandos ni las cookies.

En una segunda versión, se utiliza una cookie de sesión más clásica, con un entero aleatorio, y se almacena el estado en un diccionario indexado por ese entero.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Sumador simple con rearranques}
\label{subsec:sumador-simple-rearranques}

\textbf{Enunciado:}

Igual que el ejercicio ``Sumador simple con varios navegadores intercalados'' (\ref{subsec:sumador-simple-varios-intercalados}), pero ahora desde que el navegador inicia la suma hasta que la completa, puede haberse caído la aplicación web.

\textbf{Comentario:}

La aplicación web tendrá que  almacenar su estado en almacenamiento estable. Hay que detectar cuál es ese estado, y almacenarlo en  un fichero, en  una base de datos, etc.


%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Contador simple}
\label{subsec:contador-simple}

\textbf{Enunciado:}

Construir una aplicación web que funcione como contador inverso. Ofrecerá un recurso que, cuando sea invocado mediante un método GET, devolverá un número entero. La primera vez que se invoque, el número devuelto será un 5. Cuando se le invoque sucesivamente, el número obtenido se irá decrementando en uno (4, 3, 2...). Cuando se haya obtenido un 0, el siguiente número será de nuevo el 5 (esto es, el contador funciona como un contador inverso cíclico).

\textbf{Comentario:}

Es importante hacer énfasis en la solución en la estructura de la aplicación, tratando de estructurar el código de forma que las diferentes acciones que hará la aplicación web queden claras.

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{cURL básico}
\label{subsec:curl-basico}

\textbf{Enunciado:}

Prueba el ejercicio ``Contador simple'' (\ref{subsec:contador-simple}) con el programa \verb|curl|. Utilizalo para ver el documento que se recibe de tu servidor, para ver las cabeceras que te envía, para ver tanto cabeceras (de ida y vuelta) como cabeceras...

\textbf{Materiales:}

\begin{itemize}
\item \href{https://linuxacademy.com/guide/13852-understanding-curl-and-http-headers/}{Understanding CURL and HTTP Headers} (tutorial)
\item \href{https://curl.haxx.se/}{cURL} (sitio web)
\item \href{https://curl.haxx.se/book.html}{Everything curl} (libro)
\end{itemize}

\textbf{Solución:}

\begin{verbatim}
curl -XGET http://localhost:1234/
curl -XGET -I http://localhost:1234/
curl -XGET -Iv http://localhost:1234/
\end{verbatim}


%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Depurador básico}
\label{subsec:depurador-basico}

\textbf{Enunciado:}

Prueba el ejercicio ``Contador simple'' (\ref{subsec:contador-simple}) con el depurador de Python, por ejemplo, ejecutándolo desde PyCharm.


%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Contador simple con varios navegadores}
\label{subsec:contador-simple-varios}

\textbf{Enunciado:}

Igual que el ejercicio ``Contador simple'' (\ref{subsec:contador-simple}), pero ahora puede haber varios navegadores invocando la aplicación web. Se supone que los navegadores no se interfieren (esto es, uno completa todas sus operaciones con el contador antes de que otro la empiece).

\textbf{Comentario:}

No hacen falta modificaciones al código del ejercicio ``Contador simple'' (\ref{subsec:contador-simple}), si se asume que cuando se invoque el contador, éste puede empezar por cualquier número de su ciclo. Si por el contrario se quiere que comience como ``la primera vez'' (por 5) es preciso detectar que se está sirviendo a un nuevo navegador, y habrá que prever algún mecanismo al respecto.

Puede consultarse la implementación de referencia disponible en
\href{https://github.com/CursosWeb/Code/blob/master/Python-Web/counter/counter-server-1.py}{counter-server-1.py}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Contador simple con varios navegadores intercalados}
\label{subsec:contador-simple-varios-intercalados}

\textbf{Enunciado:}

Igual que ``Contador simple con varios navegadores'' (\ref{subsec:contador-simple-varios}), pero ahora un navegador puede comenzar a trabajar con el contador en cualquier momento, incluyendo momentos en los que otro navegador no haya terminado aún.

\textbf{Comentarios:}

En una primera versión, se implementa con una cookie simple que incluye el número que ha servido el contador de forma que la aplicación no tiene que almacenar el valor del contador para cada navegador.

En una segunda versión, se utiliza una cookie de sesión más clásica, con un entero aleatorio, y se almacena el estado del contador correspondiente en un diccionario indexado por ese entero.

En una tercera versión, se podría añadir una operación para crear un contador único para cada navegador, con un nombre de recurso propio. Cada navegador conocería su recurso, y sólo utilizaría ese. Se puede evitar que un navegador utilice un recurso que no le corresponde haciendo que su nombre no sea fácilmente descubrible.

Puede consultarse la implementación de referencia disponible en
\href{https://github.com/CursosWeb/Code/blob/master/Python-Web/counter/counter-server-2.py}{counter-server-2.py}

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Contador simple con rearranques}
\label{subsec:contador-simple-rearranques}

\textbf{Enunciado:}

Igual que el ejercicio ``Contador simple con varios navegadores intercalados'' (\ref{subsec:contador-simple-varios-intercalados}), pero ahora desde que el navegador inicia el trabajo con el contador hasta que la completa, puede haberse caído la aplicación web.

\textbf{Comentario:}

La aplicación web tendrá que  almacenar su estado en almacenamiento estable. Hay que detectar cuál es ese estado, y almacenarlo en  un fichero, en  una base de datos, etc.

Puede consultarse la implementación de referencia disponible en
\href{https://github.com/CursosWeb/Code/blob/master/Python-Web/counter/counter-server-3.py}{counter-server-3.py} y
\href{https://github.com/CursosWeb/Code/blob/master/Python-Web/counter/counter-server-4.py}{counter-server-4.py}.


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Traza de historiales de navegación por terceras partes}
\label{subsec:navegacion-terceras-partes}

Cuando un navegador realiza un GET sobre una página web HTML lanza a continuación, de forma automática, otras operaciones GET sobre los elementos cargables automáticamente que contenga esa página, como por ejemplo, las imágenes empotradas. Cada vez que se realiza uno de estos GET, se pueden recibir una o más cookies de los servidores que las sirven (y que en general pueden ser diferentes del que sirve la página HTML).

De esta forma, sirviendo imágenes para diferentes páginas HTML en diferentes sitios, una tercera parte puede trazar historiales de navegación, ligándolos a identificadores únicos. ¿Cómo?

Además, si la tercera parte en cuestión tiene acceso a información de un sitio web que permita identificar identidades, esos historiales pueden también ser ligados a identidades. ¿Cómo?

\textbf{Comentarios:}

La liga con identificadores únicos se puede lograr de varias formas, Por ejemplo se puede incluir en cada página HTML a trazar una imagen con nombre único, todas servidas por la tercera parte. La primera vez que sirve una imagen a un navegador dado, le envía también una cookie con identificador único. Todas las peticiones de imagen que se reciban serán escritas en un historial, junto con el identificador único de la cookie.

Para poder ligar este historial a una identidad, basta con que, en un servidor que ha identificado una identidad, sirva una imagen de la tercera parte con un nombre que permita posteriormente ligarlo a la identidad.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Trackers en páginas web}
\label{subsec:trackers-paginas-web}

Instala el \emph{plug-in} Lightbeam para tu navegador. Este \emph{plug-in} permite detectar todos los sitios web que se acceden al descargar una página, incluyendo los forzados por ``trackers'' (objetos incluidos en una página web para trazar a quienes descargan esa página). Utilízalo para encontrar páginas web con muchos trackers. Una vez lo hayas hecho, indica las dos páginas (de sitios distintos) en las que hayas encontrado más trackers.

\textbf{Referencias}

Sitio web de Lightbeam: \url{https://www.mozilla.org/lightbeam/}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Trackers en páginas web (Ghostery)}
\label{subsec:trackers-paginas-web-2}

Instala el \emph{plug-in} Ghostery para tu navegador. Este \emph{plug-in} permite detectar ``trackers'', objetos incluidos en una página web para trazar a quienes descargan esa página. Utilízalo para encontrar páginas web con muchos trackers. Una vez lo hayas hecho, indica las dos páginas (de sitios distintos) en las que hayas encontrado más trackers.

\textbf{Referencias}

Sitio web de Ghostery: \url{http://www.ghostery.com/}

%%-----------------------------------------------------------------------------
\subsection{Transplante de cookies}
\label{subsec:transplante-cookies}

En el ejercicio ``Explora tus cookies (2)'' (ejercicio~\ref{subsec:explora-cookies-2}) hemos explorado cómo se comportan las cookies con dos aplicaciones web simples. En este ejercicio se te pide que elijas una cualquiera de estas dos aplicaciones, y pruebes a transplantar las cookies que tenga un navegador después de haberla usado, a otro navegador diferente. Por ejemplo, puedes transplantarlas de Chrome a Firefox, o de un navegador que tengas en tu ordenador a un Firefox en un ordenador del laboratorio. Para responder al ejercicio, explica cómo has hecho para transplantar las cookies, y qué has observado al acceder a la aplicación desde el navegador al que las has transplantado.


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 02: Servicios web que interoperan}


%%-----------------------------------------------------------------------------
\subsection{Arquitectura escalable}
\label{subsec:arq-escalable}

\textbf{Enunciado:}

Diseñar una arquitectura para una aplicación distribuida que cumpla las siguientes condiciones:

\begin{itemize}
\item Puede ser usada por millones de usuarios simultáneamente.
\item Hay miles de equipos de desarrollo trabajando sobre ella. Entre los equipos hay poca comunicación pero no deben tener conflictos entre sí.
\item Cada uno de los equipos podrían extender lo que habían hecho los otros sin que estos lo sepan y sin que la evolución de cada sistema rompiera la integración.
\end{itemize}

\textbf{Comentarios:}

Desde luego, hay otros sistemas, pero el web, entendido en sentido amplio, es uno que cumple bien estos requisitos.


%%-----------------------------------------------------------------------------
\subsection{Arquitectura distribuida}
\label{subsec:arq-distribuida}

\textbf{Enunciado:}

Diseñar una arquitectura para una aplicación distribuida que cumpla las siguientes condiciones:

\begin{itemize}
\item Pueda gestionar elementos en mi casa desde remoto, en particular, mi comida. Por tanto, tendrá que gestionar los alimentos que se encuentran en la nevera, la despensa, el bol de frutas, etc.
\item Pueda interactuar tanto con máquinas como con humanos
\item Sea lo más sencilla posible
\item Sea escalable
\end{itemize}

En particular, usando REST, define algunos recursos, y las operaciones que se podrían hacer sobre ellos. Explica también qué necesitaría para poder interoperar con los recursos correspondientes, por ejemplo, a la casa de tus amigos.

\textbf{Comentarios:}

Desde luego, hay muchas maneras de hacerlo y eso favorecerá el debate.

Una primera idea es modelar los elementos como objetos (la nevera, los alimentos, etc.) y hacerlo llegar de alguna manera al otro lado de la red, donde está mi portátil (esta es una solución que siguen muchos web services, o incluso CORBA). Hay que entender que esto hará que en el lado del portátil tengamos que conocer cómo funcionan los elementos (sus atributos y sus métodos). Es como tener que aprender el manual de instrucciones (los verbos) para cada cacharro que tengamos en la cocina.

Al ver esta solución, nos damos cuenta de que contamos en el otro lado con sustantivos. Éstos tienen una localización única, que especificamos mediante una URL. Asimismo, existe la URN, que permite especificar unívocamente un elemento según su nombre, pero se ha de tener en cuenta de que puede haber un URN para muchos elementos (es como el ISBN, que hay uno para toda la edición, o sea para muchos libros). Dado la URL localizamos un URN de manera unívoca.

Mientas, en el otro lado (en el cliente) tendremos un número mínimo de acciones (los verbos). Vemos el primero: GET. Éste no obtiene el sustantivo, sino una representación del mismo. Los sustantivos son recursos. Y estos recursos pueden venir expresados de varias maneras. Así, por ejemplo, si pedimos manzanas desde un portátil la representación podría ser una imagen muy detallada; para el móvil, la imagen será más pequeña; y si el que lo pide es una máquina, podría ser un XML. Vemos los demás métodos: PUT, POST y DELETE.

Vistos los métodos discutimos si cambian el estado (vemos que sólo GET no lo hace) y si el resultado de realizar varios consecutivos es igual a hacerlo una vez (lo que llamamos idempotencia, vemos que sólo POST no lo es).

Introducimos el concepto de elemento y colección de elementos (cuando pedimos una colección, nos da un listado de los elementos que contiene; este listado contiene enlaces a los mismos) y qué pasa cuando aplicamos un método a cada uno. Hacemos especial hincapié en la diferencia entre PUT y POST.

Introducimos el concepto de REST y sus reglas. Hay varias las hemos visto ya: URLs, enlaces, representaciones y métodos. Nos falta por ver que las comunicaciones son sin estado. Los recursos pueden tenerlo, pero no la comunicación. Discutimos qué significa esto con respecto a lo que hemos visto en la asignatura hasta ahora, en particular con respecto a las sesiones (y las cookies).

Finalmente discutimos porque la web no es así, si en realidad los diseñadores de HTTP habían diseñado el protocolo para que todo fuera REST. Comentamos que con los navegadores sólo podemos hacer GETs y POSTs (y contamos que podemos utilizar los demás métodos mediante plug-ins como Poster (ver ejercicio~\ref{subsec:inst-poster}). Mostramos que, más allá de los navegadores, ya estamos en disposición de crear programas para interactuar con servidores REST, de manera que podemos comunicar máquinas entre sí siguiendo estas reglas. Discutimos las ventajas de este enfoque en esos casos.


%%-----------------------------------------------------------------------------
\subsection{Lista de la compra}
\label{subsec:lista-compra}

\textbf{Enunciado:}

Vamos a diseñar una API HTTP para un servicio que permite guardar una lista de la compra. Supongamos que esta lista está compuesta únicamente por los items que quiero comprar en un momento dado (zanahorias, yogures, etc.) y un número natural para cada item que tengo, que expresa la cantidad que quiero comprar. Por ejemplo, en un momento dado, la lista podría ser:

\begin{itemize}
\item Zanahorias: 5
\item Yogures: 4
\item Leche: 2
\end{itemize}

Puede haber items en la lista de la compra con valor 0, si se encuentra que es útil por algún motivo.

Las operaciones que permitirá la API del servicio son: consultar la lista, añadir un item (con su correspondiente cantidad) a la lista, modificar la cantidad de un item en la lista, y borrar un item de la lista.

Se pide diseñar una API HTTP para esta aplicación (servicio) web, identificando cuáles son los recursos relevantes, las operaciones HTTP válidas sobre ellas, y describiendo la semántica de cada una de ellas.

Podemos imaginar que el servicio web va a ser usado, por ejemplo, desde una aplicación en el móvil, que podrá hacer GET, PUT, POST y DELETE (usando HTTP). Cada vez que quiero apuntar o borrar algo de la lista de la compra, o quiero consultar la lista, utilizo la app del móvil para acceder, mediante HTTP, al servicio de lista de la compra.

%%-----------------------------------------------------------------------------
\subsection{Listado de lo que tengo en la nevera}
\label{subsec:contenido-nevera}

\textbf{Enunciado:}

Este es un ejercicio muy similar a ``Lista de la compra'' (\ref{subsec:lista-compra}). Vamos a diseñar una API REST para una aplicación que concreta el ejercicio ``Arquitectura distribuida'' (\ref{subsec:arq-distribuida}) en un caso bien simple: una aplicación web que mantenga la lista de lo que tengo en la nevera. El tipo de lista será el mismo que se indica para en el ejercicio de la lista de la compra, pero ahora trataremos de que la API cumpla los principios REST.

\textbf{Comentarios:}

Hay muchas soluciones posibles para este problema, que sobre todo pretende que se reflexione sobre las características que hacen de una interfaz HTTP una interfaz REST. Pero en cualquier caso, como mínimo hay que definir cuáles serán los recursos (y sus nombres), las operaciones sobre cada uno de ellos, y un breve comentario sobre su funcionamiento.

Una posible solución sería: \\

\begin{tabular}{l|l|p{10cm}}
  Recurso & Método & Descripción \\ \hline \hline
  /       & GET    & Lista de items en la nevera (enlaces a recursos) \\
          & POST   & Crea un nuevo item, \verb|item=xx&cantidad=yy| \\
  /[item] & GET    & Obten el valor (número) del alimento ``item'' \\
          & PUT    & Actualiza el valor del alimento ``item'' \\
          & DELETE & Borra el item (elimina el recurso) \\
\end{tabular}

Esta interfaz HTTP podría usarse desde la aplicación como se ve en los siguiente ejemplos.

La primera vez que se introducen zanahorias (supongamos que se introducen 5):

\begin{itemize}
\item Petición (para ver si hay zanahorias):
\begin{verbatim}
GET / HTTP/1.1
\end{verbatim}

\item Respuesta:
\begin{verbatim}
HTTP/1.1 200 OK

<a href="/leche"></a>
<a href="/chorizo"></a>
\end{verbatim}

\item Petición (para crear el recurso para las zanahorias):
\begin{verbatim}
POST / HTTP/1.1

item=zanahorias&cantidad=5
\end{verbatim}

\item Respuesta:
\begin{verbatim}
HTTP/1.1 200 OK

<a href="/chorizo"></a>
\end{verbatim}

\end{itemize}

Si sacamos 3 zanahorias:

\begin{itemize}
\item Petición (para ver cuántas zanahorias hay):
\begin{verbatim}
GET /zanahorias HTTP/1.1
\end{verbatim}

\item Respuesta:
\begin{verbatim}
HTTP/1.1 200 OK

5
\end{verbatim}

\item Petición (para actualizar al nuevo número de zanahorias):
\begin{verbatim}
PUT /zanahorias HTTP/1.1

2
\end{verbatim}

\item Respuesta:
\begin{verbatim}
HTTP/1.1 200 OK

2
\end{verbatim}

\end{itemize}

Si sacamos otras 2 zanahorias:

\begin{itemize}
\item Petición (para ver cuántas zanahorias hay):
\begin{verbatim}
GET /zanahorias HTTP/1.1
\end{verbatim}

\item Respuesta:
\begin{verbatim}
HTTP/1.1 200 OK

2
\end{verbatim}

\item Petición (para eliminar el recurso, porque quedaría a cero):
\begin{verbatim}
DELETE /zanahorias HTTP/1.1
\end{verbatim}

\item Respuesta:
\begin{verbatim}
HTTP/1.1 200 OK
\end{verbatim}

\end{itemize}



%%-----------------------------------------------------------------------------
\subsection{Sumador simple versión REST}
\label{subsec:sumador-simple-rest}

\textbf{Enunciado:}

Desarrollar una versión RESTful de ``Sumador simple'' (ejercicio~\ref{subsec:sumador-simple}). ¿Plantea problemas si se usa simultáneamente desde varios navegadores? ¿Plantea problemas si se cae el servidor entre dos invocaciones por parte del mismo navegador?

\textbf{Comentarios:}

Hay varias formas de hacer el diseño, pero por ejemplo, cada sumando podría ser un recurso, y el resultado obtenerse en un tercero (o bien como respuesta al actualizar el segundo sumando). Cada suma podría también realizarse en un espacio de nombres de recurso distinto (con su propio primer sumando, segundo sumando y resultado).


%%-----------------------------------------------------------------------------
\subsection{Calculadora simple versión REST}
\label{subsec:calc-simple-rest}

\textbf{Enunciado:}

Realizar una calculadora de las cuatro operaciones aritméticas básicas (suma, resta, multiplicación y división), siguiendo los principios REST, a la manera del sumador simple versión REST (ejercicio~\ref{subsec:sumador-simple-rest}).

\textbf{Comentarios:}

Este ejercicio, más que para proponer una solución concreta, está diseñado para debatir sobre las posibles soluciones que se le podrían dar. Por ejemplo, tenemos primero la versiones donde se supone un único usuario:

\begin{itemize}
\item Versión con un recurso por tipo de operación (``/suma'', ``resta'', etc.). Se actualiza con PUT, que envía los operandos (ej: 4,5), se consulta con GET, que devuelve el resultado (ej: 4+5=9).
\item Versión con un único recurso, ``/operacion''. Se actualiza con PUT, que envía en el cuerpo la operación (ej: 4+5), se consulta con GET, que devuelve el resultado (ej: 4+5=7).
\item Versión actualizando por separado los elementos de la operación, con un único recurso ``/operacion''. PUT podrá llevar en el cuerpo ``Primero: 4'' o ``Segundo: 5'', o ``Op: +''. Cada uno de ellos actualiza el elemento correspondiente de la operación. GET de ese recurso, devuelve el resultado de la operación con los elementos que tiene en este momento.
\item Versión actualizando por separado los elementos de la operación, con un único recurso ``/operación''. PUT podrá llevar en el cuerpo un número si es la primera o segunda vez que se invoca, un símbolo de operación si es la tercera. GET dará el resultado si se han especificado todos los elementos de la operación, error si no. Es ``menos REST'', en el sentido que guarda más estado en el lado del servidor. Pero cumple los requisitos generales de REST si consideramos que le cliente es responsable de mantener su estado y saber en qué fase de la operación está en cada momento.
\item Versión donde cada elemento se envía con un PUT a un recurso (``/operacion/primeroperando'', ``/operacion/segundooperando'', ``/operacion/signo''), y el resultado se obtiene con ``GET /operacion/resultado''. No es REST, porque el estado del recurso ``/operacion/resultado'' depende del estado de los otros recursos
.
\end{itemize}

También podemos extender el diseño a versiones con varios usuarios:

\begin{itemize}
\item Podría tenerse un identificador para cada operación. ``POST /operaciones'' podría devolver el enlace a una nueva operación creada, como ``/operaciones/2af434ad3''. Cada una de estas sumas se comportaría como las ``sumas con un usuario'' que se han comentado antes. ``DELETE  /operaciones/2af434ad3'' destruiría una operación.
\end{itemize}

\textbf{Material:}

\begin{itemize}
\item \texttt{simplecalc.py}: Programa con una posible solución a este ejercicio. Proporciona cuatro recursos ``calculadora'', uno para cada operación matemática (suma, resta, multiplicación, división). Cada calculadora mantiene un estado (operación matemática) que se actualiza con PUT y se consulta con GET.
\item Vídeo que muestra el funcionamiento de \texttt{simplecalc.py} \\
  \url{http://vimeo.com/31427714}
\item Vídeo que describe el programa \texttt{simplecalc.py} \\
  \url{http://vimeo.com/31430208}
\item \texttt{multicalc.py}: Programa con otra posible solución a este ejercicio. Proporciona un recurso para crear calculadoras (mediante POST). Al crear una calculadora se especifica de qué tipo (operación) es. Cada calculadora mantiene un estado (operación matemática) que se actualiza con PUT y se consulta con GET. Se apoya en las clases definidas en \texttt{simplecalc.py} para implementar las calculadoras.
\item \texttt{webappmulti.py}: Clase que proporciona la estructura básica para los dos programas anteriores (clase raíz de servicio web, de \emph{aplis}, etc.)
\end{itemize}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Cache de contenidos}
\label{subsec:cache-contenidos}

\textbf{Enunciado:}

Vamos a construir una aplicación web que no sólo recibe peticiones de un cliente, sino que también hace peticiones a otros servicios web. El ejercicio consiste en construir una aplicación que, dada una URL (sin ``http://'') como nombre de recurso, devuelve el contenido de la página correspondiente a esa URL. Esto es, si se le pide http://localhost:1234/gsyc.es/ devuelve el contenido de la página http://gsyc.es/. Además, lo guarda en un diccionario, de forma que si se le vuelve a pedir, lo devuelve directamente de ese diccionario.

%Puede usarse como base ``Django cms'' (ejercicio~\ref{subsec:django-cms}), y si se quiere, el módulo estándar de Python ``urllib''.
Puede usarse como base ContentApp, y si se quiere, el módulo estándar de Python urllib.

\textbf{Comentarios:}

Pueden discutirse muchos detalles de esta aplicación. Por ejemplo, cómo gestionar las cabeceras, y en particular las cookies. También, cómo saber si la página ha cambiado en el sitio original antes de decidir volver a bajarla (cabeceras relacionadas con ``cacheable'', peticiones ``HEAD'' para ver fechas, etc.)

Para la implementación de la aplicación sólo se pide lo más básico: no hay tratamiento de cabeceras, y no se vuelve a bajar el original una vez está en la cache.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Cache de contenidos versión Django}
\label{subsec:cache-contenidos-django}

\textbf{Enunciado:}

Construir una aplicación que implemente una cache de contenidos, como la descrita en el ejercicio~\ref{subsec:cache-contenidos}, pero sobre Django.
Puede usarse como base ``Django cms'' (ejercicio~\ref{subsec:django-cms}), y si se quiere, el módulo estándar de Python ``urllib''.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Cache de contenidos anotado}
\label{subsec:cache-contenidos-anotado}

\textbf{Enunciado:}

Construir una aplicación como ``Cache de contenidos'' (ejercicio~\ref{subsec:cache-contenidos}), pero que anote cada página, en la primera línea, con un enlace a la página original, y que incluya también un enlace para ``recargar'' la página (volverla a refrescar a partir del original), otro enlace para ver el HTTP (de ida y de vuelta, si fuera posible) que se intercambió para conseguir la página original, y otro enlace para ver el HTTP de la consulta del navegador y de la respuesta del servidor al pedir esta página (de nuevo si fuera posible).

\textbf{Comentarios:}

Téngase en cuenta que por lo tanto cada página que sirva la aplicación, además de los contenidos  HTML correspondientes (obtenidos de la cache o directamente de Internet) tendrá cuatro enlaces en la primera línea:

\begin{itemize}
\item Enlace a la página original.
\item Enlace a un recurso de la aplicación que permita recargar.
\item Enlace a un recurso de la aplicación que permita ver el HTTP que se intercambió con el servidor que tenía la página.
\item Enlace a un recurso de la aplicación que permita ver el HTTP que se intercambió cuando se cargó en cache esa página.
\end{itemize}

Estos enlaces conviene introducirlos en el cuerpo de la página HTML que se va a servir. Así, por ejemplo, si la página que se bajó de Internet es como sigue:

\begin{verbatim}
<html>
  <head> ... </head>
  <body>
    Text of the page
  </body>
</html>
\end{verbatim}

Debería servirse anotada como sigue:

\begin{verbatim}
<html>
  <head> ... </head>
  <body>
    <a href="original_url">Original webpage</a>
    <a href="/recurso1">Reload</a>
    <a href="/recurso2">Server-side HTTP</a>
    <a href="/recurso3">Client-side HTTP</a></br>
    Text of the page
  </body>
</html>
\end{verbatim}

Para poder hacer esto, es necesario localizar el elemento $<body>$ en la página HTML que se está anotando. Hay que tener en cuenta que este elemento puede venir tal cual o con atributos, por ejemplo:

\begin{verbatim}
<body class="all" id="main">
\end{verbatim}

Por eso no basta con identificar dónde está la cadena ``$<body>$'' en la página, sino que habrá que identificar primero dónde está ``$<body$'' y, a partir de ahí, el cierre del elemento, ``$>$''. Será justo después de ese punto donde deberán colocarse las anotaciones. Para encontrar este punto puede usarse el método \texttt{find} de las variables de tipo \emph{string}, o expresiones regulares.

Para que los enlaces que se enlazan desde estas anotaciones funcionen, la aplicación tendrá que atender a tres nuevos recursos para cada página:

\begin{itemize}
\item /recurso1: Recarga de la página en la cache.
\item /recurso2: Devuelve el HTTP con el servidor (que tendrá que estar previamente almacenado en, por ejemplo, un diccionario).
\item /recurso3: Devuelve el HTTP con el navegador (que tendrá que estar previamente almacenado en, por ejemplo, un diccionario).
\end{itemize}

Naturalmente, cada página necesitará estos tres recursos, por lo tanto lo mejor será diseñar tres espacios de nombres donde estén los recursos correspondientes para cada una de las páginas. Por ejemplo, todos los recursos de recarga podrían comenzar por ``/reload/'', de forma que ``/reload/gsyc.es'' sería el recurso para recargar la página ``http://gsyc.es''.

Para poder almacenar el HTTP con el servidor, es importante darse cuenta de que el que se envía al servidor lo produce la propia aplicación. Si se usa \texttt{urllib}, no es posible acceder directamente a lo que se está enviando, pero se puede inferir a partir de lo que se indica a \texttt{urllib}. Por lo tanto, cualquier petición HTTP ``razonable'' para los parámetros dados será suficiente, aunque no sea exactamente lo que envíe \texttt{urllib}.

El HTTP que se recibe del servidor habrá que obtenerlo usando \texttt{urllib}, en la medida de lo posible.

Para poder almacenar el HTTP con el cliente, es importante darse cuenta de que el que se envía al navegador lo produce la propia aplicación, por lo que basta con almacenarlo antes de enviarlo. El que se recibe del navegador habrá que obtenerlo de la petición recibida.

%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos miltilingüe versión REST}
\label{subsec:contentappmulti}

\textbf{Enunciado:}

Diseño y construcción de ``Gestor de contenidos miltilingüe versión REST''. Retomamos la aplicación ContentApp, pero ahora vamos a proporcionarle una interfaz multilingüe simple. Para empezar, trabajaremos con español (``es'') e inglés (``en''). Siguiendo la filosofía REST, cada recurso lo vamos a tener ahora disponible en dos URLs distintas, según en qué idioma esté. Los recursos en español empezarán por ``/es/'', y los recursos en inglés por ``/en/''. Además, si a un recurso no se le especifica de esta forma en qué idioma está, se servirá en el idioma por defecto (si está disponible), o en el otro idioma (si no está en el idioma por defecto, pero sí en el otro). Como siempre, los recursos que no estén disponibles en ningún idioma producirán un error ``Resource not available''.

\textbf{Comentarios:}

Para construir esta aplicación puedes usar dos diccionarios de contenidos (uno para cada idioma), o quizás mejor un diccionario de diccionarios, donde para cada recurso tengas como dato un diccionario con los idiomas en que está disponible, que tienen a su vez como dato la página HTML a servir.


%%-----------------------------------------------------------------------------
\subsection{Sistema de transferencias bancarias}
\label{subsec:transferencias-bancarias}

\textbf{Enunciado:}

Diseñar un sistema RESTful sobre HTTP fiable para realizar una transferencia bancaria vía HTTP.

\begin{itemize}
\item Debe poder confirmarse que la transferencia ha sido realizada.
\item Debe poder prevenirse que la transferencia se haga más de una vez.
\item Datos de la transferencia: cuenta origen, cuenta destino, cantidad.
\item También debe poder consultarse el saldo de la cuenta (datos: cuenta)
\item En un segundo escenario, puede suponerse todo lo anterior, pero considerando que hay una contraseña que protege el acceso a operaciones sobre una cuenta data (una contraseña por cuenta), tanto transferencias como consultas de saldo
.
\end{itemize}

Indica el esquema de recursos (URLs) que ofrecerá la aplicación, y los verbos (comandos) HTTP que aceptará para cada uno, y con qué semántica.

%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos multilingüe preferencias del navegador}
\label{subsec:contentappmulti-navegador}

\textbf{Enunciado:}

Diseñar y construir la aplicación web ``Gestor de contenidos multilingüe preferencias del navegador''. En la aplicación ``Gestor de contenidos multilingüe versión REST'' (ejercicio~\ref{subsec:contentappmulti}) se especificaban como parte del nombre e recurso el idioma en que se quiere recibir un recurso. Pero el navegador tiene habitualmente una forma de especificar en qué idioma quieres recibir las páginas cuando están disponibles en varios. Para ver cómo funciona esto, prueba a cambiar tus preferencias idiomáticas en Firefox, y consulta la página \url{http://debian.org}.

Implementa una aplicación web que sea como la anterior, pero que además, haga caso de las preferencias del navegador con que la invoca, al menos para el caso de los idiomas ``es'' y ``en''.

\textbf{Material complementario:}
\begin{itemize}
\item Descripción de ``Accept-Language'' en la especificación de HTTP (RFC 2616) \\
  \url{http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4}
\end{itemize}

\textbf{Comentario:}

¿Qué recibe el servidor para poder hacer la selección de idioma? Utiliza una de tus aplicaciones para ver lo que le llega al servidor. Verás que lo que utiliza el navegador para indicar las preferencias idiomáticas del usuario es la cabecera ``Accept-Language''

%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos multilingüe con elección en la aplicación}
\label{subsec:contentappmulti-apli}

\textbf{Enunciado:}

Diseñar y construir la aplicación web ``Gestor de contenidos multilingüe con elección en la aplicación''. Ahora vamos a construir un servidor de contenidos multilingüe que además de los dos mecanismos anteriores (interfaz REST y preferencias del navegador, ejercicios~\ref{subsec:contentappmulti} y~\ref{subsec:contentappmulti-navegador}) permita que el usuario elija el idioma específicamente en la propia aplicación.

Para ello, el gestor de contenidos atenderá a peticiones GET sobre recursos de la forma ``/language/es'' (para indicar que se quieren recibir las páginas en español), ``/language/en'' (para indicar que se quieren recibir las páginas en inglés) o ``language/browser'' (para indicar que se quieren recibir las páginas en el idioma que indique las preferencias del navegador).

El mecanismo de especificación de idioma mediante nombre de recurso (``/en'' o /es'') tendrá precedencia sobre el mecanismo de especificación en la aplicación, y éste sobre el de preferencias del navegador.

Cada página incluirá, además del contenido en el idioma especificado, una lista (con enlaces) de los idiomas en que está disponible esa página, y una lista (con enlaces) de los idiomas que se pueden elegir en la aplicación. Por ejemplo, si estamos consultando una página en español que está disponible también en inglés, veremos un enlace ``This page in English'' que apuntará a la URL REST de esa página en inglés. Además, habrá enlaces a ``Ver páginas preferentemente en español'' (que apuntará al recurso /language/es), ``See pages preferently in English'' (que apuntará al recurso /language/en) y ``Ver páginas según preferencias del navegador'' (que apuntará a /language/browser).

\textbf{Comentario:}

Para implementar la elección especificándolo en la propia aplicación se podrán usar cookies, aunque no haya sistema de cuentas en la aplicación, como es el caso.

%%-----------------------------------------------------------------------------
\subsection{Sistema REST para calcular Pi}
\label{subsec:rest-pi}

\textbf{Enunciado:}

Diseñar un sistema RESTful sobre HTTP que permita calcular el número pi como una operación asíncrona.

\begin{itemize}
\item El usuario solicita el comienzo del cálculo indicando el número de decimales deseado
\item El usuario debe poder consultar a partir de ese momento el estado del cálculo
\end{itemize}

Indica el esquema de recursos (URLs) que ofrecerá la aplicación, y los verbos (comandos) HTTP que aceptará para cada uno, y con qué semántica.

Háganse dos versiones: en la primera, se supone que hay un sólo usuario (navegador) del sistema. En la segunda, puede haber varios, pero no simultáneamente: si un usuario solicita el comienzo del cálculo mientras hay otro cálculo en curso, le devuelve un mensaje de error.

\textbf{Comentario:}

Quien esté interesado puede realizar una implementación de una aplicación web para este diseño. Puede usar, por ejemplo, el método Monte Carlo, aplicando incrementalmente números cada vez más altos de números aleatorios.

\textbf{Materiales:}

Explicación del cálculo de Pi mediante el método Monte Carlo, incluyendo ejemplo en Python: \\
\url{http://www.eveandersson.com/pi/monte-carlo-circle}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 03: Introducción a XML}

Ejercicios sobre XML, JSON, y HTML (reconocedores, generadores, etc).

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Chistes XML}
\label{subsec:xml-chistes}

\textbf{Enunciado:}

Estudia y modifica el programa xml-parser-jokes.py (que funciona con el fichero jokes.xml), hasta que entiendas los rudimentos del manejo de reconocedores SAX con Python.

\textbf{Material:}

\begin{itemize}
  \item jokes.xml. Fichero XML con descripciones de chistes.
  \item xml-parser-jokes.py. Programa que lee el fichero anterior, y usando un parser SAX lo reconoce y muestra en pantalla el contenido de los chistes.
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Modificación del contenido de una página HTML}
\label{subsec:xml-modificacion-html}

\textbf{Enunciado:}

Estudia y modifica el documento HTML dom.html, de forma que:

\begin{itemize}
\item Al pulsar con el ratón sobre un texto, se recargue la página (invocando para ello una función JavaScript). Este texto ha de estar disponible para poder pulsar sobre él una vez la página haya cambiado de contenido.
\item Al pulsar con el ratón sobre un botón, se modificará alguna parte del contenido mostrando la hora y fecha del momento.
\end{itemize}

\textbf{Material:}

\begin{itemize}
  \item dom.html. Documento HTML, que incluye algo de código JavaScript, y que hay que modificar.
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Titulares de BarraPunto}
\label{subsec:xml-barrapunto}

\textbf{Enunciado:}

Descargar el fichero RSS de BarraPunto\footnote{\url{http://barrapunto.com}}, y construir un programa que produzca como salida sus titulares en una página HTML. Si se carga esa página en un navegador,  picando sobre un titular, el navegador deberá cargar la página de BarraPunto con la noticia correspondiente. Como base puede usarse lo aprendido estudiando los programas xml-parser-jokes.py y xml-parser-barrapunto.py.

\textbf{Material:}

\begin{itemize}
\item \url{http://barrapunto.com/index.rss}: URL del fichero RSS de BarraPunto.
\item xml-parser-barrapunto.py: Programa que muestre en pantalla los titulares y las URLs que se describen en el fichero barrapunto.rss.
\item barrapunto.rss: Fichero con el contenido del canal RSS de BarraPunto en un momento dado.
\end{itemize}

Repositorio de entrega en GitLab: \\
\url{https://gitlab.etsit.urjc.es/cursosweb/practicas/server/xml-barrapunto}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Videos en canal de YouTube}
\label{subsec:xml-youtube}

\textbf{Enunciado:}

Descargar el fichero RSS con los videos del canal CursosWeb de Youtube\footnote{\url{https://www.youtube.com/channel/UC300utwSVAYOoRLEqmsprfg}}, y construir un programa que produzca como salida sus títulos en una página HTML. Si se carga esa página en un navegador,  picando sobre un titular, el navegador deberá cargar la página de Youtube con el video correspondiente. Como base puede usarse lo aprendido estudiando el programa \verb|xml-parser-jokes.py|.

\textbf{Ejemplo de ejecución:}

Al ser ejecutado el programa, producirá la página HTML descrita anteriormente. Por lo tanto, podemos redirigir la salida estándar el programa a un fichero, que podrá ser visualizado mediante un navegador:

\begin{verbatim}
programa > pagina.html
\end{verbatim}

\textbf{Material:}

\begin{itemize}
\item ytparser.py: Programa que muestre en pantalla los nombres y los enlaces de los videos de un fichero con el documento XML de un canal de YouTube, en formato HTML.
\item youtube.xml: Fichero con un documento XML que describe un canal de YouTube, que se puede usar con el programa \verb|ytparser.py|.
\item \url{https://www.youtube.com/feeds/videos.xml?channel_id=UC300utwSVAYOoRLEqmsprfg}: URL del documento XML del canal CursosWeb de Youtube. El fichero anterior se generó descargando este documento. Si quieres, puedes descargarlo y probar tu programa también con él, debería funcionar igual que con \verb|youtube.xml|.
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Videos en canal de YouTube (con descarga)}
\label{subsec:xml-youtube-descarga}

\textbf{Enunciado:}

Realizar un programa con la funcionalidad descrita en ``Videos en canal de Youtube'' (ejercicio~\ref{subsec:xml-youtube}), pero realizanda la descarga del canal desde YouTube. El programa admitirá un único argumento, que será un identificador de canal de YouTube, y producirá como salida estándar la página HTML que producía el ejercicio mencionado anteriormente.

\textbf{Ejemplo de ejecución:}

Al ser ejecutado el programa, producirá la página HTML descrita anteriormente. Por lo tanto, podemos redirigir la salida estándar el programa a un fichero, que podrá ser visualizado mediante un navegador:

\begin{verbatim}
programa UC300utwSVAYOoRLEqmsprfg > pagina.html
\end{verbatim}

\textbf{Material:}

\begin{itemize}
\item Módulo urllib de Python: \\
  \url{https://docs.python.org/3/library/urllib.html}
\item Tutorial sobre urllib de Python: \\
  \url{https://pythonspot.com/urllib-tutorial-python-3/}
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con titulares de BarraPunto}
\label{subsec:contentapp-barrapunto}

\textbf{Enunciado:}

Partiendo de contentApp (``Gestor de contenidos'', ejercicio~\ref{subsec:contentapp}), realiza contentAppBarraPunto. Esta versión devolverá, para cada recurso para el cuál tenga un contenido asociado en el diccionario de contenidos, una página que incluirá el contenido en cuestión, y los titulares de BarraPunto (para cada uno, título y URL).

Para ello, podéis hacer por un lado una aplicación que sirva para bajar el canal RSS de la portada de BarraPunto, y lo almacene en un objeto persistente (usando, por ejemplo, Shelve). Por otro lado, contentBarraPuntoApp leerá, antes de devolver una página, ese objeto, y utilizará sus datos para componer esa página a devolver. 

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con titulares de BarraPunto versión SQL}
\label{subsec:contentapp-barrapunto-sql}

\textbf{Enunciado:}

Realiza contentDBAppBarraPuntoSQL, con la misma funcionalidad que contentAppBarraPunto (ejercicio~\ref{subsec:contentapp-barrapunto}), pero usando una base de datos SQLite en lugar de un diccionario persistente gestionado con Shelve.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con titulares de BarraPunto versión Django}
\label{subsec:django-cms-barrapunto}

\textbf{Enunciado:}

%% Realiza una aplicación Django con la misma funcionalidad que contentDBAppBarraPuntSQL (ejercicio~\ref{subsec:contentapp-barrapunto-sql}), pero usando el entorno de desarrollo Django.

Realiza una aplicación Django con la misma funcionalidad que ``Django cms'' (ejercicio~\ref{subsec:django-cms}), pero que devuelva para cada recurso para el cuál tenga un contenido asociado en su tabla de la base de datos una página que incluirá el contenido en cuestión, y los titulares de BarraPunto (para cada uno, título y URL).

%% Para ello, podéis hacer por un lado una aplicación que sirva para bajar el canal RSS de la portada de BarraPunto, y lo almacene en un objeto persistente (usando, por ejemplo, Shelve). Por otro lado, contentBarraPuntoApp leerá, antes de devolver una página, ese objeto, y utilizará sus datos para componer esa página a devolver. 

Para reutilizar código, puedes partir de ``Django cms'' (ejercicio~\ref{subsec:django-cms}) o  ``Django cms\_put'' (ejercicio~\ref{subsec:django-cms-put}).

En particular, puedes implementar la consulta a BarraPunto de una de las siguientes formas:

\begin{itemize}
\item Cada vez que se pida un recurso, se mostrará el contenido asociado a él, anotado con los titulares de BarraPunto, que se descargarán (vía canal RSS) en ese mismo momento.
\item Habrá un recurso especial, ``/update'', que se usará para actualizar una tabla con los contenidos de BarraPunto. Cuando se invoque este recurso, se bajarán los titulares (vía canal RSS) de BarraPunto, y se almacenarán en una tabla en la base de datos que mantiene Django. Cada vez que se pida cualquier otro recurso, se mostrará el contenido asociado a él, anotado con los titulares de BarraPunto, que se extraerán de esa tabla, sin volver a pedirlos a BarraPunto.
\end{itemize}

Basta con mostrar por ejemplo los últimos tres o cinco titulares de BarraPunto (cada uno como un enlace a la URL correspondiente).

Repositorio de entrega en  GitLub: \\
\url{https://gitlab.etsit.urjc.es/cursosweb/practicas/server/django-cms-barrapunto}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con videos de YouTube (simple)}
\label{subsec:django-cms-youtube}

\textbf{Enunciado:}

Realiza una aplicación Django que utilice parte de la funcionalidad de ``Django cms'' (ejercicio~\ref{subsec:django-cms}) para construir un archivador de videos de un canal Youtube. Para ello, en el recurso ``/'', la aplicación ofrecerá, como documento HTML, dos listados:

\begin{itemize}
\item Listado de videos seleccionados
\item Listado de videos no seleccionados (seleccionables)
\end{itemize}

Cualquier otro recurso devolverá una página de error.

El listado de videos seleccionables incluirá un listado de todos los videos del canal, junto con un botón ``Seleccionar'' a su lado. Si se pulsa el botón de ``Seleccionar'' para un video, se añadirá éste al listado de videos seleccionados.

El listado de videos seleccionados, que estará vacío inicialmente, incluirá los videos que hayan sido seleccionados, según se indica anteriormente. Junto a cada video, habrá un botón ``Eliminar'', que quitará el video del listado de videos seleccionados.

Un video dado aparecerá sólo en uno de los dos listados.

Para cada video, aparecerá su título, y un enlace al video en cuestión, tanto en el listado de seleccionables como de seleccionados.

La aplicación funcionará cargando el listado del canal cuando arranque, a partir del listado XML de ese canal. Puede usarse el canal ``CursosWeb'' como canal con el que funcionará la aplicación:

\begin{itemize}
\item HTML: \\
  \url{https://www.youtube.com/channel/UC300utwSVAYOoRLEqmsprfg}
\item XML: \\
  \url{https://www.youtube.com/feeds/videos.xml?channel_id=UC300utwSVAYOoRLEqmsprfg}
\end{itemize}

\textbf{Comentarios:}

La descarga del documento XML con los contenidos del canal debería hacerse una vez. Esto debería hacerse en el momento en que la aplicación arranca. Una solución elegante para realizarlo sería utilizar el enganche (hook) \verb|AppConfig.ready|.

Para usarlo, habría que escribir código siguiendo el siguiente esquema. En la app que esté implementando la solución al ejercicio (llamémosla \verb|myapp|) escribiríamos un fichero \verb|myapp/apps.py| con código de este estilo:

\begin{verbatim}
from django.apps import AppConfig
class MyAppConfig(AppConfig):
    name = 'myapp'
    def ready(self):
        url = 'https://www.youtube.com/feeds/videos.xml?channel_id=' \
            + sys.argv[1]
        xmlStream = urllib.request.urlopen(url)
\end{verbatim}

Y luego, para que este código se ejecture, en el fichero \verb|myapp/__init__.py|:

\begin{verbatim}
default_app_config = 'myapp.apps.MyAppConfig'
\end{verbatim}

Si se hace la inicialización de esta manera, hay que tener en cuenta que no se podrá inicializar la base de datos desde el código en \verb|ready|, por varios motivos (consultar la documentación sobre el enganche para ver detalles). Pero pueden usarse listas o diccionarios, dado que si la aplicación vuelve a inicializarse, se volverán a recoger los datos del canal, y dado el enunciado, no se require más persistencia.

De todas formas, si se quieren almacenar los datos en base de datos, alternativamente al mecanismo anterior se puede inicializar mediante migraciones.

\textbf{Documentación:}

\begin{itemize}
\item Appconfig.ready: \\
\url{https://docs.djangoproject.com/en/stable/ref/applications/#django.apps.AppConfig.ready}

\item Migraciones para inicializar datos: \\
\url{https://docs.djangoproject.com/en/3.0/howto/initial-data/#providing-initial-data-with-migrations}
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con videos de YouTube (2)}
\label{subsec:django-cms-youtube-2}

\textbf{Enunciado:}

Vamos a extender la aplicación desarrollada en el ejercicio ``Gestor de contenidos con videos de Youtube'' (ejercicio~\ref{subsec:django-cms-youtube}), con la funcionalidad que se detalla a continuación.

Además del recurso ``/'', esta aplicación servirá recursos de la forma ``/[id]'', siendo ``[id]'' el identificador de un video seleccionado en la página principal (y sólo si no ha sido eliminado). Como identificador utilizaremos el que aparece en el elemento ``yt:videoId'' del documento XML que describe un canal. En cada uno de estos recursos se servirá una página HMTL con el siguiente contenido:

\begin{itemize}
\item Enlace a la página principal de la aplicación
\item Título del video (que será un enlace a la url del video)
\item Imagen del video (obtenida del elemento ``media:thumbnail'' del documento XML que describe el canal (que será un enlace a la url del video)
\item Nombre del canal (que será un enlace a la url del canal)
\item Fecha de publicación del video
\item Descripción del video
\end{itemize}

El recurso ``/'', en el listado de videos seleccionados, en lugar de incluir un enlace al video en Youtube ofrecerá un enlace a la página del video en la aplicación, tal y como se ha indicado anteriormente.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con videos de YouTube (tests)}
\label{subsec:django-cms-youtube-tests}

\textbf{Enunciado:}

En este ejercicio, tienes que añadir tests al programa desarrollado para responder al ejercicio  ``Gestor de contenidos con videos de Youtube (2)'' (ejercicio~\ref{subsec:django-cms-youtube-2}). Los tests deberán ejecutarse ``a la manera de Django'', usando \verb|manage.py test|. Al menos, habrá que creat tests para:

\begin{itemize}
\item El parser que uses para extraer los datos del documento XML. Estos tests leerán uno o varios ficheros XML con el formato correcto, y comprobarán que el parser extrase los datos deseados.
\item Una función auxiliar de cualquiera de las views. Si no tenías ninguna, crea al menos una función auxiliar para cualquier detalle de lo que haga una de las views, de forma que la puedas comprobar con un test.
\item Cada uno de los tipos de recurso que atienda la aplicación. Si un recurso se atiende con GET y POST, harán falta al menos dos tests, uno para cada una de ellos.
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Gestor de contenidos con videos de YouTube (despliegue)}
\label{subsec:django-cms-youtube-despliegue}

\textbf{Enunciado:}

En este ejercicio, tienes que desplegar en PythonAnywhere\footnote{\url{https://pythonanywhere.com}} la implementación de la práctica  ``Gestor de contenidos con videos de Youtube (tests)'' (ejercicio~\ref{subsec:django-cms-youtube-tests}), o alguna otra de las relacionadas con este ejercicio.

PythonAnywyere ofrece un plan gartuito (``Beginner''), que proporciona recursos suficientes para realizar este ejercicio.

\textbf{Materiales:}

\begin{itemize}
\item Proyecto Django \verb|django-youtube-4|, disponible en el repositorio de código de la asignatura. Incluye un fihero \verb|README.md| con indicaciones detalladas sobre el despliegue en PythonAnywhere.
\item ``PythonAnywhere Help Pages'': \\
  \url{https://help.pythonanywhere.com/pages/}
\item ``Deploying a web app on PythonAnywheere'': \\
  \url{https://www.pythonanywhere.com/task_helpers/start/4-deploy-local-web-app/}
\item ``Deploying an existing Django project on PythonAnywhere'': \\
  \url{https://help.pythonanywhere.com/pages/DeployExistingDjangoProject}
\item Capítulo ``Deploy!'' del curso de Django de Django Girls: \\
  \url{https://tutorial.djangogirls.org/en/deploy/}
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Municipios JSON}
\label{subsec:json-municipios}

\textbf{Enunciado:}

Crea un programa Python que lea el fichero \verb|municipios.json|,
y muestra en pantalla el nombre de cada municipio y su id (campo ``url'').
El fichero \verb|municipios.json| contiene una lista de diccionarios,
uno por municipio, con varios campos.

\textbf{Materiales:}

Estos materiales pueden encontrarse en el
directorio \verb|Python-JSON| del repositorio de código de la
asignatura. 

\begin{itemize}
\item Fichero: \verb|municipios.json| \\
  Originalmente, este fichero fue recogido de: \\
  \url{https://opendata.aemet.es/opendata/api/maestro/municipios/?api_key=XXX}
\item Solución de referencia: \verb|json-municipios.py|
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Municipios JSON via HTTP}
\label{subsec:json-municipios-http}

\textbf{Enunciado:}

Igual que ``Municipios JSON'' (ejercicio~\ref{subsec:json-municipios}),
pero recogiendo el documento JSON de la red, vía HTTP.

\textbf{Materiales:}

Estos materiales pueden encontrarse en el
directorio \verb|Python-JSON| del repositorio de código de la
asignatura. 

\begin{itemize}
\item Documento JSON con los municipios: \\
  \url{https://raw.githubusercontent.com/CursosWeb/Code/master/Python-JSON/municipios.json}
\item Solución de referencia: \verb|json-municipios-http.py|
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Forks de un repositorio GitLab}
\label{subsec:json-gitlab-forks}

\textbf{Enunciado:}

Escribe un programa en Python que lea la lista de forks de un repositorio de un sitio GitLab, y escriba un fichero JSON con la lista de urls de los forks.

Ejemplo de ejecución:

\begin{verbatim}
gitlab-forks.py gitlab.etsit.urjc.es 2799 <token>
\end{verbatim}

El resultado será algo como:

\begin{verbatim}
[
  "https://gitlab.etsit.urjc.es/xxx/youtube-descarga.git",
  "https://gitlab.etsit.urjc.es/yyy/youtube-descarga.git",
  "https://gitlab.etsit.urjc.es/zzz/youtube-descarga.git"
]
\end{verbatim}

\textbf{Materiales:}

\begin{itemize}
\item Documentación sobre la API de GitLab, apartado sobre forks de un repositorio: \\
\url{https://docs.gitlab.com/ee/api/projects.html#list-forks-of-a-project}

\item Ejemplo de acceso a lista de proyectos de GitLab:
  
\begin{verbatim}
curl "https://gitlab.com/api/v4/projects" | jq
\end{verbatim}

\item Ejemplo de acceso a la lista de forks de un repositorio:
  
\begin{verbatim}
curl --header "PRIVATE-TOKEN: <token>"
  "https://gitlab.etsit.urjc.es/api/v4/projects/2799/forks"
  | jq | grep http_url_to_repo
\end{verbatim}

\item ``How to fetch Internet resources using the urllib package''
  (documentación de Python): \\
  \url{https://docs.python.org/3/howto/urllib2.html}
\end{itemize}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\subsection{Extractor de información de un documento HTML}
\label{subsec:html-extractor}

\textbf{Enunciado:}

Realiza un programa en Python que, dada la URL de un documento HTML, lo descarga, lo analiza, y muestra en pantalla parte de su contenido. En particular, ha de mostrar:

\begin{itemize}
\item Si hay disponibles propiedades Open Graph\footnote{https://ogp.me/}, se extraerán las propiedades \texttt{og:title} y \texttt{image} (o la que exista de ellas), y se mostrarán.

  Las propiedades Open Graph normalmente se encuentran como metadatos en la cabecera (\texttt{head}) del documento HTML. Por ejemplo:

\begin{verbatim}
<html>
  <head>
  <title>Este es el titulo</title>
  <meta property="og:title" content="Este es el titulo" />
  <meta property="og:image" content="https://..../imagen.jpg" />
  ...
</head>
...
\end{verbatim}

\item Si hay disponible un elemento \texttt{title}, se mostrará su contenido.
\end{itemize}

\textbf{Comentarios:}

Esta práctica puede realizarse usando el módulo \texttt{html.parser} de la bilbioteca estándar de Python, el módulo \texttt{BeautifulSoup4}\footnote{\url{https://www.crummy.com/software/BeautifulSoup/}} disponible en pypi (instalable con pip), o cualquier otro módulo de reconocimiento de HTML.

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 04: Hojas de estilo CSS}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Django cms\_css simple}
\label{subsec:django-cms-css}

\textbf{Enunciado:}

Crea una hoja de estilo en la URL ``/main.css'' para manejar la apariencia de la página ``/about'' en ``Django cms\_put'' (ejercicio~\ref{subsec:django-cms-put}). La hoja tendrá el siguiente contenido:

\begin{verbatim}
body {
  margin: 10px 20% 50px 70px;
  font-family: sans-serif;
  color: red;
  background: white;
}
\end{verbatim}

La página ``/about'' tendrá el contenido que estimes conveniente. Ambos contenidos (el de ``/about'' y el de ``/main.css'') se subirán al gestor de contenidos mediante un PUT, igual que cualquier otro contenido.

Explica en el fichero `README.md` del repositorio de entrega cómo has solucionado la práctica.

Repositorio de entrega en GitLab: \\
\url{https://gitlab.etsit.urjc.es/cursosweb/practicas/server/django-cms-css}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Django cms\_css elaborado}
\label{subsec:django-cms-css-2}

\textbf{Enunciado:}

Modifica tu solución para ``Django cms\_put'' (ejercicio~\ref{subsec:django-cms-put}) de forma que:

\begin{itemize}
\item Si el recurso está bajo ``/css/'', se almacene tal cual al recibirlo (mediante PUT) y se sirva tal cual (cuando se recibe un GET).
\item Si el recurso tiene cualquier otro nombre, se almacene de tal forma cuando se reciba (mediante PUT) que el contenido almacenado sea el cuerpo (lo que va en el elemento $<BODY>$) de las páginas que se sirvan (cuando se reciba el GET correspondiente). Para servir las páginas utiliza una plantilla (\emph{template}) que incluya el uso de la hoja de estilo ``/css/main.css'' para manejar la apariencia de todas las páginas.
\end{itemize}

Repositorio de entrega en GitLab: \\
\url{https://gitlab.etsit.urjc.es/cursosweb/practicas/server/django-cms-css-2}


%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Django cms\_bootstrap cuadrícula}
\label{subsec:django-cms-bootstrap-1}

\textbf{Enunciado:}

Modifica tu solución para ``Django css simple'' (ejercicio~\ref{subsec:django-cms-css}) de forma que:

\begin{itemize}
  \item Utilice Bootstrap (mediante CDN)
  \item El contenido se muestre en una rejilla (grid), con tres columnas:
  \begin{enumerate}
    \item una con la llave, 
    \item otra con el contenido, y
    \item una tercera con un enlace a la página para modificar el contenido
  \end{enumerate}
\end{itemize}


Repositorio de entrega en GitLab: \\
\url{https://gitlab.etsit.urjc.es/cursosweb/django-cms-cuadricula}


%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Django cms\_bootstrap componentes}
\label{subsec:django-cms-bootstrap-2}

\textbf{Enunciado:}

Modifica tu solución para ``Django cms\_bootstrap cuadrícula'' (ejercicio~\ref{subsec:django-cms-bootstrap-1}) de forma que:

\begin{itemize}
  \item Se añada una barra de navegación arriba, con un enlace a ``home'' y otras URLs a tu elección.
  \item Utilice el componente de tarjeta (\emph{card}) para los contenidos de las rejillas
\end{itemize}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Django cms\_bootstrap componentes personalizados}
\label{subsec:django-cms-bootstrap-3}

\textbf{Enunciado:}

Modifica tu solución para ``Django cms\_bootstrap componentes'' (ejercicio~\ref{subsec:django-cms-bootstrap-2}) de forma que utilice uno de los siguientes componentes personalizados de Bootstrap (añadiendo donde fuera necesario imágenes, algunas de ellas servidas como ficheros estáticos desde Django):

\begin{itemize}
  \item Carousel: https://getbootstrap.com/docs/5.0/examples/carousel/
  \item Jumbotron: https://getbootstrap.com/docs/5.0/examples/jumbotron/
  \item Album: https://getbootstrap.com/docs/5.0/examples/album/
\end{itemize}


Repositorio de entrega en GitLab: \\
\url{https://gitlab.etsit.urjc.es/cursosweb/django-cms-bootstrap}


%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios 05: AJAX}

Ejercicios con AJAX y tecnologías relacionadas.

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{SPA Sentences generator}
\label{subsec:spa-sentences-generator}

\textbf{Enunciado:}

Prueba el fichero sentences\_generator.html, que incluye una aplicación SPA simple que genera frases de forma aleatoria, a partir de componentes de tres listas de fragmentos de frases. En particular, observa dónde se obtiene una referencia al nodo del árbol DOM donde se quiere colocar la frase, y cómo se manipula éste árbol para colocarla ahí, una vez está generada.

Una vez lo hayas entendido, modifícalo para que en lugar de usar tres fragmentos para cada frase, use cuatro, cogiendo cada uno, aleatoriamente, de una lista de fragmentos.

\textbf{Material:}
\begin{itemize}
\item sentences\_generator.html: Aplicación SPA que muestra frases componiendo fragmentos.
\end{itemize}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Ajax Sentences generator}
\label{subsec:ajax-sentences-generator}

\textbf{Enunciado:}

Construye una aplicación con funcionalidad similar a ``SPA Sentences generator'' (ejercicio~\ref{subsec:spa-sentences-generator}), pero realizada mediante una aplicación AJAX que pide los datos a un servidor implementado en Django.

El servidor atenderá GET sobre los recursos /first, /second y /third, dando para cada uno de ellos la parte correspondiente (primera, segunda o tercera) de una frase, devolviendo un fragmento de texto aleatorio de una lista con fragmentos que tenga para cada uno de ellos (esto es, habrá una lista para los ``primeros'' fragmentos, otra para los segundos, y otra para los terceros).

La aplicación AJAX solicitará los tres fragmentos que necesita, y los compondrá mostrando la frase resultante, de forma similar a como lo hace la aplicación ``SPA Sentences generator''.

\textbf{Material:}

\begin{itemize}
\item words\_provider.tar.gz: Proyecto Django que sirve como servidor que proporciona fragmentos de frases para la aplicación AJAX anterior. Incluye apps/sentences\_generator.html, aplicación AJAX que muestra frases componiendo fragmentos que obtiene de un sitio web, utilizando llamadas HTTP síncronas, y apps/async\_sentences\_generator.html (similar, pero con llamadas asíncronas).
\end{itemize}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Gadget de Google}
\label{subsec:gadget-google}

\textbf{Enunciado:}

Inclusión de un gadget de Google, adecuadamente configurado, en una página HTML estática.

\textbf{Referencias:}

\url{http://www.google.com/ig/directory?synd=open}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Gadget de Google en Django cms}
\label{subsec:gadget-google-cms}

\textbf{Enunciado:}

Crear una versión del gestor de contenidos Django (Django cms, ejercicio~\ref{subsec:django-cms}) con un gadget de Google en cada página (el mismo en todas ellas).

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{EzWeb}
\label{subsec:ezweb}

\textbf{Enunciado:}

Abrir una cuenta en el sitio de EzWeb, y crear allí un nuevo espacio de trabajo donde se conecten algunos gadgets.

\textbf{Referencia:}

\url{http://ezweb.tid.es}

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{EyeOS}
\label{subsec:eyeos}

\textbf{Enunciado:}

Abrir una cuenta en el sitio de EyeOS, y visitar el entorno que proporciona.

\textbf{Referencia:}

\url{http://www.eyeos.org/}

%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
%%-----------------------------------------------------------------------------
\section{Ejercicios P1: Introducción a Python}

Estos ejercicios pretenden ayudar a conocer el lenguaje de programación Python. Los ejercicios suponen que previamente el alumno se ha documentado sobre el lenguaje, usando las referencias ofrecidas en clase, u otras equivalentes que pueda preferir.

Aunque es fácil encontrar soluciones a los ejercicios propuestos, se recomienda al alumno que realice por si mismo todos ellos.

El primer ejercicio has de hacerlo directamente en el intérprete de Python (invocándolo sin un  programa fuente como argumento). Para los demás, puedes usar un editor (Emacs, gedit, o el que quieras) )o un IDE (Eclipse con el módulo PyDev, o el que quieras).

%%-------------------------------------------------------------------------
%%-------------------------------------------------------------------------
\subsection{Uso interactivo del intérprete de Python}
\label{subsec:practicas-interprete}

\textbf{Enunciado:}

Invoca el intérprete de Python desde la shell. Crea las siguientes
variables:

\begin{itemize}
\item un entero
\item una cadena de caracteres con tu nombre
\item una lista con cinco nombres de persona
\item un diccionario de cuatro
entradas que utilice como llave el nombre de uno de tus amigos y como valor su
número de móvil
\end{itemize}

Comprueba con la sentencia \verb|print nombre_variable| que todo lo
que has hecho es correcto.

Fíjate en particular que la lista mantiene el
orden que has introducido, mientras el diccionario no lo hace. Prueba a mostrar 
los distintos elementos de la lista y del diccionario con \verb|print|.

%%------------------------------------------------------------------------
%%------------------------------------------------------------------------
\subsection{Haz un programa en Python}
\label{subsec:eje-python-primer-programa}

\textbf{Enunciado:}

Haz un programa en Python que haga cualquier cosa, y escriba algo en la salida estándar (en el terminal, cuando lo ejecutes normalmente).

%En tu respuesta a este ejercicio, explica brevemente qué hace, y súbelo como anexo a esa respuesta (opción "Agregar" cuando estés editando la respuesta).

%%------------------------------------------------------------------------
%%------------------------------------------------------------------------
\subsection{Tablas de multiplicar}
\label{subsec:eje-python-tablas}

\textbf{Enunciado:}

Utilizando bucles for, y funciones range(), escribe un programa que muestre en su salida estándar (pantalla) las tablas de multiplicar del 1 al 10, de la siguiente forma:

\begin{verbatim}
Tabla del 1
-----------
1 por 1 es 1
1 por 2 es 2
1 por 3 es 3
...
1 por 10 es 10
Tabla del 2
-----------
2 por 1 es 2
2 por 2 es 4
...
Tabla del 10
------------
...
10 por 10 es 100
\end{verbatim}

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Ficheros y listas}
\label{subsec:ficheros-listas}

\textbf{Enunciado:}

Crea un script en Python que abra el fichero \verb|/etc/passwd|, tome todas sus líneas en una lista de Python e imprima, para cada identificador de usuario, la shell que utiliza.

Imprime también el número de usuarios que hay en esta máquina. Utiliza para
ello un método asociado a la lista, no un contador de la iteración.

Puedes partir del siguiente repositorio: \verb|https://github.com/CursosWeb/X-Serv-Python-Ficheros-y-Listas|

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Ficheros, diccionarios y excepciones}
\label{subsec:ficheros-dic-excep}

\textbf{Enunciado:}

Modifica el script
anterior, de manera que en vez de imprimir para cada identificador de usuario el tipo
de shell que utiliza, lo introduzca en un diccionario. Una vez introducidos todos, imprime por pantalla los valores para el usuario 'root' y para el
usuario 'imaginario'. El segundo produce un error, porque no existe. ¿Sabrías evitarlo mediante el uso de
excepciones?

Puedes partir del siguiente repositorio: \verb|https://github.com/CursosWeb/X-Serv-Python-FichDicExp|

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Calculadora}
\label{subsec:calculadora}

\textbf{Enunciado:}

Crea un programa que sirva de calculadora y que incluya dos funciones
(sumar, restar), que han de llamarse para sumar 1 y 2, 3 y 4, y para restar 5 de 6 y 7 de 8.

%, multiplicar y dividir). 
%El programa ha de poder ejecutarse desde la línea de comandos de la siguiente manera: \texttt{python3 calculadora.py función operando1 operando2}. No olvides capturar las excepciones.

Parte del siguiente repositorio en el GitLab de la ETSIT: \\ \verb|https://gitlab.etsit.urjc.es/cursosweb/x-serv-13.6-calculadora|.

La secuencia debería ser parecida a la siguiente.:

\begin{enumerate}
  \item (Navegador) Entra en el GitLab de la ETSIT con tus credenciales de los laboratorios docentes o de la URJC
  \item (Navegador) Haz un \emph{fork} del proyecto X-Serv-13.6-Calculadora de \emph{CursosWeb}. Esto creará una copia del repositorio de la que tú serás dueño (como se puede comprobar a través de la URL, que ya no contendrá CursosWeb sino tu nombre de usuario).
  \item (Shell) Clona tu repositorio a local con \emph{git clone https://...}
  \item (PyCharm) Crea el programa calc.py, con la funcionalidad que se pide más arriba.
  \item (Shell) Copia calc.py desde donde lo haya creado PyCharm al directorio con tu repositorio local
  \item (Shell) Añade el fichero \texttt{calc.py} para que sea seguido por git con \emph{git add calc.py} 
  \item (Shell) Realiza un commit con los cambios con \emph{git commit -m "Mensaje del cambio" calc.py}
  \item (Shell) Haz un push para sincronizar tu repositorio en local con el tuyo en GitLab con \emph{git push}
  \item (Navegador) Comprueba que tu repositorio en GitLab que se ha sincronizado correctamente (i.e., contiene los últimos cambios)
\end{enumerate}

%%------------------------------------------------------------------------
%%------------------------------------------------------------------------
\subsection{Descarga de documentos web}
\label{subsec:eje-python-descarga-web}

\textbf{Enunciado:}

Crea un fichero Python con clases que ayuden en la descarga de documentos web. Todas las clases estarán en el mismo fichero, que tendrá también un programa principal (que se ejecutará sólo cuando el fichero sea ejecutado directamente) que probará las clases.

Las clases serán las siguientes:

\begin{itemize}
\item Clase \verb|Robot|. Proporcionará un ``robot'' que se encarga de descargar, y en su caso mostrar, un documento web, dada su url. Cumplirá la siguiente especificación:
  \begin{itemize}
  \item Se instanciará indicando como argumento la url del documento del que se ocupará el robot.
  \item Tendrá un método \verb|retrieve|, sin argumentos, que se encargará de descargar el documento de la url de la que se ocupa el robot, sólo si no se lo ha descargado ya antes. Si se lo descarga, mostrará un mensaje en pantalla: ``Descargando url'' (siendo ``url'' la url en cuestión).
  \item Tendra un método \verb|show|, sin argumentos, que mostrará en pantalla el contenido del documento descargado. Para poder mostrarlo, \verb|show| se encargará de usar \verb|retrieve| cuando sea conveniente.
  \item Tendrá un método \verb|content|, sin argumentos, que devolverá una cadena de caracteres (\emph{string}) con el contenido del documento descargado.
  \end{itemize}
\item Clase \verb|Cache|. Proporcionará una cache de documentos, y cumplirá la siguiente especificación:
  \begin{itemize}
  \item No aceptará ningún argumento para ser instanciada.
  \item Tendrá un método \verb|retrieve|, con una url como argumento, que se encargará de descargar el documento correspondiente a esa url, si no ha sido ya descargado antes, y si lo hubiera sido, no hará nada.
  \item Tendrá un método \verb|show|, con una url como argumento, que mostrará en pantalla el contenido del documento correspondiente con esa url, usando \verb|retrieve| para descargarlo si es necesario.
  \item Tendrá un método \verb|show_all|, sin argumentos, que mostrará un listado de todas las urls cuyo documento se ha descargado ya.
  \item Tendrá un método, \verb|content|, con una url como argumento, que devolverá una cadena de caracteres (\emph{string}) con el contenido del documento correspndiente a la url, usando \verb|retrieve| para descargarlo si es necesario.
  \end{itemize}
\end{itemize}

Se recomienda que la clase \verb|Robot| use el módulo estándar de Python \verb|urllib.request|\footnote{Módulo urllib.request: \\ \url{https://docs.python.org/3/library/urllib.request.html}}\footnote{Ejemplos del módulo urllib.request: \\ \url{https://docs.python.org/3/library/urllib.request.html\#examples}} para descargar documentos, y se pide que la clase \verb|Cache| use la clase \verb|Robot| para descargar documentos.

El programa principal creará al menos dos objetos de la clase Robot, llamará a varios de sus métodos, y creará al menos dos objetos de la clase Cache, llamando también a varios de sus métodos, para mostrar que todo funciona.

\textbf{Solución:}

Se ofrece una posible solución en el ficheros \verb|cache_web.py| del directorio \verb|Python-Intro| del repostorio de código de la asignatura.


%%------------------------------------------------------------------------
%%------------------------------------------------------------------------
\subsection{Descarga de documentos web con módulos}
\label{subsec:eje-python-descarga-web-modulos}

\textbf{Enunciado:}

Realiza un programa que tenga la misma funcionalidad que ``Descarga de documentos web'' (ejercicio~\ref{subsec:eje-python-descarga-web}), pero usando un módulo (un fichero Python) para la clase Robot, y otro para la clase Cache. El programa principal, que será otro fichero, implementará la misma funcionalidad de prueba de las clases

\textbf{Solución:}

Se ofrece una posible solución en los siguientes ficheros del directorio \verb|Python-Intro| del repostorio de código de la asignatura:

\begin{itemize}
\item \verb|robot.py|: módulo con la clase Robot
\item \verb|cache.py|: módulo con la clase Cache
\item \verb|cache_web_modules.py|: programa principal
\end{itemize}

\newpage

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\section{Ejercicios P2: Aplicaciones web simples}

Estos ejercicios presentan al alumno unas pocas aplicaciones web que, aunque de funcionalidad mínima, van introduciendo algunos conceptos fundamentales.

%%-----------------------------------------------------------------------
%%-----------------------------------------------------------------------
\subsection{Aplicación web hola mundo}
\label{subsec:aplweb-hola-mundo}

\textbf{Enunciado:}

Construir una aplicación web, en Python, que muestre en el navegador ``Hola mundo'' cuando sea invocada. La aplicación usará únicamente la biblioteca socket. Construir la aplicación de la forma más simple posible, mientras proporcione correctamente la funcionalidad indicada.

\textbf{Motivación:}

Este ejercicio sirve para construir el primer ejemplo de aplicación web. Con ella se muestra ya la estructura típica genérica de una aplicación web: inicialización y bucle de atención a peticiones (a su vez dividido en recepción y análisis de petición, proceso y lógica y de aplicación, y respuesta). Todo está muy simplificado: no se hace análisis de la petición, porque se considera que todo vale, no se realiza proceso de la petición, porque siempre se hace lo mismo, y la respuesta es en realidad mínima.

Aunque no se usará mucho en la asignatura la biblioteca socket (pues trabajaremos a niveles de abstracción superiores), esta práctica sirve para ayudar a entender los detalles que normalmente oculta un marco de desarrollo de aplicaciones web.

La práctica también sirve para introducir el esquema típico de prueba (carga de la página principal de la aplicación con un navegador, colocación en un puerto TCP de usuario, etc.).

\textbf{Material:}

Se ofrecen tres soluciones en el directorio \verb|Python-Web| del repositorio de código de la asignatura:

\begin{itemize}
\item \verb|servidor-http-simple.py|: permite conexiones desde localhost
\item \verb|servidor-http-simple-2.py| permite conexiones desde fuera de la máquina huésped, y es capaz de reusar el puerto de forma que se puede rearrancar en cuanto muere.
\item \verb|servidor-http-simple-3.py| permite conexiones tanto desde localhost como desde fuera de la máquina huésped, y es capaz de reusar el puerto de forma que se puede rearrancar en cuanto muere.
\end{itemize}

%%---------------------------------------------------------------------
%%---------------------------------------------------------------------
\subsection{Variaciones de la aplicación web hola mundo}
\label{subsec:aplweb-hola-mundo-var}

\textbf{Enunciado:}

Basándose en la aplicación ``Hola mundo'' construida para el ejercicio~\ref{subsec:aplweb-hola-mundo}, crear tres aplicaciones diferentes, con la siguiente funcionalidad cada una:

\begin{itemize}
\item Aplicación web que devuelva siempre la misma página HTML, que tendrá que tener al menos una imagen (usando un elemento IMG).

\item Aplicación web que devuelva un código de error 404 y muestre un mensaje en el navegador.

\item Aplicación web que produzca una redirección a la página \url{http://gsyc.es/}
\end{itemize}

\textbf{Material:}

Soluciones de referencia, en el directorio \verb|Python-Web| del repositorio de código de la asignatura:


\begin{itemize}
\item \verb|servidor-http-simple-img.py|
\item \verb|servidor-http-simple-404.py|
\item \verb|servidor-http-simple-301.py|
\end{itemize}

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Aplicación web generadora de URLs aleatorias}
\label{subsec:aplweb-urls-aleatorias}

\textbf{Enunciado:}

Construcción de una aplicación web que devuelva URLs aleatorias. Cada vez que os conectéis al servidor, debe aparecer en el navegador ``Hola. Dame otra'', donde ``Dame otra'' es un enlace a una URL aleatoria bajo \verb|localhost:1234| (esto es, por ejemplo, \url{http://localhost:1234/324324234}). Esa URL ha de ser distinta cada vez que un navegador se conecte a la aplicación.

%Parte para ello (i.e., haz un \emph{fork}) del siguiente repositorio: \url{https://gitlab.etsit.urjc.es/grex/x-serv-14.3-urlsaleatorias}

\textbf{Motivación:}

Explorar una aplicación web como extensión muy simple de ``Aplicación web hola mundo''.

\textbf{Material:}

Soluciones de referencia, en el directorio \verb|Python-Web| del repositorio de código de la asignatura:


\begin{itemize}
\item \verb|servidor-http-simple-random.py|
\end{itemize}

%%-----------------------------------------------------------------------------
\subsection{Aplicación redirectora}
\label{subsec:aplweb-redirectora}

\textbf{Enunciado:}

Construir un programa en Python que sirva cualquier invocación que se le realice con una redirección (códigos de resultado HTTP en el rango 3xx) a otro recurso (aleatorio), que bien puede ser de sí mismo (como en el ejercicio~\ref{subsec:aplweb-urls-aleatorias}) o externo a partir de una lista con URLs.

\textbf{Comentarios:}

Para poder observar con más facilidad en el navegador lo que está ocurriendo, se puede hacer que la aplicación devuelva, en el cuerpo de la respuesta HTTP, un texto HTML indicando que se va a realizar una redirección, y a qué url va a realizarse. Para que este mensaje sea visible durante un tiempo razonable, se puede hacer que la aplicación, al recibir una petición, se quede ``parada'' durante unos segundos antes de contestar con la redirección.

Parte para ello (i.e., haz un \emph{fork}) del siguiente repositorio: \url{https://gitlab.etsit.urjc.es/cursosweb/x-serv-15.4-aplicacion-redirectora}


\textbf{Motivación:}

Entender cómo funciona la redirección, y cómo reacciona un navegador ante ella.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Sumador simple}
\label{subsec:sumador-simple}

\textbf{Enunciado:}

{\bf a) En una fase:} Construye una aplicación web que suma en una fases. Invocamos una URL del tipo \url{http://localhost:1234/sumar/1/2}, aportando la operación, el primer y el segundo operando. La aplicación nos devuelve el resultado de la suma.

{\bf b) En dos fases: } Construye una aplicación web que suma en dos fases. En la primera, invocamos una URL del tipo \url{http://localhost:1234/5}, aportando el primer sumando (el número que aparece como nombre de recurso). En la segunda, invocamos una URL similar, proporcionando el segundo sumando. La aplicación nos devuelve el resultado de la suma. En esta primera versión, suponemos que la aplicación es usada desde un solo navegador, y que las URLs siempre le llegan ``bien formadas''.

Repositorio de inicio: \url{https://gitlab.etsit.urjc.es/grex/x-serv-14.5-sumador-simple}

\textbf{Nota:}

Muchos navegadores, cuando se invoca con ellos una URL, lanzan un GET para ella, y a continuación uno o varios GET para el recurso \texttt{favicon.ico} en el mismo sitio. Por ello, hace falta tener en cuenta este caso para que funcione la aplicación web con ellos.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Clase servidor de aplicaciones}
\label{subsec:clase-serv-aplis}

\textbf{Enunciado:}

Reescribe el programa ``Aplicación web hola mundo'' usando clases, y reutilizándolas, haz otro que devuelva ``Adiós mundo cruel'' en lugar de ``Hola mundo''. Para ello, define una clase \texttt{webApp} que sirva como clase raíz, que al especializar permitirá tener aplicaciones web que hagan distintas cosas (en nuestro caso, \texttt{holaApp} y \texttt{adiosApp}).

Esa clase \texttt{webApp} tendrá al menos:

\begin{itemize}
\item Un método \texttt{Analyze} (o \texttt{Parse}), que devolverá un objeto con lo que ha analizado de la petición recibida del navegador (en el caso más simple, el objeto tendrá un nombre de recurso)
\item Un método \texttt{Compute} (o \texttt{Process}), que recibirá como argumento el objeto con lo analizado por el método anterior, y devolverá una lista con el código resultante (por ejemplo, ``200 OK'') y la página HTML a devolver
\item Código para inicializar una instancia que incluya el bucle general de atención a clientes, y la gestión de sockets necesaria para que funcione.
\end{itemize}

Una vez la clase \texttt{webApp} esté definida, en otro módulo define la clase \texttt{holaApp}, hija de la anterior, que especializará los métodos Parse y Process como haga falta para implementar el ``Hola mundo''.

El código \verb|__main__| de ese módulo instanciará un objeto de clase \texttt{holaApp}, con lo que tendremos una aplicación ``Hola mundo'' funcionando.

Luego, haz lo mismo para \texttt{adiosApp}.

Conviene que en el módulo donde se defina la clase \texttt{webApp} se incluya también código para, en caso de ser llamado como programa principal, se cree un objeto de ese tipo, y se ejecute una aplicación web simple.

\textbf{Motivación:}

Explorar el sistema de clases de Python, y a la vez construir la estructura básica de una aplicación web con un esquema muy similar al que proporciona el módulo Python \texttt{SocketServer}.

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Clase servidor de aplicaciones, generador de URLs aleatorias}
\label{subsec:aplweb-clase-urls-aleatorias}

\textbf{Enunciado:}

Realiza el servidor especificado en el ejercicio ``Aplicación web generadora de URLs aleatorias'' (ejercicio~\ref{subsec:aplweb-urls-aleatorias}) utilizando el esquema de clases definido en el ejercicio ``Clase servidor de aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis}).

Repositorio de inicio: \url{https://gitlab.etsit.urjc.es/grex/x-serv-14.7-servurlaleat}

%%------------------------------------------------------------------------------------
%%------------------------------------------------------------------------------------
\subsection{Clase servidor de aplicaciones, sumador}
\label{subsec:clase-sumador-simple}

\textbf{Enunciado:}

Realizar el servidor especificado en el ejercicio ``Sumador simple'' (ejercicio~\ref{subsec:sumador-simple}) utilizando el esquema de clases definido en el ejercicio ``Clase servidor de aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis}).

Repositorio de inicio: \url{https://gitlab.etsit.urjc.es/grex/X-Serv-14.8-Servidor-Aplicaciones-Sumador}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Clase servidor de varias aplicaciones}
\label{subsec:clase-serv-aplis-multi}

\textbf{Enunciado:}

Realizar una nueva clase, similar a la que se construyó en el ejercicio ``Clase servidor de aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis}), pero preparada para servir varias aplicaciones (\emph{aplis}). Cada \emph{apli} se activará cuando se invoquen recursos que comiencen por un cierto prefijo.

Cada una de estas \emph{aplis} será a su vez una instancia de una clase con origen en una básica con los dos métodos ``parse'' y ``process'', con la misma funcionalidad que tenían en ``Clase servidor de aplicaciones''. Por lo tanto, para tener una cierta apli, se extenderá la jerarquía de clases para \emph{aplis} con una nueva clase, que redefinirá ``parse'' y ``process'' según la semántica de la apli.

Para especificar qué \emph{apli} se activará cuando llegue una invocación a un nombre de recurso, se creará un diccionario donde para cada prefijo se indicará la instancia de \emph{apli} a invocar. Este diccionario se pasará como parámetro al instanciar la clase que sirve varias aplicaciones.

Repositorio de inicio: \url{https://gitlab.etsit.urjc.es/grex/X-Serv-14.9-ServVariasApps}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Clase servidor, cuatro aplis}
\label{subsec:clase-serv-aplis-varias}

\textbf{Enunciado:}

Utilizando la clase creada para ``Clase servidor de varias aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis-multi}), crea una una aplicación web con varias aplis:

\begin{itemize}
\item Si se invocan recursos que comiencen por ``/hola'', se devuelve una página HTML en la que se vea el texto ``Hola''.
\item Si se invocan recursos que comiencen por ``/adios'', se devuelve una página HTML en la que se vea el texto ``Adiós''.
\item Si se invocan recursos que comiencen por ``/suma/'', se proporciona la funcionalidad de ``Sumador simple'' (ejercicio~\ref{subsec:sumador-simple}), esperando que los sumandos se incluyan justo a continuación de ``/suma/''.
\item Si se invocan recursos que comiencen por ``/aleat/'', se proporciona la funcionalidad de ``Aplicación web generadora de URLs aleatorias'' (ejercicio~\ref{subsec:aplweb-urls-aleatorias}).
\end{itemize}

Repositorio de inicio: \url{https://gitlab.etsit.urjc.es/grex/X-Serv-14.10-CuatroAplis}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Herramientas de Web Developer}
\label{subsec:inst-web-developer}

\textbf{Enunciado:}

Introducción a las herramientas de \emph{Web Developer}, que ayudan en el desarrollo
y depuración de aplicaciones web en Firefox.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Ejercicios P3: Introducción a Django}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Instalación de Django}
\label{subsec:django-install}

\textbf{Enunciado:}

Instala la versión de Django que utilizaremos en prácticas.

\textbf{Comentarios:}

Utilizaremos la versión Django 2.1.7.

\textbf{Material:}

\begin{itemize}
\item Transparencias ``Introducción a Django''
\item Descarga de Django: \url{http://www.djangoproject.com/download/} \\
  (``Option 1: Get the latest official version'')
\end{itemize}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Introducción a Django}
\label{subsec:django-intro}

\textbf{Enunciado:}

Realización de un proyecto Django de prueba (myproject), siguiendo el ejemplo de las transparencias ``Introducción a Django''. Creación de las tablas de su base de datos, con Django, y consulta de la base de datos creada con sqlitebrowser.

\textbf{Material:}

Se puede encontrar un ejemplo de solución del ejercicio ``Django intro'' en el directorio \verb|Python-Django/django-intro| del repositorio de codigo.

Además, se recomienda consultar:

\begin{itemize}
\item Django Getting Started: \\
  \url{https://docs.djangoproject.com/en/2.1/intro/}
\end{itemize}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django primera aplicación}
\label{subsec:django-primera}

\textbf{Enunciado:}

Realización de una aplicación Django que haga cualquier cosa, aún sin usar datos en almacenamiento estable. Por ejemplo, puede simplemente responder a ciertos recursos con páginas HTML definidas en el propio programa (en el correspondiente fichero \texttt{views.py}).

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django calc}
\label{subsec:django-calc}

\textbf{Enunciado:}

Realiza una calculadora con Django. Esta calculadora responderá a URLs de la forma ``/suma/num1/num2'', ``/multi/num1/num2'', ``/resta/num1/num2'', ``/div/num1/num2'', realizando las operaciones correspondientes, y devolviendo error ``Not Found'' para las demás.

Parte del repositorio en GitLab: \verb|https://gitlab.etsit.urjc.es/cursosweb/x-serv-15.4-django-calc|. El proyecto Django se llamará \texttt{project} y la aplicación \texttt{calc}. 
Recuerda que sólo tendrás que modificar los siguientes ficheros: \texttt{urls.py} (modificando el del proyecto y creando el de la app) y \texttt{views.py}. 

%\textbf{Material:}
%
%calc.tar.gz: Ejemplo de solución del ejercicio ``Django calc''

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms}
\label{subsec:django-cms}

\textbf{Enunciado:}

Realizar una sistema de gestión de contenidos muy simple con Django. Corresponderá con la funcionalidad de ``contentApp'' (ejercicio~\ref{subsec:contentapp}), almacenando los contenidos en una base de datos. La aplicación Django se ha de llamar \texttt{cms}.

El ejercicio ha de entregarse en el siguiente repositorio en GitLab: 
\url{https://gitlab.etsit.urjc.es/grex/x-serv-15.5-django-cms}. El repositorio contiene
un archivo check.py para comprobar que se han entregado todos los fichero necesarios (básicamente todos los ficheros con código Python del proyecto (\texttt{manage.py} y los contenidos en el directorio \texttt{myproject} y de la aplicación en \texttt{cms}, así como la base de datos en un fichero \texttt{db.sqlite3}), además de comprobar que el código en
\texttt{views.py} sigue con las reglas de estilo de Python (PEP8).

%\textbf{Material:}
%
%cms.tar.gz: Ejemplo de solución del ejercicio ``Django cms''


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_put}
\label{subsec:django-cms-put}

\textbf{Enunciado:}

Realizar una sistema de gestión de contenidos muy simple con Django. Corresponderá con la funcionalidad de ``contentPutApp'' (ejercicio~\ref{subsec:contentputapp}), almacenando los contenidos en una base de datos. En otras palabras, será como ``Django cms'' (ejercicio~\ref{subsec:django-cms}), añadiendo la funcionalidad de que el usuario pueda poner contenidos mediante PUT, tal y como se explicó en el ejercicio de ``contentPutApp''. La aplicación Django se ha de llamar \texttt{cms\_put}.


\textbf{Comentario:}

Para realizar este ejercicio, consultar el manual de Django, donde explica cómo se comporta el objeto HTTPRequest, que es siempre primer argumento en los métodos que estamos definiendo en \texttt{views.py}. En particular, nos interesarán sus atributos ``method'' (que sirve para saber si nos está llegando un GET o un PUT) y ``body'', que nos da acceso a los datos (cuerpo) de la petición en bytes. A pesar de su nombre, este último atributo tiene esos datos tanto si la petición es un POST como si es un PUT. 

El ejercicio ha de entregarse en el siguiente repositorio en GitLab: 
\url{https://gitlab.etsit.urjc.es/cursosweb/x-serv-15.6-django-cms-put}. Has de subir el proyecto y la aplicación entera al repositorio.

%\textbf{Material:}
%
%cms\_put.tar.gz: Ejemplo de solución del ejercicio ``Django cms\_put''.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_users}
\label{subsec:django-users}

\textbf{Enunciado:}

Realizar un proyecto Django con la misma funcionalidad que ``Django cms\_put'', pero incluyendo un módulo de administración (lo que proporciona el ``Admin site'' de Django) y recursos para login y logout de usuarios. Además, cada página de contenidos (o cada mensaje indicando que una página no está disponible) deberá quedar anotada con la cadena ``Not logged in. Login'' (siendo ``Login'' un enlace al recurso de login) si no se está autenticado como usuario, o con la cadena ``Logged in as name. Logout'' (siendo ``name'' el nombre de usuario, y ``Logout'' un enlace al recurso de logout) si se está autenticado como usuario.

\textbf{Comentarios:}

\begin{itemize}
  \item Cada página tendrá, por tanto, la misma funcionalidad que cms\_put, pero además una línea en la parte superior que dependerá de si el usuario que la visita está registrado o no.

  \item Se puede ver cómo realizar la funcionalidad de login y de logout en las páginas de Django, en particular, en \url{https://docs.djangoproject.com/en/dev/topics/auth/default/#auth-web-requests}.

  \item No hace falta tener una página de registro. Si queremos registrar un usuario, lo haríamos a través del interfaz de ``admin''.
\end{itemize}

%Las aplicación Django ``Admin site'', entre otras, utiliza el middleware CSRF (protección frente a ``Cross Site Request Forgery''), que hay que tener en cuenta, especialmente en los formularios POST. En particular, es importante asegurarse de que se han referenciado los módulos de CSRF en settings.py:

%\begin{verbatim}
%MIDDLEWARE_CLASSES = (
%    ...
%    'django.middleware.csrf.CsrfViewMiddleware',
%    'django.middleware.csrf.CsrfResponseMiddleware',
%    ...
%\end{verbatim}

%Más información sobre este tema: \\
%\url{http://docs.djangoproject.com/en/dev/ref/contrib/csrf/}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_users\_put}
\label{subsec:django-users-put}

\textbf{Enunciado:}

Realizar un proyecto Django con la misma funcionalidad que ``Django cms\_users'' (ejercicio~\ref{subsec:django-users}), tratando de que el proceso de login y logout sea lo más razonable posible e incluyendo la funcionalidad de que sólo los usuarios que estén autenticados pueden cambiar el contenido de cualquier página, mientras que los que no lo están sólo pueden ver las páginas (funcionalidad similar a la de ``Gestor de contenidos con usuarios'').

Repositorio en GitLab para entregar el ejercicio: \\ 
\url{https://gitlab.etsit.urjc.es/cursosweb/x-serv-15.8-cmsusersput}.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_templates}
\label{subsec:django-templates}

\textbf{Enunciado:}

Realizar un proyecto Django con la misma funcionalidad que ``Django cms\_users\_put'' (ejercicio~\ref{subsec:django-users-put}), pero atendiendo a una nueva familia de recursos: ``/annotated/''. Cualquier recurso que comience con ``/annotated/'' se servirá usando una plantilla, y por lo demás, con la misma funcionalidad que teníamos en ``Django cms\_users\_put'' al recibir un GET para el nombre de recurso.

%Repositorio en GitHub para entregar el ejercicio: \\ 
%\url{https://github.com/CursosWeb/X-Serv-15.9-Django-CMS-Templates}.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_post}
\label{subsec:django-post}

\textbf{Enunciado:}
 Realizar un proyecto Django con la misma funcionalidad que ``Django cms\_templates'' (ejercicio~\ref{subsec:django-templates}), pero atendiendo a una nueva familiar de recursos: ``/edit/''. Cuando se acceda con un GET a un recurso que comience por ``/edit'', la aplicación web devolverá un formulario que permita editarlo (si se detecta un usuario autenticado, y si el nombre de recurso existe como página en la base de datos de la aplicación). Ese formulario tendrá un único campo que se precargará con el contenido de esa página. Si se accede con POST a un recurso que comience por ``/edit/'', se utilizará el valor que venga en él para actualizar la página correspondiente, si el usuario está autenticado y la página existe. Además, volverá a devolver el formulario igual que con el GET, para que el usuario pueda continuar editando si así lo desea.
 
Repositorio en GitLab: \\
\url{https://gitlab.etsit.urjc.es/cursosweb/practicas/server/django-cms-post}.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django cms\_forms}
\label{subsec:django-forms}

\textbf{Enunciado:}

Realizar el ejercicio ``Django cms\_post'' (ejercicio~\ref{subsec:django-post}) utilizando la clase Forms de Django. 

Además, se ha de intentar que un cambio en el modelo (p.ej. añadir un campo nuevo) sólo afecte al modelo y a la clase Form derivada del mismo, y pueda realizarse sin modificar ni las vistas ni las plantillas.

Repositorio en GitLab para entregar el ejercicio: \\ 
\url{https://gitlab.etsit.urjc.es/cursosweb/practicas/server/django-cms-forms}.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django feed\_expander}
\label{subsec:django-feed-expander}

Utilizando Django y, en la medida que te parezca conveniente, \texttt{feedparser.py} (\url{https://github.com/kurtmckee/feedparser}) y \texttt{BeautifulSoup.py} (\url{http://www.crummy.com/software/BeautifulSoup/}), realiza un servicio que expanda el contenido del canal de un usuario de Twitter. El servicio atenderá peticiones a recursos de la forma \verb|/feed/user| (siendo  \texttt{user} el identificador de un usuario de Twitter), devolviendo una página HTML con:

\begin{itemize}
\item Los cinco últimos \emph{tweets} del usuario.
\item Para cada uno de ellos, la lista de URLs que incluye (considerando como tales, por ejemplo, las subcadenas de caracteres delimitadas por espacios y que comiencen por ``http://''.
\item Para cada una de estas URLs:
  \begin{itemize}
  \item El texto del primer elemento $<p>$ de la página correspondiente, si existe.
  \item Las imágenes (identificadas como elementos $<img>$ que contenga la página correspondiente, si existen.
  \end{itemize}
\end{itemize}

Los canales de usuarios de Twitter están disponibles en formato RSS mediante el servicio Twitrss en URLs como \url{https://twitrss.me/twitter_user_to_rss/?user=user}, para el usuario \texttt{user}.

Pueden usarse también las bibliotecas \texttt{urllib} para la descarga de páginas mediante HTTP, y \texttt{urlparse} para manipular URLs (ambos son módulos estándar de Python).

\textbf{Referencias:}

\begin{itemize}
\item Documentación sobre feedparser.py: \\
  \url{https://pythonhosted.org/feedparser/}
\item Presentación sobre feedparser.py: \\
  \url{http://www.slideshare.net/LindseySmith1/feedparser}
\item Documentación sobre BeautifulSoup.py: \\
  \url{http://www.crummy.com/software/BeautifulSoup/documentation.html}
\end{itemize}


Repositorio en GitLab para entregar el ejercicio: \\ 
\url{https://gitlab.etsit.urjc.es/grex/X-Serv-15.12-Django-feedexpander}.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django feed\_expander\_db}
\label{subsec:django-feed-expander-db}

Realiza un servicio que proporcione la misma funcionalidad que ``Django feed\_expander'' (ejercicio~\ref{subsec:django-feed-expander}), pero almacenando los datos en tablas en una base de datos. Más en detalle:

\begin{itemize}
\item El recurso \verb|/feed/user| seguirá haciendo lo mismo, para el usuario ``user'' de Twitter. Pero además de mostrar la página web resultante, almacenará entablas en la base de datos:

  \begin{itemize}
  \item Los cinco últimos \emph{tweets} del usuario, y el usuario al que se refieren
  \item La lista de URLs de cada \emph{tweet}
  \item El texto del primer elemento $<p>$ de la página referenciada por cada URL.
  \item Las imágenes de dicha página.
  \end{itemize}

En todos estos casos, la información se añadirá a la que haya ya previamente en las tablas correspondientes.

\item El recurso \verb|/db/user| mostrará la misma página que se muestra para \verb|/feed/user|, pero incluyendo toda la información disponible en la base de datos para ese usuario (esto es, no limitado a los cinco últimos \emph{tweets}, si hubiera más den la base de datos). Para mostrar la página mencionada, no se accederá a ningún recurso externo: sólo a la información en la base de datos.
\end{itemize}

\textbf{Comentarios:}

Se pueden realizar varios diseños de tablas en la base de datos para este ejercicio. Entre ellos, se sugieren los basados en el siguiente esquema:

\begin{itemize}
\item Tabla de \emph{tweets}, con dos campos: usuarios y \emph{tweets}, ambos cadenas de texto (además, Django mantendrá un campo id para cada \emph{tweet}).
\item Tabla de URLs, con dos campos: id de \emph{tweet} y URL, el primero un id, el segundo cadena de texto (además, Django mantendrá un campo id para cada URL).
\item Tabla de textos, con dos campos: id de URL y texto (contenido de $<p>$, cadena de texto).
\item Tabla de imágenes, con dos campos: id de URL e imagen (cadena de texto con la URL de la imagen).
\end{itemize}

Desde luego, este esquema se puede simplificar y complicar, pero quizás sea un buen punto medio para empezar a trabajar.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Django Conciertos}
\label{subsec:django-conciertos}

Realiza las siguientes modificaciones a la aplicación de Django llamada conciertos que encontrarás en \url{https://gitlab.etsit.urjc.es/cursosweb/16.14-conciertos}:

\begin{itemize}
  \item Añade una imagen (estática) que se referencia en la plantilla base.
  \item Modifica el widget en el formulario de conciertos para que también se pueda indicar la hora de comienzo del concierto.
  \item Añade al menos dos tests a tests.py.
\end{itemize}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Ejercicios P4: Servidores simples de contenidos}

Construcción de algunos servidores de contenidos que permitan comprender la estructura básica de una aplicación web, y de cómo implementarlos aprovechando algunas características de Python.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Clase contentApp}
\label{subsec:contentapp}

\textbf{Enunciado:}

Esta clase, basada en el esquema de clases definido en el ejercicio ``Clase servidor de aplicaciones'' (ejercicio~\ref{subsec:clase-serv-aplis}), sirve el contenido almacenado en un diccionario Python. La clave del diccionario es el nombre de recurso a servir, y el valor es el cuerpo de la página HTML correspondiente a ese recurso.

La solución de este ejercicio se encuentra disponible en el siguiente repositorio de 
GitLab: \url{https://gitlab.etsit.urjc.es/grex/x-serv-16.3-contentputapp}.

% GitHub:\url{https://github.com/CursosWeb/X-Serv-16.3-contentPutApp}.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Instalación y prueba de Poster}
\label{subsec:inst-poster}

\textbf{Enunciado:}

Instalación y prueba de Poster, \emph{add-on} de Firefox

\textbf{Referencias:}

Poster Firefox add-on: \\
\url{https://addons.mozilla.org/es/firefox/addon/poster/}

También se puede utilizar RestClient, que tiene funcionalidad parecida: \\
\url{https://addons.mozilla.org/en-US/firefox/addon/restclient/}

%%----------------------------------------------------------------------------
\subsection{Clase contentPutApp}
\label{subsec:contentputapp}

\textbf{Enunciado:}

Construcción de la clase ``contentPutApp'', similar a contentApp (ejercicio~\ref{subsec:contentapp}). En este caso, la clase permite la actualización del contenido mediante peticiones HTTP PUT. Para probarla, se puede usar el add-on de Firefox llamado ``Poster''. La clase será minimalista, basta con que funcione con ``Poster''.

Opcionalmente, puede trabajarse en conseguir que un servidor construido con la clase anterior funcione con Bluefish. Bluefish es un editor de contenidos, que puede cargar una página especificando su URL, y que una vez modificada, puede enviarla, usando PUT, de nuevo a la misma URL. Aunque esto es exactamente lo que espera la clase ``contentPutApp'', hay algunas peculiaridades de funcionamiento de Bluefish que hacen que probablemente la clase haya de ser modificada para que funcione correctamente con esta herramienta.

%%----------------------------------------------------------------------------
\subsection{Clase contentPostApp}
\label{subsec:contentpostapp}

\textbf{Enunciado:}

Construcción de la clase ``contentPostApp'', similar a contentApp (ejercicio~\ref{subsec:contentapp}). En este caso, la clase permite la actualización del contenido mediante peticiones HTTP POST. Cuando se reciba un GET pidiendo cualquier recurso, se buscará en el diccionario de contenidos, y si existe, se servirá. En cualquier caso (exista o no exista el contenido en cuestión) se servirá en la misma página un formulario que permitirá actualizar el contenido del diccionario (o crear una nueva entrada, si no existía) mediante un POST.

\textbf{Repositorio de inicio:} \url{https://gitlab.etsit.urjc.es/cursosweb/X-Serv-17.4-ContentPostApp}

\textbf{Referencias:}

Forms in HTML (HTML 4.01 Specification by W3C): \\
\url{http://www.w3.org/TR/html4/interact/forms.html}

%%----------------------------------------------------------------------------
\subsection{Clase contentPersistentApp}
\label{subsec:contentpersistentapp}

\textbf{Enunciado:}

Construcción de la clase contentPersistentApp, similar a contentPutApp (ejercicio~\ref{subsec:contentputapp}), pero incluyendo almacenamiento del diccionario con los contenidos en almacenamiento persistente, de forma que la aplicación mantenga estado al recuperarse después de una caída. Para mantener estado, puede usarse el módulo ``Shelve'' de Python, que permite almacenar y recuperar objetos en ficheros.

Opcionalmente, puede usarse en otra versión el módulo ``dbm'' de Python, que sirve también para gestionar diccionarios persistentes, pero con más limitaciones.

%%----------------------------------------------------------------------------
\subsection{Clase contentStorageApp}
\label{subsec:contentstorageapp}

\textbf{Enunciado:}

Construcción de la clase contentStorageApp similar a contentPersistentApp, pero que use un objeto de clase permanentContentStore para almacenar el estado que ha de sobrevivir a caídas de la aplicación. Esta clase mantendrá variables internas con el estado a salvaguardar persistentemente, y métodos para consultar y actualizar los valores de ese estado.

%%----------------------------------------------------------------------------
\subsection{Gestor de contenidos con usuarios}
\label{subsec:contentappusers}

\textbf{Enunciado:}

Construye la clase contentAppUsers, que amplía el gestor de contenidos que estamos construyendo (clase contentStorageApp, ejercicio~\ref{subsec:contentstorageapp}) con el concepto de usuarios registrados.

Cada usuario registrado tendrá un nombre y una contraseña (que puedes almacenar por ejemplo en un diccionario), y sólo si se ha mostrado al sistema que se es usuario registrado se podrá cambiar contenido del sitio (mediante un PUT). Para mostrar que se es usuario del sistema, se hará un GET a un recurso de la forma ``/login,usuario,contraseña'', donde ``usuario'' y ``contraseña'' son el nombre de un usuario y su contraseña. A partir de ese momento, el sistema reconocerá que los accesos desde el mismo navegador son de ese usuario. 

%%----------------------------------------------------------------------------
\subsection{Gestor de contenidos con usuarios, con control estricto de actualización}
\label{subsec:contentappusersstrict}

\textbf{Enunciado:}

Construye la clase contentAppUsersStrict, que implemente la misma funcionalidad de contentAppUsers (ejercicio~\ref{subsec:contentappusers}), pero que además controle que sólo actualiza un contenido quien lo creó. En otras palabras, cuando la aplicación recibe un PUT, se comprueba que el recurso no existe, y en ese caso, si lo está subiendo un usuario autenticado, se crea. Pero si el recurso existe, sólo lo actualiza si el usuario que está invocando el PUT es el mismo que creó el recurso. Para implementar esta funcionalidad puedes utilizar un diccionario que ``recuerde'' quien creó cada recurso, o añadir, a los datos del diccionario de contenidos (donde sólo había la página HTML para el recurso en cuestión) un nuevo elemento (por ejemplo, usando una lista): el usuario que creó el recurso.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Ejercicios P5: Aplicaciones web con base de datos}

Construcción de aplicaciones web con almacenamiento estable en base de datos.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Introducción a SQLite3 con Python}
\label{subsec:sqlite3-python}

\textbf{Enunciado:}

Vamos a empezar a usar bases de datos relacionales con nuestras aplicaciones web. En particular, vamos a usar el módulo Python sqlite3, que proporciona enlace con el gestor de bases de datos SQLite3, que utiliza una interfaz SQL. Estudiar \texttt{test-db.py}, para entender cómo se hacen operaciones básicas sobre una base de datos con Python. Modificar ese programa para que añada más registros, y comprobar con sqlitebrowser la base de datos creada.

\textbf{Material:}

\texttt{test-db.py}. Programa que crea una base de datos simple SQLite3, y luego la muestra en pantalla.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Gestor de contenidos con base de datos}
\label{subsec:gestor-contenidos-bbdd}

\textbf{Enunciado:}

Escribe y prueba la clase contentDBApp, que será una versión de contentApp (ejercicio~\ref{subsec:contentapp}), pero utilizando una base de datos SQLite3 para almacenar sus objetos persistentes.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Gestor de contenidos con usuarios, con control estricto de actualización y base de datos}
\label{subsec:gestor-contenidos-usuarios-bbdd}

\textbf{Enunciado:}

Escribe y prueba la clase contentDBAppUsersStrict, que será igual que ``Gestor de contenidos con usuarios, con control estricto de actualización'' (contentAppUsersStrict, ejercicio~\ref{subsec:contentappusersstrict}), pero usando base de datos como almacenamiento permanente.

\newpage




%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Ejercicios complementarios de varios temas}

A continuación, algunos ejercicios relacionados con el temario de la asignatura. Algunos de ellos han sido propuestos en exámenes de ediciones previas, o en asignaturas con temarios similares.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Números primos}

Se pide realizar una aplicación web que, dado un número, calcule si es primo o no. El número se indica como recurso, con URLs de la forma http://primos.org/34 (si el número a probar es ``34''). Para esta aplicación:

\begin{enumerate}
\item Escribir la petición y la respuesta HTTP que se podría observar para el caso de que se pruebe el número 34.
\item Escribir el código de la aplicación (sin usar un entorno de desarrollo de aplicaciones web). Escribir el código en Python, pseudo-Python o pseudocódigo. Puede usarse un método ``IsPrime'', que acepta un número como parámetro, y devuelve True si ese número es primo, y False en caso contrario.
\item Se quiere que la aplicación mantenga una caché de los números ya probados, para evitar volver a probar un número si ya se calculó si era primo. Explicar las modificaciones que se verán en el intercambio HTTP, y en el código de la aplicación.
\item Se quiere que la aplicación, tal y como la describía el enunciado al principio de este ejercicio, siga funcionado en presencia de caídas y posteriores recuperaciones del servidor. ¿Qué cambios habrá que hacerle?
\item Lo mismo, en el caso de la aplicación con caché, tal y como se describe dos aparatados más arriba.
\end{enumerate}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Autenticación}

Una aplicación web dada permite el acceso a cierto recurso, ``/resource'', sólo a usuarios que se hayan autenticado previamente. Los usuarios se autentican mediante nombre de usuario y contraseña. La autenticación se realiza mediante POST a un recurso ``/login''. Ese mismo recurso, si recibe un GET, sirve un formulario para poder realizar la autenticación. En este caso, se plantean las siguientes preguntas:

\begin{enumerate}
\item Describir (indicando las cabeceras relevantes y el contenido del cuerpo de los mensajes) las interacciones HTTP, desde que un usuario se quiere autenticar, y pincha en la URL para recibir el formulario, hasta que este usuario recibe un mensaje de bienvenida indicando que está ya autenticado.
\item Escribe el código de una vista (view) que de servicio al recurso ``/login''. Escríbelo como se haría en una view Django (pero si prefieres, usando pseudo-Python o pseudocódigo).
\item Describe la interacción HTTP que se producirá desde que un navegador invoca la un GET sobre ``/resource'' hasta que recibe la pertinente respuesta de la aplicación web. Hazlo primero en el caso de que el navegador se haya autenticado previamente como usuario, y luego en caso de que no lo haya hecho.
\end{enumerate}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Recomendaciones}

Te han pedido que diseñes un servicio en Internet para elegir, comentar y recibir recomendaciones sobre lugares para pasar las vacaciones. Las características principales del sistema serán:

\begin{enumerate}
\item La información, comentarios y recomendaciones siempre estarán referidos a un lugar (un pueblo, una playa, una zona).
\item Cualquier usuario del servicio podrá ``abrir'' un nuevo lugar, simplemente indicando su nombre y subiendo una descripción del mismo. A partir de ese momento, habrá una URL en el servicio que  mostrará esa información. Nos referiremos a esa URL como ``la página del lugar''.
\item Cualquier usuario del servicio (incluyendo el que lo abrió) podrá modificar la descripción de un lugar y/o añadir un comentario. Los comentarios y los cambios en la descripción se reflejarán inmediatamente en la página del lugar correspondiente.
\item Cualquier usuario del servicio podrá ``elegir'' un lugar. Para ello, tendrá un botón que podrá pulsar en la página de ese lugar.
\item Cualquier usuario del servicio podrá pedir que se le recomiende un lugar, según las elecciones pasadas propias y de otros usuarios. El algoritmo que el servicio use para realizar estas recomendaciones no es objeto del diseño.
\item No se quieren mantener cuentas de usuarios, pero sí se quiere poder diferenciar entre usuarios diferentes al menos para las elecciones y las recomendaciones (para que el algoritmo pueda diferenciar entre elecciones propias y elecciones de otros).
\item El sitio ofrecerá, para cada lugar, un canal RSS con los comentarios sobre ese lugar. También  habrá un canal RSS, único para todo el sitio, con los últimos lugares sobre los que se ha comentado.
\end{enumerate}

Salvo cuando se indique otra cosa, se supone que un usuario corresponde con un navegador en un ordenador concreto.

Teniendo en cuenta los requisitos anteriores, se pide:

\begin{enumerate}
\item Detalla un esquema de URLs que permita nombrar, siguiendo en lo posible el diseño REST, todos los elementos del servicio. Procura no usar URLs innecesarias.

\item Describe todas las interacciones HTTP que tendrán lugar en el sistema
  para abrir un lugar. Detalla las URLs implicadas, e indica las cabeceras más
  relevantes.

\item Ídem para realizar un comentario sobre un  lugar. En la página del lugar habrá un  formulario para poner comentarios, el usuario lo rellenará y a continuación lo verá en esa misma página del lugar (no se usa AJAX en este apartado).

\item Ídem para elegir un  lugar. El usuario habrá de estar a la vista del lugar que quiere elegir, y una vez elegido, tendrá que verlo como elegido en esa misma página (no se usa AJAX en este apartado).

\item Cuando un usuario cambie de navegador, querrá seguir siendo reconocido por el sistema. Diseña un mecanismo, lo más simple posible, que le permita hacerlo, manteniendo garantías de que quien no tenga acceso a su navegador no podrá colocarse en su lugar desde otro. Si es posible, diséñalo sin usar el correo electrónico.

\item Describe los cambios que habría que hacer al sistema para que en la página de cada lugar cualquier usuario pueda, además de comentarios, subir fotos.

\item Describe los cambios que habría que hacer en el sistema para que la elección de un lugar se pudiera expresar sin que se produzca una recarga de página, usando AJAX.

\item ¿Se podría construir un gadget, para integrar en un mashup, que mostrase los últimos comentarios que se están poniendo en el servicio? Explica qué partes del servicio especificado en la primera parte del ejercicio usarías, y si es caso, qué modificaciones del servicio harían falta.
\end{enumerate}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Geolocalización}

Se decide construir un sitio para permitir que sus usuarios realicen
anotaciones geolocalizadas que puedan ser consultadas por
otros usuarios. Las características principales del sistema serán:

\begin{enumerate}
\item Cualquier usuario del sitio podrá subir una anotación
  geolocalizada. Para ello, rellenará un formulario en su navegador en el que
  especificará el texto que constituirá la anotación y sus
  coordenadas (latitud y longitud).
\item Cualquier usuario podrá consultar información
  geolocalizada, de varias formas:
  \begin{itemize}
  \item Especificando unas coordenadas (latitud y longitud) y una
    distancia en un formulario en el navegador. El sistema devolverá
    una página HTML con todas las anotaciones (incluyendo sus
    coordenadas y el texto correspondiente) que estén cerca de las
    coordenadas especificadas (a menos de la distancia indicada).
  \item Especificando unas coordenadas (latitud y longitud) y una
    distancia como parte de una URL del servicio, y obteniendo como
    respuesta un canal GeoRSS con todas las anotaciones (incluyendo sus
    coordenadas y el texto correspondiente) que estén cerca de las
    coordenadas especificadas (a menos de la distancia indicada).
  \item Especificando unas coordenadas (latitud y longitud) y una
    distancia como parte de una URL del servicio, y obteniendo como
    respuesta un mapa con los puntos anotados (en formato PNG).
  \item Especificando una cadena de texto en un formulario en el
    navegador. El sistema devolverá una página HTML con todas las
    anotaciones (incluyendo sus coordenadas y el texto
    correspondiente) que incluyan ese texto.
  \end{itemize}
\item Los usuarios podrán usar el sitio sin tener que abrir cuenta (de
  hecho, el sitio no mantendrá cuentas).
\item Cualquier anotación podrá ser editada (para modificarla o
  eliminarla) las veces que se quiera, si se hace desde el mismo
  navegador desde el que se creó.
\end{enumerate}

En particular, y teniendo en cuenta los requisitos anteriores,
se pide:

\begin{enumerate}
\item Describe todas las interacciones HTTP que tendrán lugar en el sistema
  para crear una anotación. Detalla las URLs implicadas, e indica las cabeceras más relevantes.
\item Ídem para ver como página HTML las anotaciones cercanas a una
  posición dada por sus coordenadas.
\item Ídem para editar una anotación previamente creada desde el mismo
  navegador.
\item Se quiere que si un usuario pierde su ordenador, y pasa a usar
  uno nuevo, pueda seguir editando las anotaciones que creó. Describe
  un mecanismo que lo permita, sin obligar al usuario a crear una
  cuenta en el sistema.
\item Se quiere utilizar el servicio de consulta de anotaciones desde
  un programa de gestión de mapas. El programa ya tiene funcionalidad
  de mostrar mapas, y de mostrar información asociada con un punto
  cualquiera del mapa. Se pretende que se utilice esta funcionalidad
  de mostrar información para mostrar las anotaciones. Explicar cómo
  se podría usar el servicio descrito en la primera parte de este
  ejercicio. Indica las URLs y las transacciones HTTP involucradas
  (indicando sus principales cabeceras) para que la aplicación pueda
  mostrar las anotaciones cercanas a un punto del mapa.
\item Indica cómo se podría usar el servicio descrito en la primera
  parte del ejercicio para que desde la aplicación
  del apartado anterior se puedan también crear anotaciones. ¿Puede
  decirse que la parte del servicio que has usado sigue las
  directrices REST?
\item Pasado un tiempo se plantea la posibilidad de incorporar cuentas
  de usuario para que estos puedan autenticarse en el sitio web.
  Describe brevemente 2 mecanismos (en cuanto a interacción
  navegador-servicio) que podrían usarse con HTTP para realizar la
  autenticación y las principales ventajas e inconvenientes de cada
  uno.
\end{enumerate}

\newpage

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\section{Prácticas de entrega voluntaria de cursos pasados}

\subsection{Prácticas de entrega voluntaria (curso 2014-2015)}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2013}

\textbf{Fecha recomendada de entrega:} Antes del 15 de marzo.

Esta práctica tendrá como objetivo la creación de una aplicación web simple para acortar URLs. La aplicación funcionará únicamente con datos en memoria: se supone que cada vez que la aplicación muera y vuelva a ser lanzada, habrá perdido todo su estado anterior. La aplicación tendrá que realizarse según un esquema de clases similar al explicado en clase.

El funcionamiento de la aplicación será el siguiente:

\begin{itemize}
\item Recurso ``/'', invocado mediante GET. Devolverá una página HTML con un formulario. En ese formulario se podrá escribir una url, que se enviará al servidor mediante POST. Además, esa misma página incluirá un listado de todas las URLs reales y acortadas que maneja la aplicación en este momento.

\item Recurso ``/'', invocado mediante POST. Si el comando POST incluye una qs (query string) que corresponda con una url enviada desde el formulario, se devolverá una página HTML con la url original y la url acortada (ambas como enlaces pinchables), y se apuntará la correspondencia (ver más abajo).

Si el POST no trae una qs que se haya podido generar en el formulario, devolverá una página HTML con un mensaje de error.

Si la URL especificada en el formulario comienza por ``http://'' o ``https://'', se considerará que ésa es la url a acortar. Si no es así, se le añadirá ``http://'' por delante, y se considerará que esa es la url a acortar. Por ejemplo, si en el formulario se escribe ``http://gsyc.es'', la url a acortar será ``http://gsyc.es''. Si se escribe ``gsyc.es'', la URL a acortar será ``http://gsyc.es''.

Para determinar la URL acortada, utilizará un número entero secuencial, comenzando por 0, para cada nueva petición de acortamiento de una URL que se reciba. Si se recibe una petición para una URL ya acortada, se devolverá la URL acortada que se devolvió en su momento.

Así, por ejemplo, si se quiere acortar

\verb|http://docencia.etsit.urjc.es|

y la aplicación está en el puerto 1234 de la máquina ``localhost'', se invocará (mediante POST) la URL

\verb|http://localhost:1234/|

y en el cuerpo de esa petición HTTP irá la qs

\verb|url=http://docencia.etsit.urjc.es|

si el campo donde el usuario puede escribir en el formulario tiene el nombre ``URL''. Normalmente, esta invocación POST se realizará rellenando el formulario que ofrece la aplicación.

Como respuesta, la aplicación devolverá (en el cuerpo de la respuesta HTTP) la URL acortada, por ejemplo

\verb|http://localhost:1234/3|

Si a continuación se trata de acortar la URL

\verb|http://docencia.etsit.urjc.es/moodle/course/view.php?id=25|

mediante un procedimiento similar, se recibirá como respuesta la URL acortada

\verb|http://localhost:1234/4|

Si se vuelve a intentar acortar la URL

\verb|http://docencia.etsit.urjc.es|

como ya ha sido acortada previamente, se devolverá la misma URL corta:

\verb|http://localhost:1234/3|

\item Recursos correspondientes a URLs acortadas. Estos serán números con el prefijo ``/''. Cuando la aplicación reciba un GET sobre uno de estos recursos, si el número corresponde a una URL acortada, devolverá un HTTP REDIRECT a la URL real. Si no la tiene, devolverá HTTP ERROR ``Recurso no disponible''.

Por ejemplo, si se recibe 

\verb|http://localhost:1234/3|

la aplicación devolverá un HTTP REDIRECT a la URL

\verb|http://docencia.etsit.urjc.es|

\end{itemize}

\textbf{Comentario}

Se recomienda utilizar dos diccionarios para almacenar las URLs reales y los números de las URLs acortadas. En uno de ellos, la clave de búsqueda será la URL real, y se utilizará para saber si una URL real ya está acortada, y en su caso saber cuál es el número de la URL corta correspondiente.

En el otro diccionario la clave de búsqueda será el número de la URL acortada, y se utilizará para localizar las URLs reales dadas las cortas. De todas formas, son posibles (e incluso más eficientes) otras estructuras de datos.

Se recomienda realizar la aplicación en varios pasos:

\begin{itemize}
\item Comenzar por reconocer ``GET /'', y devolver el formulario correspondiente.
\item Reconocer ``POST /'', y devolver la página HTML correspondiente (con la URL real y la acortada).
\item Reconocer ``GET /num'' (para cualquier número num), y realizar la redirección correspondiente.
\item Manejar las condiciones de error y realizar el resto de la funcionalidad.
\end{itemize}

%%---------------------------------------------------------------------
%%---------------------------------------------------------------------
\subsubsection{Práctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2013}

\textbf{Fecha recomendada de entrega:} Antes del 19 de abril.

Esta práctica tendrá como objetivo la creación de una aplicación web (de nombre \emph{acorta}) simple para acortar URLs utilizando Django (proyecto \emph{project}). Su enunciado será igual que el de la práctica 1 de entrega voluntaria (ejercicio~\ref{subsec:practica-vol-1-2013}), salvo en los siguientes aspectos:

\begin{itemize}
\item Se implementará utilizando Django.
\item Tendrá que almacenar la información relativa a las URLs que acorta en una base de datos, de forma que aunque la aplicación sea rearrancada, las URLs acortadas sigan funcionando adecuadamente.
\end{itemize}

Repositorio GitLab de entrega: \\
\url{https://gitlab.etsit.urjc.es/CursosWeb/X-Serv-18.2-Practica2}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Prácticas de entrega voluntaria (curso 2012-2013)}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2012}

\textbf{Fecha recomendada de entrega:} Antes del 12 de marzo.

Esta práctica tendrá como objetivo la creación de una aplicación web simple para acortar URLs. La aplicación funcionará únicamente con datos en memoria: se supone que cada vez que la aplicación muera y vuelva a ser lanzada, habrá perdido todo su estado anterior. La aplicación tendrá que realizarse según un esquema de clases similar al explicado en clase.

El funcionamiento de la aplicación será el siguiente:

\begin{itemize}
\item Recursos que comienzan por el prefijo ``/acorta/'' (invocados mediante GET). Estos recursos se utilizarán para devolver URLs acortadas, por el procedimiento de proporcionar un número entero secuencial, comenzando por 0, para cada nueva petición de acortamiento de una URL que se reciba. Si se recibe una petición para una URL ya acortada, se devolverá la URL acortada que se devolvió en su momento. La URL a acortar se especificará como parte del nombre de recurso, justo a partir de ``/acorta/'' (quitando la parte ``http://'' de la URL.

Así, por ejemplo, si se quiere acortar

\verb|http://docencia.etsit.urjc.es|

y la aplicación está en el puerto 1234 de la máquina ``localhost'', se invocará (mediante GET) la URL

\verb|http://localhost:1234/acorta/docencia.etsit.urjc.es|

Como respuesta, la aplicación devolverá (en el cuerpo de la respuesta HTTP) la URL acortada, por ejemplo

\verb|http://localhost:1234/3|

Si a continuación se trata de acortar la URL

\verb|http://docencia.etsit.urjc.es/moodle/course/view.php?id=25|

se invocará para ello la URL

\verb|http://localhost:1234/acorta/docencia.etsit.urjc.es/moodle/course/view.php?id=25|

y se recibirá como respuesta la URL acortada

\verb|http://localhost:1234/4|

Si se vuelve a intentar acortar la URL

\verb|http://docencia.etsit.urjc.es|

como ya ha sido acortada previamente, se devolverá la misma URL corta:

\verb|http://localhost:1234/3|

\item Recursos correspondientes a URLs acortadas. Estos serán números con el prefijo ``/''. Cuando la aplicación reciba un GET sobre uno de estos recursos, si el número corresponde a una URL acortada, devolverá un HTTP REDIRECT a la URL real. Si no la tiene, devolverá HTTP ERROR ``Recurso no disponible''.

Por ejemplo, si se recibe 

\verb|http://localhost:1234/3|

la aplicación devolverá un HTTP redirect a la URL

\verb|http://docencia.etsit.urjc.es|

\item Recurso ``/''. Si se invoca este recurso con GET, se obtendrá un listado de todas las URLs reales y acortadas que maneja la aplicación en este momento.
\end{itemize}

\textbf{Comentario}

Se recomienda utilizar dos diccionarios para almacenar las URLs reales y los números de las URLs acortadas. En uno de ellos, la clave de búsqueda será la URL real, y se utilizará para saber si una URL real ya está acortada, y en su caso saber cuál es el número de la URL corta correspondiente.

En el otro diccionario la clave de búsqueda será el número de la URL acortada, y se utilizará para localizar las URLs reales dadas las cortas. De todas formas, son posibles (e incluso más eficientes) otras estructuras de datos.

%%---------------------------------------------------------------------
%%---------------------------------------------------------------------
\subsubsection{Práctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2012}

\textbf{Fecha recomendada de entrega:} Antes del 9 de abril.

Esta práctica tendrá como objetivo la creación de una aplicación web simple para acortar URLs utilizando Django. Su enunciado será igual que el de la práctica 1 de entrega voluntaria (ejercicio~\ref{subsec:practica-vol-1-2012}), salvo en los siguientes aspectos:

\begin{itemize}
\item Se implementará utilizando Django.
\item Tendrá que almacenar la información relativa a las URLs que acorta en una base de datos, de forma que aunque la aplicación sea rearrancada, las URLs acortadas sigan funcionando adecuadamente.
\end{itemize}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Prácticas de entrega voluntaria (curso 2011-2012)}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2011}

%\textbf{Fecha recomendada de entrega:} Antes del 31 de octubre.

Esta práctica tendrá como objetivo la creación de una aplicación web para acceso a los artículos de Wikipedia con almacenamiento en cache.

La aplicación servirá dos tipos de recursos:

\begin{itemize}
\item ``/decorated/article'': servirá la página correspondiente al artículo ``article'' de la Wikipedia en inglés, decorado con las cajas auxiliares.
\item ``/raw/article'': servirá la página correspondiente al artículo ``article'' de la Wikipedia en inglés, sin decorar con las cajas auxiliares.
\end{itemize}

La página ``decorada'' es accesible mediante URLs de la siguiente forma (para el artículo ``pencil'' de la Wikipedia en inglés):

\begin{verbatim}
http://en.wikipedia.org/w/index.php?title=pencil&action=view
\end{verbatim}

El contenido que sirven estas URLs está previsto para ser directamente mostrado, como página HTML completa, por un navegador.

La página ``no decorada'' es accesible mediante URLs de la siguiente forma (para el artículo ``pencil'' de la Wikipedia en inglés):

\begin{verbatim}
http://en.wikipedia.org/w/index.php?title=pencil&action=render
\end{verbatim}

El contenido que sirven estas URLs está previsto para ser directamente empotrable en una página HTML, dentro del elemento ``body'' (y por lo tanto la aplicación web tendrá que aportar el HTML necesario para acabar teniendo una página HTML correcta).

Cualquiera de los dos tipos de recursos se comportará de la misma forma. Si es invocado mediante GET, usará para responder el artículo que tenga en cache. Si no lo tiene, lo bajará previamente accediendo a la URL adecuada, que se indicó anteriormente, lo almacenará en la cache, y lo usará para responder.

La respuesta, en cada caso, será una página HTML que contenga en la parte superior la siguiente información:

\begin{itemize}
\item Nombre del artículo, junto con la indicación ``(decorated)'' o ``(non decorated)'', según corresponda. Por ejemplo, ``Pencil (decorated)''.
\item Enlaces a las páginas con el artículo en la Wikipedia (versiones decorada y no decorada)
\item Enlace a la historia de modificaciones del artículo en la Wikipedia
\item Enlace al último artículos de la Wikipedia que ha servido la aplicación (al navegador que le hizo la petición, o a cualquier otro).
\item Línea de separación (elemento ``hr'').
\end{itemize}

Y a continuación el texto correspondiente del  artículo de la Wikipedia (decorado o no decorado, según sea el nombre del recurso invocado).

En caso de que se pida un artículo que no exista en la Wikipedia, se devolverá el código de error correspondiente, y se marcará en la cache, de alguna forma, que ese artículo no existe, para no tener que buscarlo en caso de que vuelva a ser pedido. En general, puede usarse algún texto que aparezca en la página que devuelve Wikipedia cuando sirve la página de un artículo que no existe, como por ejemplo:

\begin{verbatim}
<div class="noarticletext">
\end{verbatim}

\textbf{Materiales de apoyo:}

\begin{itemize}
\item Parámetros de index.php en Wikipedia (MediaWiki):
\url{http://www.mediawiki.org/wiki/Manual:Parameters_to_index.php#View_and_render}
\end{itemize}

\textbf{Comentario:}

En algunas circunstancias, el servidor de Wikipedia puede devolver un código de redirección (por ejmeplo, un ``301 Moved permanently''). Téngase en cuenta que la aplicación ha de reconocer esta situación, y repetir el GET en la URL a la que se redirige.

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2011}

%\textbf{Fecha recomendada de entrega:} Antes del 20 de noviembre.

Realiza lo especificado en la práctica 1 (ejercicio~\ref{subsec:practica-vol-1-2011}), pero usando el entorno de desarrollo Django. En particular, utiliza plantillas (templates) para la generación de las páginas HTML, tablas en base de datos para almacenar las páginas de Wikipedia descargada, y añade la siguiente funcionalidad:

\begin{itemize}
\item Utilizando el módulo correspondiente de Django, añade usuarios, que se autenticarán en el recurso ``/login''. Las cuentas de usuario estarán dadas de alta por el administrador (vía módulo Admin de Django). Si una página es bajada por un usuario autenticado se incluirá en la parte superior el mensaje ``Usuario: user (logout)'', siendo ``user'' el identificador de usuario correspondiente, y ``logout'' un enlace al recurso que puede utilizar el usuario para salir de su cuenta. Si la página es bajada sin haberse autenticado previamente, en lugar de ese mensaje se incluirá ``Usuario anónimo (login)'', siendo ``login'' un enlace al recurso ``/login''.
\item La aplicación atenderá el recurso ``/'', en el que ofrecerá (si se invoca con ``GET'') una lista de los artículos de Wikipedia disponibles en la base de datos, junto al enlace correspondiente (bajo ``/decorated'' o bajo ``/raw'') para descargarla, y el mensaje ``decorated'' o ``raw'', según el tipo de artículo descargado.
\end{itemize}


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsection{Prácticas de entrega voluntaria (curso 2010-2011)}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 1 (entrega voluntaria)}
\label{subsec:practica-vol-1-2010}

Esta práctica tendrá como objetivo la creación de una aplicación web para acceso a los artículos de Wikipedia, con almacenamiento en cache, y con consulta en varios idiomas.

La aplicación servirá dos tipos de recursos:

\begin{itemize}
\item ``/article'': servirá la página correspondiente al artículo ``article'' de la Wikipedia en inglés.
\item ``/language/article'': servirá la página correspondiente al artículo ``article'' correspondiente al idioma ``language'', expresado mediante el código ISO de dos letras. Bastará con que funcione con los idiomas inglés (en) y español (es).
\end{itemize}

La página que se bajará de la Wikipedia para cada artículo será la ``no decorada'', accesible mediante URLs de la siguiente forma (para el artículo ``pencil'' de la Wikipedia en inglés):

\begin{verbatim}
http://en.wikipedia.org/w/index.php?action=render&title=pencil
\end{verbatim}

El contenido que sirve esta URL está previsto para ser directamente empotrable en una página HTML, dentro del elemento ``body''.

Cualquiera de los dos tipos de recursos se comportará de la misma forma. Si es invocado mediante GET, usará para responder el artículo que tenga en cache. Si no lo tiene, lo bajará previamente accediendo a la URL de página no decorada, que se indicó anteriormente, lo almacenará en la cache, y lo usará para responder.

La respuesta será una página HTML que contenga:

\begin{itemize}
\item Título de la página (nombre del artículo).
\item Enlace a la página con el artículo en la Wikipedia (versión decorada)
\item Enlace a la historia de modificaciones del artículo en la Wikipedia
\item Enlace a los tres últimos artículos de la Wikipedia que ha servido la aplicación (al navegador que le hizo la petición, o a cualquier otro).
\item Texto de la página no decorada del artículo de la Wikipedia.
\end{itemize}

En caso de que se pida un artículo que no exista en la Wikipedia, se devolverá el código de error correspondiente, y se marcará en la cache, de alguna forma, que ese artículo no existe, para no tener que buscarlo en caso de que vuelva a ser pedido. En general, puede usarse algún texto que aparezca en la página que devuelve Wikipedia cuando sirve la página de un artículo que no existe, como por ejemplo:

\begin{verbatim}
<div class="noarticletext">
\end{verbatim}

\textbf{Materiales de apoyo:}

\begin{itemize}
\item Parámetros de index.php en Wikipedia (MediaWiki):
\url{http://www.mediawiki.org/wiki/Manual:Parameters_to_index.php#View_and_render}
\end{itemize}

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 2 (entrega voluntaria)}
\label{subsec:practica-vol-2-2010}

Esta práctica consistirá en la realización de un gestor de contenidos que tenga las siguientes características:

\begin{itemize}
\item Funcionalidad de ``Gestor de contenidos con usuarios, con control estricto de actualización y uso de base de datos'' (ejercicio~\ref{subsec:gestor-contenidos-usuarios-bbdd})

\item Implementación de HEAD para todos los recursos.

\item Terminación de una sesión autenticada. Para ello se usará el recurso ``/logout''.

\item Además, cada página que se obtenga con un GET irá anotada con la siguiente información:
  \begin{itemize}
  \item Sólo si la página no la está viendo un usuario autenticado. Enlace que permita la autenticación del usuario que creó la página (a falta de la contraseña). Aparecerá con la cadena ``Autor: user'', siendo ``user'' el nombre de usuario que creó la página, y estando enlazado a ``/login,user,''.
  \item Enlace que permita ver el mensaje HTTP que envió el navegador para poder ver esa página (se puede suponer que esa fue la última página descargada desde este navegador).
  \item Enlace que permita ver la respuesta HTTP que envió el servidor para poder ver esa página (se puede suponer que esa fue la última página descargada desde este navegador).
  \end{itemize}
\end{itemize}

Además, opcionalmente, podrá tener:

\begin{itemize}
\item Creación de cuentas de usuario. Para ello se usará un recurso ``/signin,user,passwd'', sobre el que un GET creará el usuario ``user'' con la contraseña ``passwd'', si ese usuario no existía ya.
\item Subida de páginas con POST. en lugar de PUT. Se usará un POST para subir una nueva página. No hace falta implementar un formulario HTML que invoque el POST, pero también se podría hacer.
\item Una implementación que no tenga la limitación de que los enlaces al mensaje HTTP del navegador y del servidor sean de la última página descargada, sino de los de la descarga de la página que los tiene, sea la última o no.
\end{itemize}

Realizar la entrega en un fichero tar.gz o .zip, incluyendo además del código fuente los ficheros de SQLite3 necesarios, y un fichero README que resuma la funcionalidad exacta que se ha implementado (en particular, que detalle la funcionalidad opcional implementada).

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 3 (entrega voluntaria)}
\label{subsec:practica-vol-3-2010}

Realiza lo especificado en la práctica 2, pero usando el entorno de desarrollo Django. Donde lo creas oportuno, interpreta las especificaciones en el contexto de las facilidades que proporciona Django. Por ejemplo, la autenticación de usuarios se puede hacer vía un formulario de login (con el POST correspondiente) usando los módulos que proporciona Django para ello.

Igualmente, extiende las especificaciones en lo que te sea simple al usar las facilidades de Django. Por ejemplo, la gestión de usuarios (creación y borrado de usuarios) puede hacerse fácilmente usando módulos Django.

En la medida que sea razonable, usa POST (con los correspondientes formularios) en lugar de PUT. Opcionalmente, mantén ambas funcionalidades (subida de contenidos vía PUT, como se indicaba en la práctica 2, y vía POST, como se está recomendando para ésta).

\textbf{Notas:}

Parte de la especificación requiere almacenar las cabeceras de la respuesta del servidor al navegador. En Django, las cabeceras se van añadiendo al objeto HTTPResponse (o similar), y por tanto será necesario extraerlas de él. La forma más simple, y suficiente para estas prácticas, es simplemente convertir el objeto HTTPResponse en string: ``str(response)''. Si se quiere, se puede manipular el string resultante, para obtener las cabeceras en un formato más parecido al de la práctica 1, pero esto no será necesario para la versión básica.


%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
\subsubsection{Práctica 4 (entrega voluntaria)}
\label{subsec:practica-vol-4-2010}

Realización de lo especificado en la práctica 3 de entrega voluntaria, utilizando para la implementación las posibilidades avanzadas de Django, incluyendo especialmente las plantillas, y si es posible el sitio de administración, los usuarios y las sesiones Django. La parte básica seguirá siendo básica, y la opcional, opcional (más la adición, opcional, que se comenta más adelante).

La funcionalidad de esta práctica es, por lo tanto, la misma que la de la práctica 3. Pero a diferencia de la práctica 3, en este caso sí se pide usar los módulos ``de alto nivel'' de Django.

La URL que se usaba en las prácticas 2 y 3 para autenticarse pasa a ser ``/login'', que en el caso de recibir un GET devolverá el formulario para autenticarse, y en caso de recibir un POST gestionará la autenticación.

A la parte opcional de las prácticas 2 y 3, que sigue siendo opcional, se añade la de modificar el contenido de las páginas con formularios (usando métodos POST para la actualización), y de crear nuevas páginas también mediante formularios y POST. Para la actualización se sugiere que se usen nombres de recurso de la forma ``/edit/name'', siendo ``name'' el nombre de la página. Para la creación se sugiere que se use un nombre de recurso de la forma ``/create''.

Con respecto a la opción de crear usuarios, ahora la opción cambia a servir una URL ``/signin'' que devuelva el formulario para crearse una cuenta, y que cuanto reciba un POST gestione la creación de la cuenta.

\newpage

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\section{Pruebas escritas pasadas}

\input{exa-saro-2021-06-04}

\input{exa-sat-2021-06-01}

\input{exa-saro-2020-05}

\input{exa-saro-2019-05}

\input{exa-sat-2019-05}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Examen de ITT-SAT, 7 mayo de 2018}


Se quiere construir un sitio web, MisMuseos, donde se puedan compartir valoraciones sobre museos. La funcionalidad básica del sitio es la siguiente:

\begin{enumerate}
\item Para poder utilizar el sitio hace falta un código de acceso. Los códigos de acceso son cadenas alfanuméricas de 20 caracteres, que se consiguen en los museos. Una vez se ha introducido un código de acceso correcto desde un navegador se puede acceder desde ese navegador a toda la funcionalidad del sitio. Si no, cualquier recurso del sitio devolverá un documento HTML con un formulario para introducir un código de acceso.

\item Una vez se ha introducido un código válido (que llamaremos, a partir de ese momento, ``código activo'' en ese navegador), el sitio sólo proporcionará dos recursos que devuelvan un documento (salvo que haga falta alguno más para proporcionar la funcionalidad descrita en este enunciado):
  \begin{itemize}
  \item El recurso (página) principal, que devolverá el documento HTML que se describe más adelante.
  \item El recurso de valoraciones realizadas, que devolverá un documento XML con un listado de las valoraciones realizadas usando el código de acceso activo en el navegador, ordenadas por fecha de valoración, e incluyendo para cada una de ellas el nombre del museo y la valoración dada.
  \end{itemize}

\item Cualquier otro recurso que se pida desde el navegador causará que se envié una redirección a la página principal.

\item La página principal del sitio mostrará a los visitantes (una vez se ha introducido un código válido):
  \begin{itemize}
  \item Un formulario para elegir un nombre, o el nombre si ya se usó el formulario para elegirlo
  \item Un enlace que, si se pulsa, hará que el código de acceso quede ``desactivado'' (dejando por tanto de ser un ``código activo'' en ese navegador). Cualquier nueva acción en el sitio devolverá el formulario para introducir el código de acceso.
  \item Un listado con todos los museos que tienen MisMuseos, incluyendo para cada museo una foto, el nombre del museo, la puntuación media que le han dado los visitantes del sitio, y un formulario para valorarlo. Este formulario tendrá un botón (``Valorar'') y una caja para poner la valoración (un número entero entre 0 y 4).
  \end{itemize}

\item Además, todas las páginas HTML (incluido el formulario para introducir el código de acceso) incluirán una imagen transparente, de un píxel, que se utilizará para que MisMuseos pueda trazar el número de páginas vistas desde un mismo navegador, esté activo un código en ese navegador o no.

\item Las fotos de cada museo son servidas por el sitio web de cada museo, no por MisMuseos.

\item Al poner un valor en el formulario de valoración de un museo, y pulsar ``Valorar'', se añadirá una nueva valoración al museo en cuestión, si el código de acceso activo en ese navegador nunca había valorado ese museo, o cambiará la valoración anterior, si ya lo había valorado.

\item Un mismo código de acceso puede ser utilizado desde varios navegadores (estar activo en ellos), en periodos diferentes o simultáneos.

\item En un mismo navegador pueden estar activos varios códigos de acceso, pero  no simultáneamente. Sólo si se ``olvida'' (deja de estar activo) el que se está usando, se podrá activar otro, introduciéndolo en el formulario que se recibirá tras pulsar el enlace de ``olvidar''.

\end{enumerate}


Teniendo en cuenta los requisitos anteriores, se pide:

\begin{enumerate}
\item Diseña un esquema REST para proporcionar el servicio descrito. Se habrán de especificar los nombres de recurso empleados, y cómo reaccionará la aplicación cuando reciba los métodos POST o GET sobre esas urls (no se usarán los métodos PUT o DELETE). Coloca la información en una tabla, con las urls en una columna, los métodos en otra, y la descripción de lo que realizará la aplicación al recibirlos en la tercera. Escribe también un fichero similar al fichero urls.py de Django (aunque no es importante que se respete la sintaxis mientras se entienda y la estructura sea similar a la de Django), que refleje el esquema REST anterior (1 punto).

\item Describe el modelo de datos que necesitará esta aplicación. Define las tablas necesarias y los campos necesarios para la funcionalidad descrita. Asegúrate de que incluyes en el modelo de datos la tabla o tablas necesarias para saber el número de páginas vistas por cada navegador, gracias al uso de la imagen transparente que se describe en en enunciado. Hazlo de forma lo más similar posible a lo que tendrías que escribir en el fichero models.py en Django (aunque no es importante que se respete la sintaxis mientras se entienda el modelo de datos que propones) (1 punto).

\item Describe las interacciones HTTP que ocurrirán entre el navegador y cualquier servidor web en el siguiente escenario. El escenario comienza cuando un visitante que accede por primera vez al sitio pone en el navegador la url de la página principal del sitio. A continuación, después de ver esta página principal, rellena el formulario que recibe con un código de acceso válido. El escenario termina cuando el visitante vuelve a ver la página principal del sitio, pero ahora ya con el código activo, y por lo tanto viendo la lista de museos. (1 punto).

\item Describe las interacciones HTTP que ocurrirán entre el navegador y cualquier servidor web en el siguiente escenario. El escenario comienza con un visitante que ya tiene un código activo está viendo la página principal del sitio, con la lista de museos. El visitante rellena el formulario de valoración de un museo, que nunca había valorado antes con ese código, y pulsa el botón ``Valorar''. El escenario termina cuando el visitante vuelve a ver la página principal, con la lista de museos (1 punto).

\item Escribe cómo podría ser el documento XML para un visitante que está usando un código con el que se han realizado valoraciones para los museos ``El Campo'', ``Reina Margarita'' y ``Tisten'' (una valoración para cada uno) (1 punto).
\end{enumerate}

En todos los escenarios, ten en cuenta que tu respuesta debe considerar toda la funcionalidad que ofrece el servicio, y permitir que ésta pueda proporcionarse. Diseña la aplicación de forma que envíe cookies al navegador sólo cuando sea necesario.

En las respuestas donde describas interacciones HTTP indica para cada una de ellas claramente y en este orden:
  \begin{itemize}
  \item La primera línea de la petición HTTP
  \item Si lo hay, el contenido de la petición
  \item La primera línea de la respuesta HTTP
  \item Si lo hay, el contenido de la respuesta
  \item Una brevísima explicación de para qué se usa la interacción
  \item Tanto en la petición como en la respuesta, las cabeceras con cookies, si es que fueran necesarias para la funcionalidad del escenario que se está describiendo (incluyendo el aspecto que han de tener esas cabeceras). Si la cabecera con cookie va o no dependiendo de algún factor ajeno a tu aplicación, explica cuando irá y cuándo no, y cuál es ese factor.
  \end{itemize}

Además, asegúrate de que describes las interacciones HTTP en el orden en que ocurrirían en el escenario.

\section*{Soluciones}

Hay muchas soluciones posibles. A continuación, una de ellas.

\subsection*{Esquema REST}

Este podría ser el esquema REST una vez se ha introducido un código válido:

\begin{tabular}{|l|l|l|}
  \hline
  Recurso & Método & Comentario \\ \hline \hline
  /       & GET    & Página principal (HTML) \\
          & POST   & \verb|museo=id&val=val| \\
          &        & (valoración de museo) \\
          &        & o \\
          &        & \verb|nombre=nombre| \\
          &        & (poner nombre) \\
          &        & Devolverá el mismo HTML que si se invoca con GET \\ \hline
  /val.xml & GET   & Página XML con valoraciones para el código (XML) \\ \hline
  /pixel  & GET    & Pixel para trazar páginas vistas (GIF) \\ \hline
  /salir  & GET    & Desactivación de código \\
          &        & Devolverá el formulario para introducir código (HTML) \\
          &        & (según el enunciado, se invoca con un enlace, luego \\
          &        & ha de ser GET) \\ \hline
\end{tabular}

Antes de introducirlo, todos los recursos devolverán, ante un GET, el formulario para introducir el código, salvo ``/pixel'' (que funcionaría igual) y / que para POST admitiría un código, \verb|codigo=codigo_museo| (para GET devolvería el formulario también).

El recurso / podrá discriminar, si recibe un POST, si se está valorando un museo o si se está poniendo un nombre por el nombre de los campos en la query string recibida.

\vspace{.3cm}

Nota: Alternativamente, podría haber un recurso para valorar para cada muse, por ejemplo ``/valorar/\{museo\}'', sobre el que se haría el POST de valoración. Pero en ese caso, sería recomendable que este recurso, además de aceptar la valoración, devolviese una redirección sobre el recurso /.

\subsection*{urls.py}

Lo escribimos sólo para el esquema REST una vez se ha introducido el código:

\begin{verbatim}
from django.conf.urls import url
from . import views

urlpatterns = [
    url(r'^$', views.pagina_principal),
    url(r'^val.xml$', views.valoraciones),
    url(r'^pixel$', views.trazado),
    url(r'^salir$', views.salir)
]
\end{verbatim}

\subsection*{models.py}

Versión simplificada, que cumple el enunciado, aunque podría optimizarse:

\begin{verbatim}
from django.db import models

class Codigos(models.Model):
    codigo = models.CharField(max_length=20)
    nombre = models.CharField(max_length=100, null==True)

class Museos(models.Model):
    nombre = models.TextField()
    id = models.IntegerField()
    foto = models.CharField(max_length=100)

class Navegadores(models.Model):
    cookie = models.CharField(max_length=32)
    vistas = models.IntegerField()

class Activos(models.Model):
    codigo = models.ForeignKey('Codigos')
    navegador = models.ForeignKey('Navegadores')

class Valoraciones(models.Model):
    codigo = models.ForeignKey('Codigos')
    museo = models.ForeignKey('Museos')
    valoracion = models.IntegerField()
    fecha = models.DateTimeField()
\end{verbatim}

No se incluyen los campos identificador único para cada tabla.

La tabla Codigos tendrá todos los códigos válidos (que se han repartido a los museos). Esta tabla es fuente de ineficiencias, porque la mayoría de los nombres estarán vacíos (dado que corresponderán a códigos no usados o a los que no se les ha puesto nombre), por lo que en producción sería conveniente tener una tabla separada para los nombres. Pero tal y como está definida aquí, funcionaría.

\subsection*{Primer escenario}

Todas las interacciones son entre el navegador y el sitio MisMuseos, salvo cuando se indica otra cosa.

\begin{itemize}
\item Petición GET /

\begin{verbatim}
  GET / HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK

  [Formulario para codigo, HTML]
\end{verbatim}

\item Petición GET /pixel. El navegador, al cargar el documento HTML recibido, encontrará en él la referencia al pixel para trazado, y lo pedirá mediante otra interacción HTTP:

\begin{verbatim}
  GET / HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...
  Set-Cookie: ....; navegador=12345ABCDE12345ABCDE12345ABCDE12

  [Imagen para trazado, GIF]
\end{verbatim}

\verb|navegador| es un identificador de navegador, que servirá para trazar las páginas vistas (suponemos que este se envía con cabeceras que lo hagan no-cacheable, de forma que pueda realizar su misión). También se utilizará, cuando se haya enviado un código válido, para saber que este navegador se ha autenticado (anotándolo en la tabla Activos).

\item Petición POST / (para proporcionar el código que se ha introducido en el formulario):

\begin{verbatim}
  POST / HTTP/1.1
  ...
  Cookie: navegador=12345ABCDE12345ABCDE12345ABCDE12

  codigo=ABCDE12345ABCDE12345
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Página principal con la lista de museos, HTML]
\end{verbatim}

Al recibir esta petición y comprobar que el código es correcto (utilizando la tabla Codigos), MisMuseos apuntará este navegador con este código en la tabla Activos, donde seguirá apuntado hasta que el usuario decida desactivar este código en su navegador.


\item Petición GET /pixel (igual que la anterior):

\begin{verbatim}
  GET / HTTP/1.1
  ...
  Cookie: navegador=12345ABCDE12345ABCDE12345ABCDE12
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK

  [Imagen para trazado, GIF]
\end{verbatim}

En esta ocasión, ya no se recibe una cookie, sino que se envía (ya se recibió, y MisMuseos, al detectar que ya viene con la petición, no la vuelve a enviar). Al recibir esta petición, MisMuseos apuntará una nueva página vista para este navegador.

\item Petición GET de la foto del museo museo (una por cada museo). Cada una de estas interacciones son {\bf con el sitio web de los museos en cuestión}.

\begin{verbatim}
  GET /url_foto HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK

  [Foto, GIF]
\end{verbatim}

\item ...
\end{itemize}


\subsection*{Segundo escenario}

A continuación, las interacciones son entre el navegador y el sitio MisMuseos. Suponemos, como ya se ha indicado, que la imagen se sirve como no-cacheable..

\begin{itemize}
\item Petición POST / (para realizar una valoración):

\begin{verbatim}
  POST / HTTP/1.1
  ...
  Cookie: navegador=12345ABCDE12345ABCDE12345ABCDE12

  museo=5&val=3
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Página principal con la lista de museos, HTML]
\end{verbatim}

Al recibir esta petición, MisMuseos comprobará que el código está activo, buscando el identificador de navegador en la tabla Activos, y consiguiendo a partir de la entrada correspondiente el código. A continuación, utilizará el código para añadir una entrada a la tabla Valoraciones con el identificador del museo, el código, y la valoración.

\item Petición GET /pixel (igual que las anteriores):

\begin{verbatim}
  GET / HTTP/1.1
  ...
  Cookie: navegador=12345ABCDE12345ABCDE12345ABCDE12
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK

  [Imagen para trazado, GIF]
\end{verbatim}

\end{itemize}

En este caso no se han incluido las peticiones de las fotos de los museos, porque se hace la suposición razonable de que serán imágenes cacheables. En cualquier caso, si no se hace esta suposición, se pueden incluir, de la misma forma que se incluyeron anteriormente

\subsection*{Canal XML}


\begin{verbatim}
<?xml version="1.0" encoding="UTF-8" ?>

<valoraciones>
  <codigo>ABCDE12345ABCDE12345</codigo>
  <lista_valoraciones>
    <valoracion>
      <museo>El Campo</museo>
      <val>3</val>
      <fecha>2018-05-03 12:20:21</fecha>
    </valoracion>
    <valoracion>
      <museo>Reina Margarita</museo>
      <val>4</val>
      <fecha>2018-05-02 11:10:31</fecha>
    </valoracion>
    <valoracion>
      <museo>Tisten</museo>
      <val>1</val>
      <fecha>2018-05-01 13:23:11</fecha>
    </valoracion>
  </lista_valoraciones>
</valoraciones>
\end{verbatim}

En general, hay que cuidar que la valoración de cada museo sea claramente identificable que corresponde a ese museo, y las convenciones sintácticas de XML.


%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Examen de ITT-SARO, 17 mayo de 2018}


Se quiere construir un sitio web, MisMuseos, donde se puedan compartir comentarios sobre museos. La funcionalidad básica del sitio es la siguiente:

\begin{enumerate}
\item El sitio está públicamente accesible para cualquiera que lo quiere consultar, sin necesidad de abrir cuenta ni ningún otro trámite.

\item Además, cualquiera podrá dar un ``me gusta'' a los museos que quiera, en la página del museo (ver más abajo), pero no más de una vez desde el mismo navegador (ver página de museo, más abajo).

\item Para poder poner un comentario sobre un museo, hace falta un código de acceso, disponible en ese museo. Los códigos de acceso son cadenas alfanuméricas de un solo uso, en el sentido de que quien tiene un código puede poner un comentario sobre el museo correspondiente y editarlo cuantas veces quiera desde cualquier navegador, usando ese código. Pero una vez usado para poner un comentario, ese código sólo permitirá cambiar el comentario.

\item La funcionalidad ``en modio consulta'' del sitio es la siguiente:
  \begin{itemize}
  \item El recurso (página) principal del sitio tendrá un listado de todos los museos que se pueden consultar. Para cada museo se mostrará el nombre del museo (que será un enlace a la página del museo, ver más abajo), el último comentario para ese museo, y un icono (en formato PNG) con el número de ``me gusta'' que ha recibido ese museo.
  \item La página de cada museo tendrá el nombre y dirección del museo, un formulario con un botón (sin icono) para indicar ``me gusta'' si no se ha pulsado ya ese botón desde ese mismo navegador, y un formulario para escribir un código de museo, si no se ha utilizado ya desde ese navegador para ese mismo museo (en ese caso, el museo estará ``en modo comentario'' (ver más abajo). Además, tendrá el listado de todos los comentarios que se hayan puesto, con cualquier código válido y desde cualquier navegador, para ese museo.
  \end{itemize}

\item La funcionalidad ``en modo comentario'' del sitio es igual, salvo que en la página de los museos donde se haya introducido un código válido desde ese navegador, en lugar del formulario para introducir el código aparecerá un formulario para introducir un comentario. Si ese código ya  se ha usado (desde cualquier navegador) para introducir un comentario, ese comentario aparecerá ``precargado'' en el formulario. El resto de la página es exactamente igual que en ``modo consulta''.

\item Los iconos que se ven en las páginas del sitio están servidas por el propio sitio.

\item Todas las páginas del sitio (página principal y páginas de museos) tendrán un banner (imagen en formato PNG), que será servido por un sitio tercero que llamaremos ``Servidor del banner''.
\end{enumerate}


Teniendo en cuenta los requisitos anteriores, se pide:

\begin{enumerate}
\item Diseña un esquema REST para proporcionar el servicio descrito. Se habrán de especificar los nombres de recurso empleados, y cómo reaccionará la aplicación cuando reciba los métodos POST o GET sobre esas urls (no se usarán los métodos PUT o DELETE). Coloca la información en una tabla, con las urls en una columna, los métodos en otra, y la descripción de lo que realizará la aplicación al recibirlos en la tercera. Escribe también un fichero similar al fichero urls.py de Django (aunque no es importante que se respete la sintaxis mientras se entienda y la estructura sea similar a la de Django), que refleje el esquema REST anterior (1 punto).

\item Describe el modelo de datos que necesitará esta aplicación. Define las tablas necesarias y los campos necesarios para la funcionalidad descrita. Asegúrate de que incluyes en el modelo de datos la tabla o tablas necesarias para saber el número de páginas vistas por cada navegador, gracias al uso de la imagen transparente que se describe en en enunciado. Hazlo de forma lo más similar posible a lo que tendrías que escribir en el fichero models.py en Django (aunque no es importante que se respete la sintaxis mientras se entienda el modelo de datos que propones) (1 punto).

\item Describe las interacciones HTTP que ocurrirán entre el navegador y cualquier servidor web en el siguiente escenario. El escenario comienza cuando un visitante que accede por primera vez al sitio pone en el navegador la url de la página principal del sitio. A continuación, después de ver esta página principal, pulsa sobre el enlace de un museo, y ve la página de ese museo. El escenario termina cuando el visitante está viendo la página principal de ese museo en su navegador (1 punto).

\item Describe las interacciones HTTP que ocurrirán entre el navegador y cualquier servidor web en el siguiente escenario. El escenario comienza con un visitante que ya ha rellenado, en la página de un museo, el formulario de código con un código válido, y está viendo la página de ese museo. A continuación, rellena el formulario con un comentario (no lo había rellenado nunca antes), y lo envía a MisMuseos. Y a continuación, pone un ``me gusta'' para ese mismo museo (pulsando en el botón correspondiente). El escenario termina cuando el visitante vuelve a ver la página del museo, ya sin el botón de ``me gusta'' y con el comentario pre-relleno en el formulario de comentarios (1 punto).

\item Describe qué tendrá que hacer el ``Servidor del banner'' para poder saber, de forma independiente de MisMuseos, el número de navegadores únicos que están visitando MisMuseos, sin más colaboración por parte de MisMuseos que colocar un banner que él sirva en todas sus páginas (como ya se comentó en la descripción de funcionalidad de MisMuseos).
\end{enumerate}

En todos los escenarios, ten en cuenta que tu respuesta debe considerar toda la funcionalidad que ofrece el servicio, y permitir que ésta pueda proporcionarse. Diseña la aplicación de forma que envíe cookies al navegador sólo cuando sea necesario.

En las respuestas donde describas interacciones HTTP indica para cada una de ellas claramente y en este orden:
  \begin{itemize}
  \item La primera línea de la petición HTTP
  \item Si lo hay, el contenido de la petición
  \item La primera línea de la respuesta HTTP
  \item Si lo hay, el contenido de la respuesta
  \item Una brevísima explicación de para qué se usa la interacción
  \item Tanto en la petición como en la respuesta, las cabeceras con cookies, si es que fueran necesarias para la funcionalidad del escenario que se está describiendo (incluyendo el aspecto que han de tener esas cabeceras). Si la cabecera con cookie va o no dependiendo de algún factor ajeno a tu aplicación, explica cuando irá y cuándo no, y cuál es ese factor.
  \end{itemize}

Además, asegúrate de que describes las interacciones HTTP en el orden en que ocurrirían en el escenario.

\section*{Soluciones}

Hay muchas soluciones posibles. A continuación, una de ellas.

\subsection*{Esquema REST}

Este podría ser el esquema REST:

\begin{tabular}{|l|l|l|}
  \hline
  Recurso & Método & Comentario \\ \hline \hline
  /       & GET    & Página principal (HTML) \\ \hline
  /\{id\_museo\} & GET   & Página de un museo \\
          & POST   & \verb|codigo=codigo| \\
          &        & (introducción de código de museo) \\
          &        & \verb|megusta=True| \\
          &        & (``me gusta'' al museo) \\
          &        & \verb|comentario=texto| \\
          &        & (poner un comentario sobre el museo) \\ \hline
  /iconos/\{num\} & GET & Iconos para los números de ``me gusta'' \\ \hline
\end{tabular}

Las opciones POST para ``me gusta'' y para poner comentario a un museo devolverán 401 (no autorizado) cuando no se haya introducido un código válido para ese museo, y ``funcionarán'' de acuerdo al enunciado cuando se haya introducido.


\subsection*{urls.py}

Lo escribimos sólo para el esquema REST una vez se ha introducido el código:

\begin{verbatim}
from django.conf.urls import url
from . import views

urlpatterns = [
    url(r'^$', views.pagina_principal),
    url(r'^(\d+)$', views.museo),
    url(r'^iconos/(\d+)$', views.trazado),
]
\end{verbatim}

\subsection*{models.py}

Versión simplificada, que cumple el enunciado, aunque podría optimizarse:

\begin{verbatim}
from django.db import models

class Codigos(models.Model):
    codigo = models.CharField(max_length=20)
    museo = models.ForeignKey('Museos')
    navegador = models.ForeignKey('Navegadores', null==True)

class Museos(models.Model):
    nombre = models.TextField()
    id = models.IntegerField()
    direccion = models.TextField()

class Navegadores(models.Model):
    cookie = models.CharField(max_length=32)

class MeGusta(models.Model):
    navegador = models.ForeignKey('Navegadores')
    museo = models.ForeignKey('Museos')

class Comentarios(models.Model):
    codigo = models.ForeignKey('Codigos')
    comentario = models.TextField()
    fecha = models.DateTimeField()
\end{verbatim}

No se incluyen los campos identificador único para cada tabla.

La tabla Codigos tendrá todos los códigos válidos (que se han repartido a los museos), cada uno con su museo correspondiente. Cuando un navegador use un código, se anotará en esta tabla.

\subsection*{Primer escenario}

Todas las interacciones son entre el navegador y el sitio MisMuseos, salvo cuando se indica otra cosa.

\begin{itemize}
\item Petición GET /

\begin{verbatim}
  GET / HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK

  [Página principal, HTML]
\end{verbatim}


\item Petición GET de los iconos de número de ``me gusta'' para cada uno de los museos mostrados. Habrá tantas de estas interacciones como iconos con el número de ``me gusta'' haya en los museos de la página principal. La primera de estas interacciones supone que el número de ``me gusta'' que muestra el icono es 3:

\begin{verbatim}
  GET /iconos/3 HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Imagen con 3 "me gusta", PNG]
\end{verbatim}


\item Petición GET para el banner, realizada no a MisMuseos sino al ``Servidor del banner''

\begin{verbatim}
  GET /banner HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Imagen de banner, PNG]
\end{verbatim}
  

\item Petición GET de la página de museo, una vez el visitante ha pulsado sobre el enlace correspondiente (suponemos que el museo en cuestión tiene el identificador ``12''):

\begin{verbatim}
  GET /12 HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK

  [Página de museo, HTML]
\end{verbatim}

\end{itemize}

En este escenario no han hecho falta cookies, porque no es necesario identificar al navegador (no se introducen códigos, no se pulsa sobre ``me gusta''...)


\subsection*{Segundo escenario}

A continuación, las interacciones son entre el navegador y el sitio MisMuseos. Suponemos que el banner no es preciso volver a pedirlo, porque estará en la cache del navegador. Además, como el visitante ha introducido ya un código válido de museo, se le habrá enviado (con una cabecera ``Set--Cookie'') una cookie, para poder identificarle. Suponemos que el museo al que corresponde la página que está viendo el visitante es el ``12''.

\begin{itemize}
\item Petición POST /12 (para subir un comentario):

\begin{verbatim}
  POST / HTTP/1.1
  ...
  Cookie: navegador=12345ABCDE12345ABCDE12345ABCDE12
  
  comentario="Me ha gustado mucho este museo"
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Página del museo, con el comentario ya puesto, HTML]
\end{verbatim}

\item Petición POST /12 (para indicar ``me gusta''):

\begin{verbatim}
  POST / HTTP/1.1
  ...
  Cookie: navegador=12345ABCDE12345ABCDE12345ABCDE12
  
  megusta=True
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Página del museo, con el comentario y sin el boton "me gusta", HTML]
\end{verbatim}

\end{itemize}


\subsection*{Trazado de navegadores únicos desde servidor de banner}

Basta con que, cada vez que sirve por primera vez un banner de MisMuseos a un navegador, le envíe (con cabecera ``Set-Cookie'') una cookie con un identificador de navegador único. Cuando le llegue una petición que ya tenga cookie, no hará más que servir el banner. El número de navegadores únicos será el número de cookies servidas.



%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Examen de ITT-SAT, 10 mayo de 2017}

Se quiere construir un sitio web, Mensajitos, donde se pueden poner mensajes para que los vean otras personas. La funcionalidad básica del sitio es la siguiente:

\begin{enumerate}
\item En el sitio no hay cuentas para usuarios: toda la funcionalidad está disponible para cualquiera que lo visite.
\item De todas formas, cualquier visitante podrá reservar un nombre que no esté ya en uso para cuando suba información al sitio. Este nombre se mantendrá mientras el visitante utilice el mismo navegador. Para ello se usará el formulario que aparece en la página principal (ver a continuación).
\item La página principal del sitio mostrará a los visitantes un botón para crear un canal de mensajes, y un formulario para elegir un nombre (si se ha elegido ya, en lugar del formulario aparecerá el nombre elegido). El botón permitirá crear un nuevo canal (cada visitante puede crear tantos como quiera), según se indica más abajo. Además, en esta página principal cada visitante verá la lista de los canales que ha creado previamente. Tras crear un nuevo canal, o elegir un nombre, el visitante volverá a ver la página principal del sitio.
\item Cada canal tendrá un nombre de recurso único, que se generará aleatoriamente cuando se cree. Cualquiera que conozca el nombre de recurso de un canal, podrá leer y escribir en él, simplemente accediendo a ese recurso (lo haya creado quien lo haya creado).
\item El recurso correspondiente a cada canal mostrará una página HTML (la ``página del canal'') con los 10 últimos mensajes en el canal, un formulario para poner un nuevo mensaje, y un formulario para poner la url de una imagen (que puede estar en cualquier sitio de Internet, mientras la haga visible mediante HTTP). Cada mensaje que se muestre, se mostrará con el formato:

\begin{verbatim}
Nombre: mensaje
\end{verbatim}

Donde ``Nombre'' es el nombre del visitante (o ``Anónimo'', si no lo ha elegido), y ``mensaje'' es el mensaje en cuestión.

Las urls de imágenes se considerarán también como mensajes, pero antes de mostrarlos como tales (y de almacenarlos en la base de datos), se convertirán a un elemento IMG de HTML. Por ejemplo, la imagen de url \verb|http://fotos.com/123345.jpg| se convertirá en el HTML siguiente (que se considerará el ``mensaje'' en el formato descrito anteriormente):

\begin{verbatim}
<img src="http://fotos.com/123345.jpg" style="width:200px;height:150px;">
\end{verbatim}

Tras poner un nuevo mensaje (o una imagen) en un canal, el visitante vuelve a ver de nuevo la página del canal.

\item Cada canal tendrá también un recurso asociado donde se podrán descargar todos sus mensajes (incluyendo aquellos que se especificaron como imágenes) en formato XML. Este recurso aparecerá también como enlace en la página del canal. El documento XML correspondiente incluirá al menos todos los mensajes que se han escrito en el canal, el nombre del visitante que puso cada uno de ellos, la fecha en que se puso cada uno de ellos, el enlace a la página HTML del canal, la fecha en que se creó el canal, y el nombre del visitante que creó el canal (si alguno de los visitantes implicados no ha especificado un nombre, se usará ``Anónimo'').
\item Todas las páginas HTML del sitio incluirán una imagen de cabecera (banner) que se alojará en el propio sitio.
\end{enumerate}

Teniendo en cuenta los requisitos anteriores, se pide:

\begin{enumerate}
\item Diseña un esquema REST para proporcionar el servicio descrito. Se habrán de especificar los nombres de recurso empleados, y cómo reaccionará la aplicación cuando reciba los métodos POST o GET sobre esas urls (no se usarán los métodos PUT o DELETE). Coloca la información en una tabla, con las urls en una columna, los métodos en otra, y la descripción de lo que realizará la aplicación al recibirlos en la tercera. Escribe también un fichero similar al fichero urls.py de Django (aunque no es importante que se respete la sintaxis mientras se entienda y la estructura sea similar a la de Django), que refleje el esquema REST anterior (1 punto).

\item Describe el modelo de datos que necesitará esta aplicación. Define las tablas necesarias y los campos necesarios para la funcionalidad descrita. Hazlo de forma lo más similar posible a lo que tendrías que escribir en el fichero models.py en Django (aunque no es importante que se respete la sintaxis mientras se entienda el modelo de datos que propones) (1 punto).

\item Describe las interacciones HTTP que ocurrirán entre el navegador y cualquier servidor web en el siguiente escenario. El escenario comienza cuando un visitante que accede por primera vez al sitio pone en el navegador la url de la página principal del sitio. A continuación, después de ver esta página principal, rellena el formulario para elegir un nombre. En este momento, el navegador vuelve a mostrar la página principal, ya con el nombre elegido en lugar del formulario para elegirlo. A continuación el visitante crea un nuevo canal. El escenario termina cuando el visitante vuelve a ver la página principal del sitio, con el nuevo canal ya creado. (1 punto).

\item Describe las interacciones HTTP que ocurrirán entre el navegador y cualquier servidor web en el siguiente escenario. El escenario comienza con un visitante que ya ha reservado nombre y está viendo la página de un canal que aún no tiene mensajes. El visitante rellena el formulario de imagen, poniendo la url de una imagen válida. El escenario termina cuando el visitante vuelve a ver la página del canal, ya con el nuevo mensaje generado a partir de la url de la imagen (1 punto).

\item Escribe cómo podría ser el documento XML para un canal que tiene tres mensajes, uno de los cuales corresponde a la url de una imagen, para un usuario que tiene nombre (1 punto).
\end{enumerate}

En todos los escenarios, ten en cuenta que tu respuesta debe considerar toda la funcionalidad que ofrece el servicio, y permitir que ésta pueda proporcionarse. Diseña la aplicación de forma que envíe cookies al navegador sólo cuando sea necesario.

En las respuestas donde describas interacciones HTTP indica para cada una de ellas claramente y en este orden:
  \begin{itemize}
  \item La primera línea de la petición HTTP
  \item Si lo hay, el contenido de la petición
  \item La primera línea de la respuesta HTTP
  \item Si lo hay, el contenido de la respuesta
  \item Una brevísima explicación de para qué se usa la interacción
  \item Tanto en la petición como en la respuesta, las cabeceras con cookies, si es que fueran necesarias para la funcionalidad del escenario que se está describiendo (incluyendo el aspecto que han de tener esas cabeceras). Si la cabecera con cookie va o no dependiendo de algún factor ajeno a tu aplicación, explica cuando irá y cuándo no, y cuál es ese factor.
  \end{itemize}

Además, asegúrate de que describes las interacciones HTTP en el orden en que ocurrirían en el escenario.

\section*{Soluciones}

Hay muchas soluciones posibles. A continuación, una de ellas.

\subsubsection*{Esquema REST}

\begin{tabular}{|l|l|l|}
  \hline
  Recurso & Método & Comentario \\ \hline \hline
  /       & GET    & Página principal (HTML) \\ \hline
  /       & POST   & Creación de canal \\
          &        & \verb|canal=True| \\
          &        & Reserva de nombre \\
          &        & \verb|nombre=nombre_visitante| \\
          &        & Devolverá el mismo HTML que si se invoca con GET \\
          &        & Este HTML incluirá ya un enlace al nuevo canal \\ \hline
  /\{id\_canal\} & GET & Página del canal \verb|id_canal| (HTML) \\ \hline
  /\{id\_canal\} & POST & Subir mensaje al canal \verb|id_canal| \\
          &        & \verb|mensaje=texto| \\
          &        & Subir imagen al canal \verb|id_canal| \\ 
          &        & \verb|imagen=url| \\
          &        & Devolverá el mismo HTML que si se invoca con GET \\ \hline
  /\{id\_canal\}.xml & GET & Página del canal \verb|id_canal| (XML) \\ \hline
  /banner & GET & Imagen que se usará como banner del sitio \\ \hline
\end{tabular}

\vspace{.3cm}

Nota: No se indica en el enunciado, pero convendrá que la página HTML que se reciba como respuesta a un POST para crear un canal incluya, de forma prominente, un enlace a dicho canal, dado que el usuario necesita saber cuál es.

\subsubsection*{urls.py}

\begin{verbatim}
from django.conf.urls import url
from . import views

urlpatterns = [
    url(r'^$', views.pagina_principal),
    url(r'^banner$', views.banner),
    url(r'^(.+\.xml)$', views.canal_xml),
    url(r'^(.+)$', views.canal)
]
\end{verbatim}

\subsubsection*{models.py}

Versión simplificada, que cumple el enunciado:

\begin{verbatim}
from django.db import models

class Visitante(models.Model):
    nombre = models.CharField(max_length=20, null==True)
    cookie = models.CharField(max_length=64)

class Canal(models.Model):
    recurso = models.CharField(max_length=50)
    creador = models.ForeignKey('Visitante')

class Mensaje(models.Model):
    canal = models.ForeignKey('Canal')
    autor = models.ForeignKey('Visitante')
    texto = models.TextField()
    fecha = models.DateTimeField() # Para fecha en XML
\end{verbatim}


\subsubsection*{Primer escenario}

Todas las interacciones son entre el navegador y el sitio Mensajitos.

\begin{itemize}
\item Petición GET /

\begin{verbatim}
  GET / HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  Set-Cookie: ....; session=session_id

  [Pagina principal, HTML]
\end{verbatim}

session\_id es un identificador de sesión (o de visitante), que se puede enviar también más adelante. Como identificador de sesión que es, será normalmente una cadena de caracteres larga, generada aleatoriamente, y por tanto difícil de adivinar para quien no la conozca.

\item Petición GET /banner (para cargar la imagen del banner)

\begin{verbatim}
  GET /banner HTTP/1.1
  ...
  Cookie: session=session_id
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Banner]
\end{verbatim}

\item Petición POST / (para enviar los datos del formulario de nombre)

\begin{verbatim}
  POST / HTTP/1.1
  ...
  Cookie: session=session_id

  nombre=Nombre_Usado
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Pagina principal, ya sin formulario para elegir nombre, HTML]
\end{verbatim}

La cookie que se envió anteriormente, en realidad se podría enviar aquí, pues hasta este momento no hay nada que asociar a la sesión.

\item Petición POST / (para enviar los datos del botón de crear canal)

\begin{verbatim}
  POST / HTTP/1.1
  ...
  Cookie: session=session_id

  canal=True
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Pagina principal, ahora con el nuevo canal, HTML]
\end{verbatim}

\end{itemize}

\subsubsection*{Segundo escenario}

A continuación, las interacciones son entre el navegador y el sitio Mensajitos. Suponemos que la imagen del banner ya está en la caché del navegador, y por tanto no se pide. Como el navegador ya ha estado visitando el sitio y tiene nombre, ha de haber recibido la cookie de sesión. Suponemos que ``/2732434232'' es el nombre de recurso correspondiente al canal.

\begin{itemize}
\item Petición POST /2732434232 (para poner el mensaje)

\begin{verbatim}
  POST / HTTP/1.1
  ...
  Cookie: session=session_id

  imagen="url"
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Pagina del canal, ahora con un nuevo mensaje con el img correspondiente, HTML
   
   <img src="url" style="width:200px;height:150px;">]
\end{verbatim}

\end{itemize}

Ahora, el navegador tendrá que pedir la imagen que se haya incluido anteriormente (url ``url''). Esta interacción será por lo tanto entre el navegador y el sitio al que apunte la url de la imagen. Suponiendo que la url sear \verb|http://sitio.com/imagen|:

\begin{itemize}
\item Petición GET /imagen (para cargar la imagen)

\begin{verbatim}
  GET /imagen HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Imagen]
\end{verbatim}

\end{itemize}



\subsubsection*{Canal XML}


\begin{verbatim}
<?xml version="1.0" encoding="UTF-8" ?>

<canal>
  <recurso>http://mensajitos.com/3443344453</recurso>
  <creado>20 de marzo de 2016 23:05:05</creado>
  <creador>Flor de Loto</creador>
  <mensaje>
    <texto>Este es un mensaje</texto>
  </mensaje>
    <texto>
      <img src="url" style="width:200px;height:150px;">
    </texto>
  <mensaje>
  </mensaje>
  <mensaje>
    <texto>Este es el último mensaje</texto>
  </mensaje>
</canal>
\end{verbatim}

El texto para el mensaje de la imagen tendría que ponerse ``codificado'' para que no se confunda con texto XML, pero esto no se ha tenido en cuenta en esta solución..



%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Examen de IST-SARO, 10 mayo de 2017}

Se quiere construir un sitio web, Fotogram, donde se pueden poner fotos para que las vean otras personas. La funcionalidad básica del sitio es la siguiente:

\begin{enumerate}
\item En el sitio no hay cuentas para usuarios: toda la funcionalidad está disponible para cualquiera que lo visite.
\item La página principal del sitio mostrará a los visitantes un formulario para crear un nuevo canal de fotos. Este formulario permitirá elegir un nombre para el canal, y el nombre del recurso en que se servirá, que deberá ser (el nombre del recurso) uno que no esté ya en uso en el sitio. Además, en esta página principal cada visitante verá la lista de los canales que ha creado previamente, y junto a cada uno habrá un botón para borrarlo. Tras crear un nuevo canal, o borrarlo, el visitante volverá a ver la página principal del sitio.
\item Cualquiera que conozca el nombre de recurso de un canal, podrá ver sus fotos, y poner fotos en él, simplemente accediendo a ese recurso (lo haya creado quien lo haya creado).
\item El recurso correspondiente a cada canal mostrará una página HTML (la ``página del canal'') con las fotos puestas en ese canal y el comentario asociado a cada foto (si lo hay), y un formulario para poner una nueva foto. Este formulario permitirá especificar la url de una foto (que puede estar en cualquier sitio de Internet, mientras la haga visible mediante HTTP), y opcionalmente un comentario asociado a esa foto. Para cada foto que se muestre se mostrará la foto, el comentario asociado a ella (si lo hay) y la fecha en que se subió la foto.
Tras poner una nueva foto en un canal, el visitante vuelve a ver de nuevo la página de ese canal.
\item El sitio aceptará en un recurso (uno para todo el sitio, no uno por canal), no enlazado en ninguna página del mismo, un documento XML con un listado de fotos a subir a un canal, que se recibirá en el cuerpo de un POST de HTTP. El documento XML incluirá el nombre de recurso del canal donde se subirán las fotos (que deberá existir), y un listado de las fotos a subir. Para cada foto, se incluirá su url y (opcionalmente) su comentario asociado.
\item Todas las páginas HTML del sitio incluirán una imagen de cabecera (banner) que se alojará en el sitio de url \verb|http://banners.com|.

\item Se supone que la cache del navegador está deshabilitada.
\end{enumerate}

Teniendo en cuenta los requisitos anteriores, se pide:

\begin{enumerate}
\item Diseña un esquema REST para proporcionar el servicio descrito. Se habrán de especificar los nombres de recurso empleados, y cómo reaccionará la aplicación cuando reciba los métodos POST o GET sobre esas urls (no se usarán los métodos PUT o DELETE). Coloca la información en una tabla, con las urls en una columna, los métodos en otra, y la descripción de lo que realizará la aplicación al recibirlos en la tercera. Escribe también un fichero similar al fichero urls.py de Django (aunque no es importante que se respete la sintaxis mientras se entienda y la estructura sea similar a la de Django), que refleje el esquema REST anterior (1 punto).

\item Describe el modelo de datos que necesitará esta aplicación. Define las tablas necesarias y los campos necesarios para la funcionalidad descrita. Hazlo de forma lo más similar posible a lo que tendrías que escribir en el fichero models.py en Django (aunque no es importante que se respete la sintaxis mientras se entienda el modelo de datos que propones) (1 punto).

\item Describe las interacciones HTTP que ocurrirán entre el navegador y cualquier servidor web en el siguiente escenario. El escenario comienza cuando un visitante que accede por primera vez al sitio pone en el navegador la url de la página principal del sitio. A continuación, después de ver esta página principal, rellena el formulario para crear un canal. El sitio le devuelve una página donde aparecerá ya el canal recién creado en la lista de canales. El escenario termina cuando el visitante ve en su navegador la página de ese canal, tras haber pulsado sobre él en la lista (1 punto).

\item Describe las interacciones HTTP que ocurrirán entre el navegador y cualquier servidor web en el siguiente escenario. El escenario comienza cuando un visitante que accede por primera vez al sitio pone en el navegador la url de la página de un canal en el que ya hay una foto. A continuación, después de ver la página del canal en cuestión con esa foto, rellena el formulario para poner una nueva foto, indicando su url (no incluye comentario). El escenario termina cuando el visitante ve en su navegador de nuevo la página del canal, ya con la foto que acaba de poner (1 punto).

\item Escribe cómo podría ser el documento XML para subir un listado de fotos a un canal (1 punto).
\end{enumerate}

En todos los escenarios, ten en cuenta que tu respuesta debe considerar toda la funcionalidad que ofrece el servicio, y permitir que ésta pueda proporcionarse. Diseña la aplicación de forma que envíe cookies al navegador sólo cuando sea necesario.

En las respuestas donde describas interacciones HTTP indica para cada una de ellas claramente y en este orden:
  \begin{itemize}
  \item La primera línea de la petición HTTP
  \item Si lo hay, el contenido de la petición
  \item La primera línea de la respuesta HTTP
  \item Si lo hay, el contenido de la respuesta
  \item Una brevísima explicación de para qué se usa la interacción
  \item Tanto en la petición como en la respuesta, las cabeceras con cookies, si es que fueran necesarias para la funcionalidad del escenario que se está describiendo (incluyendo el aspecto que han de tener esas cabeceras). Si la cabecera con cookie va o no dependiendo de algún factor ajeno a tu aplicación, explica cuando irá y cuándo no, y cuál es ese factor.
  \end{itemize}

Además, asegúrate de que describes las interacciones HTTP en el orden en que ocurrirían en el escenario.


\subsection*{Soluciones}

Hay muchas soluciones posibles. A continuación, una de ellas.

\subsubsection*{Esquema REST}

\begin{tabular}{|l|l|l|}
  \hline
  Recurso & Método & Comentario \\ \hline \hline
  /       & GET    & Página principal (HTML) \\ \hline
  /       & POST   & Creación de canal \\
          &        & \verb|canal=Nombre&recurso=Recurso| \\
          &        & Para borrar canal, misma qs, con nombre de canal vacío \\
          &        & Devolverá el mismo HTML que si se invoca con GET \\
          &        & Este HTML incluirá ya un enlace al nuevo canal \\
          &        & cuando se haya creado \\ \hline
  /\{rec\_canal\} & GET & Página del canal \verb|rec_canal| (HTML) \\ \hline
  /\{rec\_canal\} & POST & Subir foto al canal \verb|rec_canal| \\
          &        & \verb|foto=url&comentario=Texto| \\
          &        & Devolverá el mismo HTML que si se invoca con GET \\ \hline
  /subir  & POST   & Página del canal \verb|id_canal| (XML) \\ \hline
\end{tabular}

\subsubsection*{urls.py}

\begin{verbatim}
from django.conf.urls import url
from . import views

urlpatterns = [
    url(r'^$', views.pagina_principal),
    url(r'^(subir)$', views.subir_xml),
    url(r'^(.+)$', views.canal)
]
\end{verbatim}

\subsubsection*{models.py}

Versión simplificada, que cumple el enunciado:

\begin{verbatim}
from django.db import models

class Visitante(models.Model):
    cookie = models.CharField(max_length=64)

class Canal(models.Model):
    recurso = models.CharField(max_length=50)
    nombre = models.CharField(max_length=50)
    creador = models.ForeignKey('Visitante')

class Foto(models.Model):
    canal = models.ForeignKey('Canal')
    url = models.CharField(max_length=50)
    comentario = models.TextField()
    fecha = models.DateTimeField()
\end{verbatim}


\subsubsection*{Primer escenario}

Las interacciones son entre el navegador y el sitio que se indica.

\begin{itemize}
\item Petición GET / (a Fotogram)

\begin{verbatim}
  GET / HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  Set-Cookie: ....; session=session_id

  [Pagina principal, HTML]
\end{verbatim}

session\_id es un identificador de sesión (o de visitante), que se puede enviar también más adelante. Como identificador de sesión que es, será normalmente una cadena de caracteres larga, generada aleatoriamente, y por tanto difícil de adivinar para quien no la conozca.

\item Petición GET /banner (a Banners)

\begin{verbatim}
  GET /banner HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Banner]
\end{verbatim}

\item Petición POST / (para enviar los datos del formulario de canal)

\begin{verbatim}
  POST / HTTP/1.1
  ...
  Cookie: session=session_id

  canal=Nombre&recurso=Recurso
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Pagina principal, ya con enlace al canal recién creado, HTML]
\end{verbatim}

La cookie que se envió anteriormente, en realidad se podría enviar aquí, pues hasta este momento no hay nada que asociar a la sesión.

\item Petición GET /banner (a Banners)

\begin{verbatim}
  GET /banner HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Banner]
\end{verbatim}

\item Petición GET /Recurso (para ver la página del canal, a Fotogram)

\begin{verbatim}
  GET / HTTP/1.1
  ...
  Cookie: session=session_id
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Pagina del canal, HTML]
\end{verbatim}

\item Petición GET /banner (a Banners)

\begin{verbatim}
  GET /banner HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Banner]
\end{verbatim}

\end{itemize}

\subsubsection*{Segundo escenario}

Las interacciones son entre el navegador y el sitio que se indica.

\begin{itemize}
\item Petición GET /Recurso (a Fotogram)

\begin{verbatim}
  GET / HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...
  Set-Cookie: ....; session=session2_id

  [Pagina del canal, que lleva una foto, HTML]
\end{verbatim}

session2\_id es un identificador de sesión (o de visitante), que se puede enviar también más adelante (o incluso no enviar en este escenario, porque según enunciado no se traza qué visitante sube las fotos).

\item Petición GET /banner (a Banners)

\begin{verbatim}
  GET /banner HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Banner]
\end{verbatim}

\item Petición GET /Foto (al sitio donde está la foto)

\begin{verbatim}
  GET /Foto HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Foto, JPEG, PNG, GIF, etc.]
\end{verbatim}


\item Petición POST /Recurso (a Fotogram)

\begin{verbatim}
  POST /Recurso HTTP/1.1
  ...
  Cookie: session=session2_id

  foto=url_foto2&comentario=
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Pagina del canal, que lleva una foto, HTML]
\end{verbatim}

\item Petición GET /banner (a Banners)

\begin{verbatim}
  GET /banner HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Banner]
\end{verbatim}

\item Petición GET /Foto (al sitio donde está la foto)

\begin{verbatim}
  GET /Foto HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Foto, JPEG, PNG, GIF, etc.]
\end{verbatim}

\item Petición GET /Foto2 (al sitio donde está la segunda foto)

\begin{verbatim}
  GET /Foto2 HTTP/1.1
  ...
\end{verbatim}

\item Respuesta

\begin{verbatim}
  HTTP/1.1 200 OK
  ...

  [Foto, JPEG, PNG, GIF, etc.]
\end{verbatim}

\end{itemize}


\subsubsection*{Documento XML}


\begin{verbatim}
<?xml version="1.0" encoding="UTF-8" ?>

<fotos>
  <recurso>/Canal</recurso>
  <foto>
    <url>http://sitiodefotos.com/foto1</url>
  </foto>
  <foto>
    <url>http://sitiodefotos2.com/foto2</url>
    <comentario>Esta es una foto</comentario>
  </foto>
  <foto>
    <url>http://sitiodefotos3.com/foto3</url>
    <comentario>Esta es otra foto</comentario>
  </foto>
</fotos>
\end{verbatim}

\newpage

\input{practica-final-2020-05}

\newpage

\input{practica-final-2019-y-ant}

\newpage
%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\section{Materiales de interés}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Material complementario general}

\begin{itemize}
\item Philip Greenspun, \textsl{Software Engineering for Internet Applications}:\\
  \url{http://philip.greenspun.com/seia/} \\
  utilizado en un curso del MIT \\
  \url{http://philip.greenspun.com/teaching/one-term-web}
\end{itemize}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Introducción a Python}

\begin{itemize}
\item \url{http://www.python.org/doc}

Documentación en línea de Python (incluyendo un Tutorial, los manuales de referencia, HOWTOS, etc. Usa la versión para Python 2.x

\item \url{http://www.diveintopython.org/}

``Dive into Python'', por Mark Pilgrim. Libro para aprender Python, orientado a quien ya sabe programa con lenguajes orientados a objetos.

\item \url{http://wiki.python.org/moin/BeginnersGuide/Programmers}

Otros textos sobre Python, de interés especialmente para quien ya sabe programar en otros lenguajes.

\item \url{http://en.wikibooks.org/wiki/Python_Programming}

``Python Programming'', Wikibook sobre programación en Python.

\item \url{http://en.wikipedia.org/wiki/Python_(programming_language)}

Python en la Wikipedia

\item \url{http://www.python.org/dev/peps/pep-0008/}

Style Guide for Python Code (PEP 8). Esta es la guía de estilo que se puede comprobar con el programa pep8.
\end{itemize}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Aplicaciones web mínimas}

\begin{itemize}
\item \url{http://docs.python.org/dev/howto/sockets.html}

``Socket Programming HOWTO''. Programación de sockets en Python, guía rápida.

\item \url{http://docs.python.org/library/socket.html}

Documentación de la biblioteca de sockets de Python.

\item \url{https://addons.mozilla.org/en-US/firefox/} 

Lista de add-ons y plugins para Firefox.

\end{itemize}

%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{SQL y SQLite}


\begin{itemize}
\item \url{http://www.shokhirev.com/nikolai/abc/sql/sql.html}

``SQLite / SQL Tutorials: Basic SQL'', por Nikolai Shokhirev

\end{itemize}


%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\section{Preguntas más fecuentes}


%%--------------------------------------------------------------------------
%%--------------------------------------------------------------------------
\subsection{Django: Referencia a elementos en otro módulo}

Esta pregunta se plantea de muchas formas, pero la más habitual es cuando queremos usar un módulo Python que hemos construido para proporcionar una cierta funcionalidad (llamémoslo \verb|modulo.py|), y necesitamos referirnos a alguno de sus elementos (variables, funciones, clases) desde \verb|views.py|. ¿Cómo podemos hacerlo?

\textbf{Respuesta}

Hay varias formas de hacerlo, pero una de las que pueden ser más habituales consiste en colocar el módulo en el mismo directorio donde tenemos \verb|views.py| (normalmente, el directorio de la app Django que estamos construyendo), y luego importar el módulo desde \verb|views.py| usando el formato relativo de importación (donde ``.'' se refiere a módulos en el directorio del que importa).

Si lo hacemos así, nos quedarán en el directorio de la app Django los siguientes ficheros:

\begin{itemize}
\item \verb|urls.py|
\item \verb|views.py|
\item \verb|modulo.py|
\item ...
\end{itemize}

Y el fichero \verb|views.py|, si en él queremos utilizar por ejemplo una función \verb|funcion| y una variable \verb|variable| del módulo \verb|modulo.py|, se escribirá así:

\begin{verbatim}
...
from .modulo import funcion, variable

...
... = variable
...
funcion()
...
\end{verbatim}
